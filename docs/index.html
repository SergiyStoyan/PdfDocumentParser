<html>
<head>

<link rel="stylesheet" type="text/css" href="main.css">
<link rel="stylesheet" type="text/css" href="menu_generator.css">

</head>
<body>
<h1>Pdf Document Parser</h1>

<div id='content'>
<h2>Overview</h2>
<p>PdfDocumentParser is a parsing engine designed to extract text/images from PDF documents that conform to a predefined graphic layout - such as invoices and the like. The main parsing approach is based on finding certain text or image fragments in page and then extracting text/images located relatively to those fragments.
<p>Within this scope PdfDocumentParser is capable of the following:
<ul>
<li>processing PDF entities (used for native PDF files);</li>
<li>processing OCR'ed text (used for scanned PDF files);</li>
<li>image search/comparison (used for either native or scanned PDF files);</li>
</ul> 

<p>PdfDocumentParser has been developed to be incorporated into a custom application hopefully without need of change. 
<p>PdfDocumentParser API consists of:
<ul>
<li><a href="#templateEditor">Template Editor</a> where parsing templates can be created or debugged in an easy manner;</li>
<li><a href="#api">Parsing API</a> that allows custom applications to parse PDF files in a custom manner with little effort required;</li>
</ul> 


<h3>Text/image operations</h3>
<p>PdfDocumentParser implements the following strategies to operate with text and images:
<ul>
<li>Extracting text directly from PDF structure. This way is based on native text presentation inside PDF files and should be used whenever possible since it is the most robust and fast.</li>
<li>Getting text from image by OCR technology incorporated into PdfDocumentParser. This option should be chosen only when direct PDF processing does not work. It is usually needed when pdf file consists completely or partially of images such as scanned documents, photos etc. This way cannot not give 100% accuracy against PDF processing and will acceptably work only for images with resolution not less than 300dpi. Also this way is slower.</li>
<li>Image search. This way is used for seeking and comparing page fragments as images. This way is slower than PDF processing and so must be avoided when possible. Also, it may not provide 100% accuracy on scanned documents if they have essential discrepancy in size, contrast, brightness, orientation etc.</li>
</ul>





<h3>Assumptions</h3>
<ul>
<li>a PDF file can consist of multiple documents (e.g. multiple invoices);</li>
<li>a document (e.g. invoice) can consist of multiple pages;</li>
</ul>



<h2><a name="templateEditor">Template Editor</a></h2>
Template Editor is a GUI object that is to be called from a desktop application whenever creating or editing <a href="#template">parsing template</a> is required. 

<h3><a name='tutorial'>Tutorial: set template</a></h3>
<p><a href="#template">A parsing template</a> can be created from scratch or copied from an existing one and modified as needed. 
<p>This tutorial starts with a blank template.
<p class='screenshot_title'>Open a test PDF file in the template editor window:
<img src='img/tutorial0.png'/>

<h4>Create anchors</h4>
<p>Any template needs at least one anchor that will certainly identify type of document and distinguish it from the rest documents you may want to parse. Such an anchor should be targeted to some fragment of a document that is unique to its type. Usually it is a logo of company that issued the document.
<p class='screenshot_title'>Create an anchor that captures the logo and thus detects if the page corresponds to the template:
<img src='img/tutorial1.png'/>

<p>In addition to the first anchor which is a must for any template, one more anchor is usually needed that checks if the page is first page of a document. It is necessary when parsing a multi-document PDF file: when Parser finds this anchor, all the previously extracted fields are recorded and reset.
<p class='screenshot_title'>Create an anchor that checks document's number and thus detects if the page is document's first page:
<img src='img/tutorial2.png'/>

<p><span class='attention'>NOTE: </span>when you select a line in either table, PdfDocumentParser processes it on the current page and the result is displayed in the page viewer and in Status.

<h4>Specify conditions</h4>
<p>Generally conditions can be any that are dictated by the logic of the appication. But usually the application needs to detect if a page at the same time corresponds to the template and is the first page of a document. If this condition is met then this template is chosen to process the document. In the tutorial this condtion has name FirstPageOfDocument. FirstPageOfDocument should be defined by entering a boolean expression that relates on anchors #1 and #2.  
<p class='screenshot_title'>Enter expression "1 & 2" which is true only when both anchors are found together:
<img src='img/tutorial3.png'/>

<p>While in our example FirstPageOfDocument is quite good with 2 anchors and it is so for the most documents, sometimes more anchors are required: for instance when we need to parse different type documents issued by the same company and so have to distinguish document types.



<h4>Set fields</h4>
<p>A field is usually linked an anchor so that when a field's anchor is found, PdfDocumentParser locates the field's rectangle relatively to the anchor's position and extracts text surrounded by it. But a field might have no anchor in which case its selecting rectangle remains in a prefixed location.
<p class='screenshot_title'>Set INVOICE# field:
<img src='img/tutorial4.png'/>

<p>In the same way as above create anchors for the rest fields and link the fields to them.
<p class='screenshot_title'>Setting COST field:
<img src='img/tutorial5.png'/>




<h4>Check template</h4>
<p>When all the conditions and the fields are configured, it's time to walk through the PDF file and see how the template works on every page.
<p class='screenshot_title'>The page #2 begins a new invoice:
<img src='img/tutorial6.png'/>
<p class='screenshot_title'>The page #3 continues and ends an invoice: 
<img src='img/tutorial7.png'/>
<p>The template worked properly on the test file. Click OK to save it.
















<h2><a name='api'>API</a></h2>
Refer <a href='#InvoiceParser'>InvoiceParser</a> for an alive example of using PdfDocumentParser in a custom application.

<h3>Methods</h3>
<table>
<tr><th class='title_column'>Method</th><th>Description</th></tr>
<tr><td class='title_column'>Cliver.PdfDocumentParser.PageCollection::ActiveTemplate</td>
<td>Set active template in PdfDocumentParser.</td></tr>
<tr><td class='title_column'>Cliver.PdfDocumentParser.Page::IsCondition</td>
<td>Checks if a condition defined by active template is met in page.</td></tr>
<tr><td class='title_column'>Cliver.PdfDocumentParser.Page::GetValue</td>
<td>Extracts a field defined by active template from page.</td></tr>
</table>


<h3>Pseudo-code</h3>
Some basic algoritm of processing a PDF file with PdfDocumentParser would look like the following:
<pre><code>
foreach(page in pdf)
{
    foreach(template in templates)
    {
        PdfDocumentParser.ActiveTemplate = template;
        if(PdfDocumentParser.IsCondition(page, 'itIsDocumentFirstPage'))
        {
            object value1 = PdfDocumentParser.GetValue('field1Name');
            do something with value1
            object value2 = PdfDocumentParser.GetValue('field2Name');
            do something with value2
            ...
        }
        else if(PdfDocumentParser.IsCondition(page, 'itIsDocumentLastPage'))
        {
            object value1 = PdfDocumentParser.GetValue('field1Name');
            do something with value1
            object value2 = PdfDocumentParser.GetValue('field2Name');
            do something with value2
            ...
        }
        ...
    }
}
</code></pre>

The main idea is that custom operations are performed depending on conditions defined in templates.









<h2><a name="template">Template</a></h2>
<p>A template is desinged for documents that comply with certain layout (e.g. for invoices issued by the same company). It contains information about which data is to be harvested and how. Applying a template to documents with layout different from that it was designed for obviously brings to mistakes.
<p>When you want to parse a document with a new layout, open Template Editor (how it is done depends on the custom application). Select a sample PDF file to be parsed and having it displayed in the editor you go through the following steps:
<ul>
<li> create <a href="#anchor">anchors</a>;</li>
<li> create <a href="#condition">conditions</a>;</li>
<li> create <a href="#field">fields</a>;</li>
<li> select each created element and see in the status box if it works as expected;</li>
<li> save the template;</li>
</ul>
See <a href="#tutorial">tutorial</a> for more details.



<h3><a name="anchor">Anchor</a></h3>
<p>Anchor is a fragment of either text or image that PdfDocumentParser will look for in PDF page. If found, the anchor is then used by conditions or fields. A not engaged anchor itself is useless. Anchor can be used in the following ways:
<ul>
<li> it can be linked by fields whose positions in page may vary like 'total amount' field whose position usually depends on size of invoice's content;</li> 
<li> it can be engaged in conditions that needs to detect if a certain pattern exists in PDF page;</li>
<li> it can be linked by another anchor so that the latter becomes valid only when the former is found;</li>
</ul>
<p>While native PDF documents in some cases can be parsed without anchors, scanned documents that usually have their margins vary should be processed only with anchors.

<p>Linking to acnhor means that coordinates of a linked field or anchor become relative to the anchor they are linked to. That's PdfDocumentParser first will look for the anchor and if it is found, it will locate the linked fields or anchors depending on the location of their anchor.
<p>The same anchor can be used by multiple conditions and fields.

<h4>General structure of anchor</h4>
<p>An anchor consists of a single or many elements of the same type where the first element is master and the rest are secondary. Position of the master element is considered position of the anchor itself. Secondary elements are searched relatively to the master element's position.  
<p>When an anchor is linked to another anchor, its master element is treated like a secondary element of the linking anchor.


<h4>Create anchor</h4>
<p>To create an anchor, select a new row in the anchors table and choose its type which can be one of the following:

<p> Each of types is processed by its own very different way and so choosing the right type is crucial in successful and robust parsing.
<p>Then select with mouse a rectangle in the document page. The text or image within the selection box will be a fragment that PdfDocumentParser will look for.
<p>If you keep Ctrl pressed while selecting, you can select more than 1 element for the same anchor. To stop selecting, you have to release Ctrl before releasing mouse button.

<h4><a name='anchorPdfText'>Anchor types:</a></h4>
<h5><a name='anchorPdfText'>PdfText</a></h5>
Elements of this type anchor is PDF character boxes which together present a text to be found in page. Every character is separate anchor element.
<table>
<tr><th class='title_column'>Parameter</th><th>Description</th></tr>
<tr><td class='title_column'>Position deviation</td>
<td>It allows to loose bonds between master element and secondary elements in a anchor when for some reason they can shift relatively to each other. It is measured in pixels and must be a positive float number, non-zero even for identical documents bacause of discrepancy reasoned by internal image re-scaling.</td></tr>
<tr><td class='title_column'>Position deviation is absolute</td>
<td>If set then position of each element is compared to the master element's position, otherwise, with the previous element's position. It makes no sense when anchor contains no secondary element.</td></tr>
<td class='title_column'>Search rectangular margin</td>
<td>When set, area where an anchor is looked for is entire page. Otherwise, the searched area is restricted by Search rectangular margin that specifies an area around the rectangle where the anchor was located while creating. It is measured in pixels. It should be set only when it is known that the anchor is always belongs to a cetain part of page. It helps to avoid undesired matching and speed up processing.</td></tr>
</table>

<h5>OcrText</h5>
It is strctured and treated similarly to <a href='#anchorPdfText'>PdfText</a> type except that difference that character boxes are provided by OCR engine instead of PDF entities. 
<table>
<tr><th class='title_column'>Parameter</th><th>Description</th></tr>
<tr><td class='title_column'>Position deviation</td>
<td>See <a href='#anchorPdfText'>PdfText</a>.</td></tr>
<tr><td class='title_column'>Position deviation is absolute</td>
<td>See <a href='#anchorPdfText'>PdfText</a>.</td></tr>
<td class='title_column'>Search rectangular margin</td>
<td>See <a href='#anchorPdfText'>PdfText</a>.</td></tr>
<tr><td class='title_column'>OCR entire page</td>
<td><span class='attention'>NOTE: </span>This switch can completely change parsing. It is because OCR by Tesseract of a larger image and a smaller fragment can give different recognition of the same text. 
<br>Which is better? Sometimes OCR of entire page gives more correct results, sometimes otherwise. But it always takes considerably longer time than OCR of a smaller fragment defined by Search rectangular margin. 
<br>This switch makes sense only when Search rectangular margin is checked, otherwise the entire page is OCR'ed anyway.</td></tr>
</table>

<h5>ImageData</h5>
Elements of this type anchor is images which are page fragments picked by the selection box.
<p><span class='attention'>NOTE: </span> even if an image fragment is looked for within the same page where it was extracted from, it cannot be found without a non-zero tolerance. It happens since hash maps produced after downsizing image and thus results of their pixel interpolation differ for entire image and a fragment. 
<table>
<tr><th class='title_column'>Parameter</th><th>Description</th></tr>
<tr><td class='title_column'>Position deviation</td>
<td>See <a href='#anchorPdfText'>PdfText</a>.</td></tr>
<tr><td class='title_column'>Position deviation is absolute</td>
<td>See <a href='#anchorPdfText'>PdfText</a>.</td></tr>
<td class='title_column'>Search rectangular margin</td>
<td>See <a href='#anchorPdfText'>PdfText</a>. It reduces search time and helps to avoid undesired matching.</td></tr>
<tr><td class='title_column'>Brightness tolerance</td>
<td>While for native PDF documents it can be 0.1 - 0.2, scanned documents which have brightness discrepancy may need it higher. A higher tolerance brings to a less certain result.</td></tr>
<tr><td class='title_column'>Different pixel number tolerance</td>
<td>While for native PDF documents it can be 0.1 - 0.2, scanned documents which have brightness discrepancy may need it higher. A higher tolerance brings to a less certain result.</td></tr>
<tr><td class='title_column'>Find best match</td>
<td>If set, looks for the match with the least difference, otherwise returns the first match within the tolerance specified.</td></tr>
</table>





<h3><a name="condition">Condition</a></h3> 
<p>Condition is a boolean expression that depends on anchors and is configured in every template.
<p>Condition can have meaning True or False which depends on the pair [PDF page, template]. It can be checked by <a href='#api'>PdfDocumentParser API</a> method IsCondition(<condition name>). 
<p>Conditions are identified by their names. Their name collection is dictated by logic of custom application and thus is predefined within its scope and is the same for all templates.

<h4>Mostly used condition</h4>
<p>While condition collection can vary, the following conditons highly likely are required in any application:
<ul>
<li>condition that tells whether document corresponds to this template or not. It is obviously that this condtion must identify its document type with a high confidence;</li>
<li>also, if processed PDF files are multi-document then one more condition that detects first page of documents is required;</li>
</ul>
Usually both of these tasks are united into a single condition, though.

<h4>Boolean expression</h4>
Condition's expression is composed of the following symbols: &lt;anchor id&gt;, '!', '&', '|', '(', ')'. When anchor referenced by &lt;anchor id&gt; is found then it is treated as True, otherwise False. Boolean result of expression is meaning of its condition. 
<p><span class='attention'>NOTE: </span>Operands '&' and '|' are processed consequently meaning that for instance "1 | 2 & 3" and "2 & 3 | 1" are not equivalent. Therefore parentheses should be used to manage precedence of operations.
<p>Sample expressions:
<br> "1"
<br> "1 | (2 & 3)"







<h3><a name="field">Field</a></h3>
<p>Field defines certain text or image that is to be extracted from PDF file. It is configured in every template and can either be linked to an anchor or retain absolute position in page. 
<p>Fields are identified by their names. Their name collection is dictated by logic of custom application and thus is predefined within its scope and is the same for all templates. 
<p>To create a field, select a new row in the fields table and select the area in page were text for this field must be extracted. If the field may have different location in page then it must be linked to an anchor that will detect its proper location for every page. If anchor of a linked field is not found then this field is not found as well. 
<p>When it is known that the field is always has the same position in every document then there is no need to link it to an anchor.

<h4><a name='anchorPdfText'>Field types:</a></h4>
<h5>PdfText</h5>
Its value is a text surrounded by field's rectangle. It is obtained from PDF text entities.
<h5>OcrText</h5>
Its value is a text surrounded by field's rectangle. It is recognized by OCR engine.
<p>For native PDF documents this type should never be used. But for scanned documents it is the only way to get text in digital form that can be recorded in a file or database, indexed, searched and so on.
<h5>ImageData</h5>
Its value is a System.Drawing.Bitmap object that contains fragment of page surrounded by field's rectangle. 
It is used when image is required rather than text or when OCR is not reliable.







<h2>Scanned documents</h2>
<p>Scanned documents are not the first subject for PdfDocumentParser but they are supported. PdfDocumentParser provides auto-deskew and page rotation options which are usually required for scanned documents. 
<p>Because of quality deviations in scanned documents the image comparison tolerance parameters may need to be tuned.
<p>The image resolution in PdfDocumentParser must be set to not less than 300dpi, otherwise OCR will not work. On the other hand, increasing resolution increases processing time. Also, setting resolution in PdfDocumentParser higher than the resolution of original images will not make sense. Image resolution parameter is common for all templates and can be changed in the settings window. 










<h2><a name='InvoiceParser'></a>InvoiceParser</h2>
Invoice Parser is a custom desktop application based on PdfDocumentParser. It can be used as a framwork or sample of incorporating PdfDocumentParser into custom code. Actually its custom specificity lays only in a way how PDF files are parsed while the rest code can be used unchanged as a framework in a new application.
<p>Generally, it does the following:
<ul>
<li>enhances PdfDocumentParser.Template with custom properties that are not related to parsing;</li>
<li>keeps and manages templates;</li>
<li>defines PdfDocumentParser.TemplateForm.TemplateManager and calls PdfDocumentParser.TemplateForm for editing templates;</li>
<li>processes PDF files along the custom needs;</li>
</ul>
<img src='img/invoiceparser2_1.png'/>

<h3>Assumptions</h3>
<ul>
<li>by default, a PDF file can contain only documents of the same type and it can be tuned for every template separately;</li>
<li>once detected, a document is considered continued until next document begins or the file ends;</li>
</ul>
<p>These assumptions is not something deep rooted in the code and can be easily modified.


<h3>Custom template parameters</h3>
<table>
<tr><th class='title_column'>Parameter</th><th>Description</th></tr>
<tr><td class='title_column'>Active</td>
<td>Inactive template is not ignored while parsing.</td></tr>
<tr><td class='title_column'>Group</td>
<td>An optional mark that can be helpful for managing templates.</td></tr>
<tr><td class='title_column'>Order</td>
<td>A weight indicating template's order in check line. It is intended to reduce processing time. Templates with the less order are tried first.</td></tr>
<tr><td class='title_column'>DTLPage</td>
<td>The last page in PDF files that is to be checked for this template. It is intended to reduce processing time.</td></tr>
<tr><td class='title_column'>Filter</td>
<td>It is a Regex applied to PDF file path to recognize the proper template. Optional. It is intended to reduce processing time.</td></tr>
</table>

<h3>Considerations</h3>
<p>When processing documents InvoiceParser applies every active template to every new document to recognize a proper template. So, if you have 50 templates and 1000 files evenly distributed for templates, InvoiceParser will do on average 1000/2 *50 = 25,000 template tries. It may take a considerable time especially with templates using OCR. You can decrease processing time by the following ways:
<ul> 
<li> specify file filters for templates. If it can be done then the tips below are not needed;
<li> specify template orders so that templates that require longer time for recognition have higher order. E.g. templates that use auto-deskew should be checked in the last place;
<li> keep templates that are known as not corresponding to the files to be processed right now, inactive so that PdfDocumentParser will have to choose the right templates from a lesser collection;
<li> as every template is checked for condtion FirstPageOfDocument, avoid using OCR text type in its anchors because this type requires essential time to build an OCR cache of page (being built it is very fast though). This tip makes sense only when the most of templates use Image type in anchors which usually happens. Otherwise, if anchors of the most of templates can use OCR'ed text then it may give a faster parsing;
</ul>

























</div>
<script src="menu_generator.js"></script>

<div class="footer">
        <script src="copyright.js"></script>
        &nbsp;2018,&nbsp;&nbsp;<a href="mailto:sergey.stoyan@gmail.com?Subject=PdfDocumentParser request" target="_top">Sergey Stoyan</a>
</div>

</script>
</body>
</html>