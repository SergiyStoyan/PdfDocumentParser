<html>
<head>
<title>Pdf Document Parser</title>
<link rel="stylesheet" type="text/css" href="main.css">
<link rel="stylesheet" type="text/css" href="menu_generator.css">

</head>
<body>
<div class='header'>
<div class='mainHeader'>Pdf Document Parser</div>
</div>

<div class='content'>
<h1>Overview</h1>
<p>PdfDocumentParser is a parsing engine intended to extract of text/images from PDF documents that conform to a predefined graphic layout - such as invoices and the like. The main parsing approach is based on finding certain text or image fragments in page and then extracting text/images located relatively to those fragments.
<p>Within this scope PdfDocumentParser is capable of the following:
<ul>
<li>operating with text represented by PDF entities (meant for native PDF files);</li>
<li>processing OCR'ed text (meant for scanned PDF files);</li>
<li>image search/comparison/extraction (meant for either native or scanned PDF files);</li>
</ul> 
For more details see <a href='#anchorTypes'>anchor types</a> and <a href='#fieldTypes'>field types</a>.

<p>PdfDocumentParser was designed to be incorporated into custom applications hopefully without need of change. 
<p>PdfDocumentParser API consists of:
<ul>
<li><a href="#templateEditor">Template Editor</a> where parsing templates can be created or debugged in an easy manner;</li>
<li><a href="#api">Parsing API</a> that allows custom applications to parse PDF files in a custom manner with little effort required;</li>
</ul> 
<p>It is developed in .NET.

<h1><a name="templateEditor">Template Editor</a></h1>
Template Editor is a GUI object that can be called from a desktop application whenever editing <a href="#template">template</a> is required. 

<h2><a name='templateEditorApi'>Template Editor API</a></h2>
<table>
<tr><th class='title_column'>Object</th><th>Description</th></tr>
<tr><td class='title_column'><code>Cliver.PdfDocumentParser.TemplateForm</code></td>
<td>.NET Windows Form that provides abilities of editing/debugging a template. Create <code>TemplateForm</code> with a <code>TemplateManager</code> instance as a parameter and call <code>Show()</code> or <code>ShowDialog()</code> on it.</td></tr>
<tr><td class='title_column'><code>Cliver.PdfDocumentParser.TemplateManager</code></td>
<td>Abstract class that must be defined with custom routines. Passed to <code>TemplateForm()</code> as a parameter.</td></tr>
</table>
<p>Refer to <a href='#InvoiceParser'>InvoiceParser</a> as a sample of use.

<h2><a name='tutorial'>Tutorial: configuring template</a></h2>
Because PdfDocumentParser can only be used from within a custom application developed for a certain parsing task, <a href='#InvoiceParser'>InvoiceParser</a> is used as a custom application in this tutorial. 
<p>InvoiceParser was designed to parse PDF files containing invoices and extract the following <a href='#field'>fields</a> from them:
<ul>
<li>INVOICE#</li>
<li>JOB#</li>
<li>PO#</li>
<li>COST</li>
</ul>
It means that any template in InvoiceParser has these fields.

<h3>Assumptions</h3>
PdfDocumentParser does not impose any requirement for PDF files except that that they must conform to some recognizable layout. On the other hand, InvoiceParser, as a custom application, was desinged with the following assumptions about PDF files made:
<ul>
<li>a PDF file can consist of multiple documents (which are invoices);</li>
<li>a document can consist of multiple pages;</li>
<li>any page in a PDF file is a part of a document;</li>
</ul>
<p>These assumptions allow to keep things simple and predefine the <a href='#condition'>condition</a> collection as it will be expalined later.

<h3>Open Template Editor</h3>
<p>A <a href="#template">template</a> can be created from scratch or copied from an existing one and then modified as needed. 
<p>This tutorial starts with a blank template.
<p>Template Editor is open in a custom application, so the way of doing this depends on the application. In <a href='#InvoiceParser'>InvoiceParser</a> click the blank row in the table and then click button Edit.
<p class='screenshot_title'>Open a test PDF file in Template Editor:
<img src='img/tutorial0.png'/>

<h3><a name='tutorialAnchor'>Create anchors</a></h3>
<p>Any template needs at least one <a href='#anchor'>anchor</a> intended to certainly identify the type of a document and distinguish it from the rest documents that may be parsed. Such an anchor should be targeted to some fragment of a document that is unique to its type. Obviously, this fragment must identify the document type with a high confidence. Usually a logo of company that issued the document can serve well this goal.
<p class='screenshot_title'>Create an anchor that captures the logo and thus detects if the page corresponds to the template:
<img src='img/tutorial1.png'/>

<p>Next, from the assumptions made above follows that an invoice can be multi-page. Therefore, InvoiceParser should be capable to detect the beginning page of a document. 
<p class='screenshot_title'>Create an anchor that checks if a page is the first page of a document:
<img src='img/tutorial2.png'/>

<p><span class='attention'>NOTE: </span>when you select a row in either table: anchors, conditions or fields, its status is updated in the head cell and the captured place is displayed in the page viewer.

<h3><a name='tutorialCondition'>Specify conditions</a></h3>
<p>In general, <a href='#condition'>condition</a> collection can be any that is predefined by a custom application. In InvoiceParser, a single condition named FirstPageOfDocument is predefined. Yet not only InvoiceParser, but any application highly likely requires a condition like that as it would need to examine every PDF page for the following:
<ul>
<li>does a page belong to a document that this template was created for?</li>
<li>if it does, is the page the first page of a document?</li>
</ul>
According to the assumptions declared in the beginning, if condition FirstPageOfDocument is met on a page then this template has to be chosen to process the page and the next ones until a new document beginning is detected. 
<p>Sometimes one more condition that checks if a page is the last page of a document may be required but the necessity of it depends on what is known about PDF files to be parsed. Within the assumptions made, this condition would be redundant.

<p class='screenshot_title'>FirstPageOfDocument must relate on anchors #1 and #2 created before exactly for it. Configure it with boolean expression "1 & 2" which is True only when both anchors are found together:
<img src='img/tutorial3.png'/>

<p>While in this sample FirstPageOfDocument is quite good with 2 anchors, sometimes more anchors may be needed: for instance when the same company issues documents of different types and thus company's logo is not sufficient to detect the type.



<h3><a name='tutorialField'>Set fields</a></h3>
<p>Though some of the <a href='#field'>fields</a> in this sample seem not to need linking to anchors, it is advisable to always link fields to anchors to drastically reduce the probability of mistaken parsing. It will be done so in this tutorial.
<p class='screenshot_title'>Set <a href='#field'>field</a> INVOICE#:
<img src='img/tutorial4.png'/>

<p class='screenshot_title'>In the same way as above set the rest fields and create anchors for them:
<img src='img/tutorial5.png'/>




<h3>Check template</h3>
<p>When all the conditions and fields are set, it's time to walk through the file and see how the template works on every page.
<p class='screenshot_title'>The page #2 begins a new invoice:
<img src='img/tutorial6.png'/>
<p class='screenshot_title'>The page #3 continues and ends an invoice: 
<img src='img/tutorial7.png'/>
<p>The template worked properly on the test file. Click OK to save it.
















<h1><a name='api'>API</a></h1>
Refer to <a href='#InvoiceParser'>InvoiceParser</a> as an alive example of using PdfDocumentParser in a custom application.

<h2>Methods&properties</h2>
<table>
<tr><th class='title_column'>Method | property</th><th>Description</th></tr>
<tr><td class='title_column'><code>Cliver.PdfDocumentParser.PageCollection::ActiveTemplate</code></td>
<td>Set active template in PdfDocumentParser.</td></tr>
<tr><td class='title_column'><a name='IsCondition'><code>Cliver.PdfDocumentParser.Page::IsCondition()</code></a></td>
<td>Checks if a condition is met in page.</td></tr>
<tr><td class='title_column'><code>Cliver.PdfDocumentParser.Page::GetValue()</code></td>
<td>Extracts a field from page. If anchor of the field was not found, NULL is returned.</td></tr>
</table>


<h2>Pseudo-code</h2>
A basic algorithm of processing a PDF file with PdfDocumentParser would look like the following:
<pre>
foreach(page in PdfFile)
{
    if(PdfDocumentParser.ActiveTemplate == null)
    {
        foreach(template in templates)
        {
            PdfDocumentParser.ActiveTemplate = template;
            if(PdfDocumentParser.IsCondition(page, "DocumentFirstPage"))
                break;
            PdfDocumentParser.ActiveTemplate = null;
        }
    }
    if(PdfDocumentParser.ActiveTemplate != null)
    {      
        if(PdfDocumentParser.IsCondition(page, "Field1Page"))
        {
            object value1 = PdfDocumentParser.GetValue(page, "field1");
            ...do something with value1...
        }
        if(PdfDocumentParser.IsCondition(page, "Field2Page"))
        {
            object value2 = PdfDocumentParser.GetValue(page, "field2");
            ...do something with value2...
        }
        ...
        if(PdfDocumentParser.IsCondition(page, "DocumentLastPage"))
            PdfDocumentParser.ActiveTemplate = null;
    }
}
</pre>

The main idea is that custom operations are performed depending on conditions.









<h1><a name="template">Template</a></h1>
<p>To parse documents that comply with a certain layout (e.g. invoices issued by the same company) a parsing template is configured. It contains information about which data is to be extracted and how. Obviously, applying a template to documents with layout different from that it was designed for, brings to incorrect parsing.
<p>Configuring a template is done in <a href='#templateEditor'>Template Editor<a/> and consists of the following steps:
<ul>
<li>create <a href="#anchor">anchors</a> required for <a href="#condition">conditions</a>;</li>
<li>define <a href="#condition">conditions</a> using created anchors;</li>
<li>set <a href="#field">fields</a>;</li>
<li>create <a href="#anchor">anchors</a> for fields that need it and link those fields to them;</li>
<li>test the template on the rest pages of the file;</li>
</ul>
Refer to <a href="#tutorial">the tutorial</a> for more details.



<h2><a name="anchor">Anchor</a></h2>
<p>An anchor is a fragment of either text or image that PdfDocumentParser will look for in a PDF page. If found, the anchor is then used by conditions or fields. A not engaged anchor itself is useless. Anchor can be used in the following ways:
<ul>
<li> it can be linked by fields whose positions in page may vary like 'total amount' field whose position usually depends on size of invoice's content;</li> 
<li> it can be engaged in <a href="condition">conditions</a> that need to detect if a certain pattern exists in a PDF page;</li>
<li> it can be linked by another anchor so that the latter becomes valid only when the former is found;</li>
</ul>
<p>While native PDF documents in some cases can be parsed without anchors, scanned documents which usually have their margins vary should be processed only with anchors.

<p>Linking to an anchor means that coordinates of a linked field or anchor become relative to the anchor they are linked to. That's PdfDocumentParser first will look for the anchor and then, if it is found, it will locate the linked fields or anchors depending on the location of their anchor.
<p>The same anchor can be used by multiple conditions, fields and anchors.

<h3>General structure of anchor</h3>
<p>An anchor consists of a single or many elements of the same type where the first element is master and the rest are secondary. Position of the master element is considered the position of the anchor itself. Secondary elements are searched relatively to the master element's position. 
<p>If some of an anchor's elements is not found then the anchor itself is not found.
<p>The rectangle where an anchor was located on the page while creating, is named 'initial rectangle' and contains all the anchor's elements.

<h3>Anchor linked to an anchor</h3>
<p>When an anchor is linked to another anchor, its master element is treated like a secondary element of the linking anchor. <p>A linked anchor is named 'child' of the linking one which is named 'parent'. Being a parent does not impose any restriction to an anchor. 
<p>The number of anchors consistently linked in a chain can be any.


<h3>Create anchor</h3>
<p>To create an anchor, click the blank row in anchors table and choose its <a href='#anchorTypes'>type</a>. Then select with mouse a rectangle in the document page. The text or image within the selection box will be a fragment that PdfDocumentParser will look for. For more details refer to <a href='#tutorialAnchor'>the tutorial</a>.
<p>If you keep Ctrl pressed while selecting, you can select more than 1 element for the same anchor. To stop selecting, you have to release Ctrl before releasing the mouse button.

<h3><a name='anchorTypes'>Anchor types</a></h3>
<p>Each of types is processed by its own very different way therefore choosing the right type is crucial in successful and robust parsing.

<h4><a name='anchorPdfText'>PdfText</a></h4>
<p>This type is based on native text presentation inside a PDF file. Elements of this type are character boxes extracted from PDF entities which together present a text to be found in page. Every character is a separate anchor element.
<p>It should be used whenever possible because it is most robust and fast. 

<table>
<tr><th class='title_column'>Parameter</th><th>Description</th></tr>
<tr><td class='title_column'>Position deviation</td>
<td>It allows to loose bonds between master element and secondary elements in a anchor when for some reason they can shift relatively to each other. It is measured in pixels and must be a positive float number, non-zero even for identical documents because of discrepancy reasoned by internal image re-scaling.</td></tr>
<tr><td class='title_column'>Position deviation is absolute</td>
<td>If set then position of each element is compared to the master element's position, otherwise, with the previous element's position. It makes no sense if the anchor contains no secondary element.</td></tr>
<td class='title_column'>Search rectangle margin</td>
<td>When set, area where the anchor is looked for is the entire page. Otherwise, the searched area is restricted by Search rectangle margin that specifies a rectangular area around the anchor's initial rectangle. It is measured in pixels. It should be set only when it is known that the anchor is always belongs to a certain part of page. It helps to avoid undesired matching and speed up processing.</td></tr>
</table>

<h4>OcrText</h4>
<p>This type works similarly to <a href='#anchorPdfText'>PdfText</a> type except that difference that character boxes are provided by OCR engine instead of native PDF entities.
<p>It should be used only when PdfText type does not work which happens on scanned or mixed documents. It cannot not give 100% accuracy like PdfText type does and will acceptably work only for images with resolution not less than 300dpi. Also, its perfomance is slower than that of PdfText type. 
<table>
<tr><th class='title_column'>Parameter</th><th>Description</th></tr>
<tr><td class='title_column'>Position deviation</td>
<td>See <a href='#anchorPdfText'>PdfText</a>.</td></tr>
<tr><td class='title_column'>Position deviation is absolute</td>
<td>See <a href='#anchorPdfText'>PdfText</a>.</td></tr>
<td class='title_column'>Search rectangle margin</td>
<td>See <a href='#anchorPdfText'>PdfText</a>.</td></tr>
<tr><td class='title_column'>OCR entire page</td>
<td><span class='attention'>NOTE: </span>This switch can completely change parsing. It is because OCR by Tesseract of a larger image and a smaller fragment can give different recognition of the same text. 
<br>Which is better? OCR of entire page gives sometimes more correct results, sometimes otherwise. But it always takes considerably longer time than OCR of a smaller fragment defined by Search rectangle margin. 
<br>This switch makes sense only if Search rectangle margin is set, otherwise the entire page is OCR'ed anyway.</td></tr>
</table>

<h4>ImageData</h4>
<p>Elements of this type are images which are fragments of page selected while creating an anchor.
<p>This type should be used when anchoring to images, not to text, is required. Its perfomance is slower than that of PdfText type. Also, it may not provide 100% accuracy on scanned documents if they have essential discrepancy in size, contrast, brightness, orientation etc. In such cases, OcrText type may work better.
<p><span class='attention'>NOTE: </span> even when an image fragment is sought within the same page where it was extracted from, it cannot be found without a non-zero tolerance. It happens because the search hash is produced after downsizing an image and thus pixel interpolation while restoring to the initial size gives different results for an entire image and for its fragment. 
<table>
<tr><th class='title_column'>Parameter</th><th>Description</th></tr>
<tr><td class='title_column'>Position deviation</td>
<td>See <a href='#anchorPdfText'>PdfText</a>.</td></tr>
<tr><td class='title_column'>Position deviation is absolute</td>
<td>See <a href='#anchorPdfText'>PdfText</a>.</td></tr>
<td class='title_column'>Search rectangle margin</td>
<td>See <a href='#anchorPdfText'>PdfText</a>. It reduces search time and helps to avoid undesired matching.</td></tr>
<tr><td class='title_column'>Brightness tolerance</td>
<td>While for native PDF documents it can be 0.1 - 0.2, scanned documents which have brightness discrepancy may need it higher. A higher tolerance brings to a less certain result.</td></tr>
<tr><td class='title_column'>Different pixel number tolerance</td>
<td>While for native PDF documents it can be 0.1 - 0.2, scanned documents which have brightness discrepancy may need it higher. A higher tolerance brings to a less certain result.</td></tr>
<tr><td class='title_column'>Find best match</td>
<td>If set, looks for the match with the least difference, otherwise returns the first match within the tolerance specified.</td></tr>
</table>





<h2><a name="condition">Condition</a></h2> 
<p>A condition is a boolean expression that depends on anchors and is configured individually in every template.
<p>A condition can have meaning True or False which depends on pair [PDF page, template]. In the custom code it is checked by PdfDocumentParser <a href='#api'>API</a> method <a href='#IsCondition'><code>IsCondition(<condition name>)</code></a>. 
<p>Conditions are identified by their names. A condition collection is dictated by the logic of a custom application, therefore condition names are predefined within the application's scope and are the same for all templates that belong to it.

<h3>Mostly used condition</h3>
<p>While condition collection can vary, the following checks highly likely are needed in any application:
<ul>
<li>does a document correspond to the template?</li>
<li>is a page the first page of a document?</li>
</ul>
Usually these checks are combined into a single condition which thus allows choosing the right template while parsing a PDF file page by page consequently.
<p>Depending on the parsing task, more conditions may be required: for instance that one that can detect the last page of a document.

<h3>Boolean expression</h3>
Condition expressions are composed of the following symbols: &lt;anchor id&gt;, '!', '&', '|', '(', ')'. When anchor referenced by &lt;anchor id&gt; is found then it is treated as True, otherwise False. Meaning of a condition is the boolean result of its expression. 
<p><span class='attention'>NOTE: </span>Operands '&' and '|' are processed consequently, therefore for instance "1 | 2 & 3" and "2 & 3 | 1" are not equivalent. Parentheses should be used to manage precedence of operations.
<p>Sample expressions:

<table>
<tr><th class='title_column_center'>Expression</th><th>Description</th></tr>
<tr><td class='title_column_center'>1</td>
<td>The simplest expression which is True when anchor #1 is found.</td></tr>
<tr><td class='title_column_center'>(1 | 7 | 8) & 2</td>
<td>Such kind of expression is useful for instance when a company can use different logos for documents of the same structure. In such a case, instead of creating several separate templates, a single template can be configured that can accept more than 1 logo image. Respectively anchors #1,7 and 8 are targeted to the expected logos.</td></tr>
<td class='title_column_center'>!2 | (2 & 3)</td>
<td>This expression could be used for instance for a decision whether a certain field should be parsed or passed off.</td></tr>
</table>

For more details refer to <a href='#tutorialCondition'>the tutorial</a>.





<h2><a name="field">Field</a></h2>
<p>A field defines certain text or image that is to be extracted from a PDF page. 
<p>Fields are identified by their names. A field collection is dictated by the logic of a custom application and thus their names are predefined within its scope and are the same for all templates that belong to it. 
<p>A field optionally can be linked to an anchor. When a field has no anchor, its selecting rectangle retains the initial position which was its position during creation. When a field has anchor, PdfDocumentParser locates the field's rectangle relatively to its anchor's actual position so that if on some page the anchor shifts, the field shifts together with it. It is advisable always to link fields to anchors thus drastically decreasing probability of incorrect parsing.
<p>When it is definitely known that a field appears on every page and always keeps the same position then there is no need to link it to an anchor.

<h3>Set field</h3>  
<p>To set a field, select the respective row in fields table, choose its <a href='#fieldTypes'>type</a> and then select in the PDF view a rectangle from where text or image must be extracted. Then, if a field has a variable position then it must be linked to an anchor that will detect its proper location on a page. If the anchor of a linked field is not found then this field is not found too. For more details refer to <a href='#tutorialField'>the tutorial</a>.

<h3><a name='fieldTypes'>Field types</a></h3>
<h4><a name='fieldPdfText'>PdfText</a></h4>
Its value is a text surrounded by field's rectangle. It is obtained from PDF entities.
<h4>OcrText</h4>
Its value is a text surrounded by field's rectangle. It is recognized by OCR engine.
<p>For native PDF documents this type should never be used. But for scanned documents it is the only way to get text in the digital form which can be recorded in a file or database, indexed, searched and so on.
<h4>ImageData</h4>
Its value is a <code>System.Drawing.Bitmap</code> object that contains a fragment of page surrounded by the field's rectangle. 
<p>It is used when image is required rather than text or when OCR is not reliable.







<h1>Scanned documents</h1>
<p>Scanned documents are not the first subject for PdfDocumentParser but they are supported. PdfDocumentParser provides auto-deskew and page rotation options which are usually needed for scanned documents. 
<p>Because of quality deviations in scanned documents the image comparison tolerance parameters may need to be tuned for every anchor.
<p>The image resolution in PdfDocumentParser must be set to not less than 300dpi, otherwise OCR will not work properly. The higher the resolution, the better OCR is. On the other hand, increasing resolution increases processing time. Also, setting resolution in PdfDocumentParser higher than the resolution of original images will not make sense. Image resolution parameter is common for all templates and is set in the configuration window. 










<h1><a name='InvoiceParser'></a>InvoiceParser</h1>
Invoice Parser is a custom desktop application based on PdfDocumentParser. It can be used as an example of incorporating PdfDocumentParser into a custom code. Also, its custom specificity lays only in a way how PDF files are parsed, therefore the rest code can be used unchanged as a framework in a new application.
<p>Generally, it does the following:
<ul>
<li>enhances <code>PdfDocumentParser.Template</code> with custom properties that are not related to parsing;</li>
<li>stores and manages templates;</li>
<li>defines <code>PdfDocumentParser.TemplateForm.TemplateManager</code> and calls <code>PdfDocumentParser.TemplateForm</code> for editing templates;</li>
<li>processes PDF files in accordance with the custom needs;</li>
</ul>
<img src='img/invoiceparser2_1.png'/>

<h2>Assumptions</h2>
<ul>
<li>by default, a PDF file can contain documents of the same type only. However, it can be tuned for every template separately;</li>
<li>once detected, a document is considered continued until the next document begins or the file ends;</li>
</ul>
<p>These assumptions is not something deep rooted in the code and can be easily modified.


<h2>Custom template parameters</h2>
<table>
<tr><th class='title_column'>Parameter</th><th>Description</th></tr>
<tr><td class='title_column'>Active</td>
<td>Inactive template is ignored while parsing.</td></tr>
<tr><td class='title_column'>Group</td>
<td>An optional mark that can be helpful for managing templates.</td></tr>
<tr><td class='title_column'>Order</td>
<td>A weight indicating template's order in check line. It is intended to reduce processing time. Templates with the less order are tried first.</td></tr>
<tr><td class='title_column'>DTLPage</td>
<td>The last page in PDF files that is to be checked for this template. It is intended to reduce processing time.</td></tr>
<tr><td class='title_column'>Filter</td>
<td>It is a Regex applied to PDF file path to recognize the proper template. Optional. It is intended to reduce processing time.</td></tr>
<tr><td class='title_column'>Filter</td>
<td>It is a Regex applied to PDF file path to recognize the proper template. Optional. It is intended to reduce processing time.</td></tr>
<tr><td class='title_column'>SFTRegex</td>
<td>It is a Regex that matches to names of templates that can share the same PDF file. By default it is NULL meaning that such a template if chosen for processing a PDF file cannot be changed for this file.</td></tr>
</table>

<h2>Considerations</h2>
<p>When processing documents InvoiceParser applies every active template to every new document to recognize a proper template. So, if you have 50 templates and 1000 files evenly distributed for templates, InvoiceParser will do on average 1000/2 *50 = 25,000 template tries. It may take a considerable time especially when templates use OCR. Processing time can be reduced by the following ways:
<ul> 
<li> specify file filters for templates. If it can be done then the other tips are not needed;
<li> specify template orders so that templates that require a longer time for recognition have a higher order. E.g. templates that use auto-deskew should be checked in the last place;
<li> keep templates that are known as not corresponding to the files to be processed right now, inactive;
</ul>

























</div>

<div class='footer'>
        <script src='copyright.js'></script>
        &nbsp;2018,&nbsp;&nbsp;<a href='mailto:sergey.stoyan@gmail.com?Subject=PdfDocumentParser request' target='_top'>Sergey Stoyan</a>
</div>

<script src='menu_generator.js'></script>

</body>
</html>