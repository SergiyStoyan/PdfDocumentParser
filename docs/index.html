<html>
<head>
<title>Pdf Document Parser</title>
 
<link rel="stylesheet" type="text/css" href="main.css">
<link rel="stylesheet" type="text/css" href="menu_generator.css">

<link href="prism.css" rel="stylesheet" />

</head>
<body>
<script src="prism.js"></script>
<div class='header'>
<div class='mainHeader'>Pdf Document Parser</div>
</div>

<div class='content'>
<h1><a name='overview'>Overview</a></h1>
<p>PdfDocumentParser is a .NET engine designed for parsing PDF documents that conform to predictable graphical layouts - such as forms, CV's, invoices and the like. PdfDocumentParser was designed to be incorporated into an application, thus, drastically reducing efforts of building PDF parsers. 

<p>PdfDocumentParser provides the following facilities:
<ul>
<li><a href="#templateEditor">Template Editor</a> where parsing templates can be created and debugged in an easy manner;</li>
<li><a href="#parsingApi">Parsing API</a> that allows parsing PDF files in a custom manner with a little effort required;</li>
</ul> 

<h2><a name='approach'>Approach</a></h2>
<p>The main approach of parsing by PdfDocumentParser is based on finding certain text or image fragments on a PDF page and then extracting text/images located relatively to those fragments.
<p>Within this scope PdfDocumentParser is capable of the following:
<ul>
<li>search/extract text represented by PDF entities - meant for native PDF files;</li>
<li>search/extract text obtained by OCR - meant for scanned PDF files;</li>
<li>search/compare/extract page fragments as images - meant for either native or scanned PDF files;</li>
</ul> 
For more details see <a href='#anchorTypes'>anchor types</a> and <a href='#fieldTypes'>field types</a>.

<p>Also, PdfDocumentParser allows an application to check custom <a href='#condition'>conditions</a> on a PDF page to decide which actions should be taken on it.


<h2><a name='customApplication'>Developing application</a></h2>
<p>An application based on PdfDocumentParser has to care about the following main aspects:
<ul>
<li>provide storage and management of parsing templates;</li>
<li>allow a user to create and modify templates with <a href="#templateEditor">Template Editor</a>;</li>
<li>implement a custom algorithm of processing PDF files:
    <ul>
    <li>choose a template to be applied on a PDF page;</li>
    <li>process data parsed by the chosen template;</li>
    </ul> 
</li>
</ul> 
For more details see <a href='#pseudoCode'>pseudo-code</a>, <a href='#tutorialParsingApi'>Parsing API tutorial</a> and <a href='#InvoiceParser'>InvoiceParser</a>.

<h3><a name='creatingSolution'>Visual Studio</a></h3>
In Visual Studio:
<ul>
<li>create your project;</li>
<li>add PdfDocumentParser project to the solution;</li>
<li>reference PdfDocumentParser in your project;</li>
<li>update nuget packages for the solution;</li>
<li>start developing your parser using PdfDocumentParser API;</li>
</ul> 



<h2><a name='licensing'>Licensing</a></h2>
PdfDocumentParser is provided under GNU Affero General Public License v3.0. Contact me if you want another license.
<p>Be noticed that PdfDocumentParser may use third-party software as command line tools or linked libraries that are licensed separately.


<h2><a name='repository'>Repository</a></h2>
Open <a href='https://github.com/sergeystoyan/PdfDocumentParser' target='_blank'>repository</a>.


<h2><a name='gettingStarted'>Getting started</a></h2>
To get the idea of what can be done with PdfDocumentParser and how it is used, review <a href='#tutorialParsingApi'>tutorial of Parsing API</a> and then <a href='#tutorialTemplateEditor'>tutorial of setting template</a>.  


<h1><a name="template">Template</a></h1>
<p>A parsing template is intended for parsing documents that comply with the same layout (e.g. invoices issued by the same company). It contains information what data should be extracted, where and how. 
<p>Obviously, applying a template to documents with layouts different from that it was designed for, brings to incorrect parsing.
<p>Creating and modifying templates is preformed with <a href='#templateEditor'>Template Editor<a/>



<h2><a name='anchor'>Anchor</a></h2>
<p>An anchor is a fragment of either text or image captured on a PDF page in order to be searched on any page needed afterwards. An anchor can be used in the following ways:
<ul>
<li><a href="#field">fields</a> can be linked to it;</li> 
<li>it can be engaged in <a href="#condition">conditions</a>;</li>
<li>other <a href='#anchor'>anchors</a> can be linked to it;</li>
</ul>
<p>Being used does not impose any restriction on an anchor. Thus, an anchor can be used in many ways at the same time.

<p>Anchors are identified by their numbers assigned automatically.
<p>An anchor consists of a single or many elements of the same type which can be either text characters or images. The first element is 'master' and the rest are 'secondary'. Position of its master element is position of the anchor itself. 
<p>When an anchor is searched on a page, its master element is searched first and, if found, then its secondary elements are checked being bonded to the master position. Anchor is set found only when all its elements are found. 
<p><span class='attention'>NOTE: </span>Only the first match on page is used to locate anchor. No further match is searched.


<h3>Compound anchor</h3>
<p>A compound anchor is a chain of successively linked anchors. It is represented by the last anchor in the chain which gives one's position to it. 
<p>A compound anchor is set not found when some of its anchors is not found.
<p>Compound anchors are required for more conditioned search. Usage of compound anchors and simple anchors is the same.
<p>A linked anchor is named 'child' of the linking one which is named 'parent'. When an anchor is linked to another anchor, its search area (when it is set to not entire page) becomes related to its parent anchor's position. That means that a parent anchor is searched not until its first match found as done for a stand-alone anchor, but until a match found that satisfies to the child anchor as well. 
<br>More specifically, when a child anchor has <a href='#anchorPdfText'>Search Rectangle Margin</a> set to not entire page,  position of its parent anchor, while searching as parent, may differ from position of the very same anchor, while searching stand-alone. 
<br>The same consideration is true for child anchors too: an anchor, whose search area is set to not entire page, may change its position after linking to another anchor. 
<br>Thus, <span class='attention'>NOTE: </span>An anchor acting stand-alone and the same anchor acting as a part of a compound anchor should be considered different anchors because they can have different positions.
<p>Number of anchors in a compound anchor can be any. Though, it should be taken to account that processing time of recursive search performed for a compound anchor exponentially increases with the chain length.



<h3><a name='anchorTypes'>Anchor types</a></h3>
<p>Each of types is processed by its own very different way, therefore choosing the right type is crucial in successful and robust parsing. 


<h4><a name='anchorPdfText'>PdfText</a></h4>
<p>This type can only be used to anchor to text. It should be used whenever possible because it is most robust and fast. 
<p>It is based on the native text presentation inside a PDF file. Elements of this type are character boxes extracted from PDF entities. Every character is a separate anchor element. Together they present a text fragment to be found on page.

<table>
<tr><th class='title_column'>Parameter</th><th>Description</th></tr>
<tr><td class='title_column'>Position deviation</td>
<td>It allows to loose bonds between master element and secondary elements in an anchor when for some reason they can shift relative to each other. It is measured in pixels and must be a positive float number, non-zero even for identical documents because of discrepancy reasoned by internal image re-scaling.
<br>It makes no sense for an anchor having no secondary element.</td></tr>
<tr><td class='title_column'>Position deviation is absolute</td>
<td>If True, position deviation of every secondary element is measured by the master element's position, otherwise, by position of the previous element. The latter is looser than the former.</td></tr>
<td class='title_column'>Search rectangle margin</td>
<td>When set, the area where the anchor is searched is the entire page. Otherwise, the search area is restricted by Search rectangle margin that specifies a rectangular area around the anchor's initial rectangle which is the rectangle where the anchor was located on page while creating. It is measured in pixels. It should be used only when it is known definitely that the anchor is always located in a certain part of page. It helps to avoid undesired matching and speed up processing.</td></tr>
</table>

<h4>OcrText</h4>
<p>This type can only be used to anchor to text. It should be used only when PdfText does not work which happens on scanned or mixed documents. 
<p>It works similarly to <a href='#anchorPdfText'>PdfText</a> type except that difference that character boxes are provided by OCR engine instead of native PDF entities.
<p>In contrast to PdfText, OcrText type does not ensure 100% accuracy and can acceptably work only with images of resolution not less than 300dpi (see <a href='#PdfPageImageResolution'>PdfPageImageResolution</a> parameter). 
<table>
<tr><th class='title_column'>Parameter</th><th>Description</th></tr>
<tr><td class='title_column'>Position deviation</td>
<td>See <a href='#anchorPdfText'>PdfText</a>.</td></tr>
<tr><td class='title_column'>Position deviation is absolute</td>
<td>See <a href='#anchorPdfText'>PdfText</a>.</td></tr>
<td class='title_column'>Search rectangle margin</td>
<td>See <a href='#anchorPdfText'>PdfText</a>.</td></tr>
<tr><td class='title_column'>OCR entire page</td>
<td><span class='attention'>NOTE: </span>This switch can completely change parsing. It is because OCR by Tesseract of a larger and a smaller fragments can give different recognition of the same text. 
<br>Which is better? OCR of entire page gives sometimes more correct results, sometimes otherwise. But it always takes considerably longer time than OCR of a smaller fragment which is defined by Search rectangle margin. 
<br>This switch makes sense only if Search rectangle margin is on, otherwise the entire page is OCR'ed anyway.</td></tr>
</table>

<h4>ImageData</h4>
<p>This type is used to anchor to images. 
<p>Elements of an ImageData anchor are images that were selected on PDF page while creating the anchor.
<p>For native PDF documents where images are without discrepancy in quality, ImageData type works quite well. 
<p>When anchoring to a text which is presented by image as happens in scanned or mixed documents, there is a choice between ImageData and OcrText types. Which one to choose? If a target image do not change much from document to document and looks the same (no matter how poor its quality is), ImageData is more reliable and fast. However, if a target image has essential discrepancy in size, contrast, brightness, orientation etc. in documents, OcrText may work better.
<p><span class='attention'>NOTE: </span> even when an image fragment is searched within the same page where it was extracted from, it cannot be found without a non-zero tolerance. It happens because search hashes of a whole page image and a fragment are produced after downsizing them, and then, when restoring from the hashes, pixel interpolation gives different results for the entire page and the fragment. 
<table>
<tr><th class='title_column'>Parameter</th><th>Description</th></tr>
<tr><td class='title_column'>Position deviation</td>
<td>See <a href='#anchorPdfText'>PdfText</a>.</td></tr>
<tr><td class='title_column'>Position deviation is absolute</td>
<td>See <a href='#anchorPdfText'>PdfText</a>.</td></tr>
<td class='title_column'>Search rectangle margin</td>
<td>See <a href='#anchorPdfText'>PdfText</a>.</td></tr>
<tr><td class='title_column'>Brightness tolerance</td>
<td>While for native PDF documents it can be 0.1 - 0.2, scanned documents which have brightness discrepancy may need it higher. A higher tolerance gives a less accuracy.</td></tr>
<tr><td class='title_column'>Different pixel number tolerance</td>
<td>While for native PDF documents it can be 0.1 - 0.2, scanned documents which have brightness discrepancy may need it higher. A higher tolerance gives a less accuracy.</td></tr>
<tr><td class='title_column'>Find best match</td>
<td>If True, looks for the match with the least difference, otherwise returns the first match within the tolerance specified.</td></tr>
</table>


<h3>Create anchor</h3>
<p>How to create anchors, see in <a href='#tutorialAnchor'>tutorial</a>.






<h2><a name="condition">Condition</a></h2> 
<p>A condition is defined by a boolean expression that depends on anchors. It is used in the custom application for deciding which actions should be performed on a PDF page. It is checked by method <a href='#IsCondition'><code>IsCondition(<condition name>)</code></a>.
<p>Conditions are identified by their names. 
<p>The condition collection is dictated by logic of the application, and thus, is predetermined within its scope and is the same for all templates that belong to it.


<h3>Boolean expression</h3>
Condition expressions are composed of the following symbols: &lt;anchor id&gt;, '!', '&', '|', '(', ')', 'T', 'F'. When an anchor referenced by &lt;anchor id&gt; is found then it is treated as True, otherwise False. The meaning of condition is the boolean result of its expression and is a function of pair [PDF page, template].  
<p><span class='attention'>NOTE: </span>Operands '&' and '|' are processed successively, therefore, for instance, "1 | 2 & 3" and "2 & 3 | 1" are not equivalent. Parentheses should be used to manage precedence of operations.
<p>Sample expressions:
<table>
<tr><th class='title_column_center'>Expression</th><th>Description</th></tr>
<tr><td class='title_column_center'>1</td>
<td>The simplest expression which is True when anchor #1 is found.</td></tr>
<tr><td class='title_column_center'>(1 | 7 | 8) & 2</td>
<td>This kind of expression is useful for instance when a company uses different logos for documents of the same structure. In such a case, instead of creating several separate templates, a single template can be set to accept more than 1 logo image. Respectively anchors #1,7 and 8 are targeted to the possible logos.</td></tr>
<td class='title_column_center'>!2 | (2 & 3)</td>
<td>Such an expression could be used for instance in decision whether a certain field should be parsed or passed off.</td></tr>
</tr>
<td class='title_column_center'>T</td>
<td>In order to keep the processing code unified, a condition can be predefined in some templates.</td></tr>
</table>

For more details refer to <a href='#tutorialCondition'>tutorial</a>.


<h3>Set condition</h3>
<p><p>How to set conditions, see in <a href='#tutorialCondition'>tutorial</a>.



<h2><a name="field">Field</a></h2>
<p>A field defines certain text or image that is to be extracted from a PDF page. It is retrieved by method <a href='#GetValue'><code>GetValue()</code></a>.
<p>Fields are identified by their names. The field collection is dictated by logic of the application, and thus is predetermined within its scope and is the same for all templates that belong to it. 

<h3>Anchoring</h3>  
<p>A field optionally can be linked to an anchor.
When a field has no anchor, its selecting rectangle retains the initial position which was its position during creation.
When a field is linked to an anchor, its rectangle is bonded to its anchor's actual position so that if on some page the anchor shifts, the field shifts together with it. 
<p>When it is known definitely that a field appears on every page and always keeps the same position then there is no need to link it to an anchor.
<p>In scanned documents whose margins vary, fields cannot retain constant positions and so always should be processed with anchors.
<p>It is advisable always to link fields to anchors thus minimizing probability of mistaken parsing.


<h3><a name='fieldTypes'>Field types</a></h3>

<h4><a name='fieldPdfText'>PdfText</a></h4>
Its value is a text surrounded by field's rectangle. It is obtained from native PDF entities. So it does not work on images.

<h4>OcrText</h4>
Its value is a text surrounded by field's rectangle. It is recognized by OCR engine.
<p>For native PDF documents, this type should never be used. But for scanned documents, it is the only way to get text in digital form which can be recorded to a file or database, indexed, searched and so on.
<p>In contrast to PdfText, OcrText type does not ensure 100% accuracy and can acceptably work only with images of resolution not less than 300dpi (see <a href='#PdfPageImageResolution'>PdfPageImageResolution</a> parameter). 

<h4>ImageData</h4>
Its value is a <code>System.Drawing.Bitmap</code> object that contains a fragment of page surrounded by the field's rectangle. 
<p>It is used when image is required rather than text or when OcrText type is not reliable.


<h3>Set field</h3> 
<p>How to set fields, see in <a href='#tutorialField'>the tutorial</a>.




<h2><a name='templateSettings'>Settings</a></h2>
A template has the following settings that influence on parsing:
<table>
<tr><th class='title_column'>Parameter</th><th>Description</th></tr>
<tr><td class='title_column'><a name='AutoDeskew'>Auto-Deskew</a></td>
<td>It is used for scanned documents. It is always advisable to keep it active in templates targeted to scanned documents. </td></tr>
<tr><td class='title_column'><a name='PageRotation'>Rotate Pages</a></td>
<td>It is used mostly for scanned documents. A page must be correctly oriented to get OCR working properly on it.</td></tr>
<tr><td class='title_column'><a name='TextAutoInsertSpaceThreshold'>Space Auto-Insert Threshold</a></td>
<td>It is used while splitting text, captured for PdfText field, onto words.
<br>Also, it is used when displaying PdfText anchor's patterns but has no influence on parsing here. 
<br>When needed, it should be tuned experimentally.</td></tr>
</table>











<h1><a name='parsingApi'>Parsing API</a></h1>

<h2>Methods</h2>
<table>
<tr><th class='title_column'>Method | Property</th><th>Description</th></tr>
<tr><td class='title_column'><code>Cliver.PdfDocumentParser.PageCollection::ActiveTemplate</code></td>
<td>Set active template in PdfDocumentParser.</td></tr>
<tr><td class='title_column'><a name='IsCondition'><code>Cliver.PdfDocumentParser.Page::IsCondition()</code></a></td>
<td>Check if a condition is met on the page.</td></tr>
<tr><td class='title_column'><a name='GetValue'><code>Cliver.PdfDocumentParser.Page::GetValue()</code></a></td>
<td>Extract a field from the page. If anchor of the field was not found, NULL is returned.</td></tr>
</table>
<p>Refer to <a href='#InvoiceParser'>InvoiceParser</a> as an live example of using PdfDocumentParser in an application.


<h2><a name='pseudoCode'>Pseudo-code</a></h2>
The main idea of using PdfDocumentParser in an application is that custom operations are performed depending on custom <a href='#condition'>conditions</a>. 
<p>Because of the fact that the collection of <a href='#condition'>conditions</a> is determined by the application, it is impossible to outline 'the most general algorithm' of processing a PDF file with PdfDocumentParser. But some basic algorithm would look like the following:
<pre>
<code class="language-csharp">//pseudo-code: processing a PDF file.
//Note: the classes and methods are not real and serve for simplicity and clarity only.

foreach(page in pdfFile)
{
    //find a template appropriate for the page
    if(PdfDocumentParser.ActiveTemplate == null)
    {
        foreach(template in templates)
        {
            PdfDocumentParser.ActiveTemplate = template;
            if(PdfDocumentParser.IsCondition(page, "DocumentFirstPage"))
                break;
            PdfDocumentParser.ActiveTemplate = null;
        }
    }
    
    if(PdfDocumentParser.ActiveTemplate == null)
    {
        logWarning("No template was detected for page: " + page.Number);
        continue;
    }
        
    //applying the chosen template  
    object value1 = PdfDocumentParser.GetValue(page, "field1");
    //doing something with value1...
    <...>
    
    object value2 = PdfDocumentParser.GetValue(page, "field2");
    //doing something with value2...
    <...>
}</code>
</pre>
<p>Notice that the above algorithm assumes that only one template can be applied to a PDF page while it is not mandatory in general. 


<h3><a name='pseudoCode2'>Multi-page documents</a></h3>
Here is a more advanced algorithm designed for PDF files that contain multi-page documents.
<pre>
<code class="language-csharp">//pseudo-code: processing a PDF file that contains multi-page documents.
//Note: the classes and methods are not real and serve for simplicity and clarity only.

foreach(page in pdfFile)
{
    //find a template appropriate for the document
    if(PdfDocumentParser.ActiveTemplate == null)
    {
        foreach(template in templates)
        {
            PdfDocumentParser.ActiveTemplate = template;
            if(PdfDocumentParser.IsCondition(page, "DocumentFirstPage"))
                break;
            PdfDocumentParser.ActiveTemplate = null;
        }
    }
    
    if(PdfDocumentParser.ActiveTemplate != null)
    {        
        //applying the chosen template    
        if(PdfDocumentParser.IsCondition(page, "Field1MustBeParsed"))
        {
            object value1 = PdfDocumentParser.GetValue(page, "field1");
            //doing something with value1...
            <...>
        }
        if(PdfDocumentParser.IsCondition(page, "Field2MustBeParsed"))
        {
            object value2 = PdfDocumentParser.GetValue(page, "field2");
            //doing something with value2...
            <...>
        }
    
        if(PdfDocumentParser.IsCondition(page, "DocumentLastPage"))
            PdfDocumentParser.ActiveTemplate = null;
    }
}</code>
</pre>




<h2><a name='tutorialParsingApi'>Tutorial: using Parsing API</a></h2>

<h3>Sample task & application</h3>
<p>Since PdfDocumentParser can only be used from within an application developed for a certain parsing task, in this tutorial the following sample task is considered: 
<p>there are PDF files that consist of invoices issued by different companies. Values INVOICE#, JOB#, PO#, COST must be parsed from every invoice.
<p>It is known that the PDF files to be parsed comply with the following:
<ul>
<li>a file can consist of multiple invoices;</li>
<li>an invoice can consist of multiple pages;</li>
<li>any page in a file is a part of invoice;</li>
</ul>
<p>The application developed for this task is <a href='#InvoiceParser'>InvoiceParser</a> which can be referred to during this tutorial.

<h3><a name='customConfiguration'>Custom configuration<a/></h3>
<p>As is obvious from the task requirements, the <a href='#field'>field</a> collection predetermined in our application should be: INVOICE#, JOB#, PO#, COST.
<p>Now let's decide which <a href='#condition'>conditions</a> are needed in our application. 
<p>Since the invoices are issued by different companies, they have different layouts. Every layout requires its own parsing template. Therefore, our application should be able to <b>A)</b>recognize layout of a PDF page in order to know which template should be applied. 
<p>Additionally, as invoices can be multi-page, our application has to <b>B)</b>detect the first page of every invoice. 
<p>Checks (A) and (B) can be joined into one <a href='#condition'>condition</a>. Let's name it 'FirstPageOfDocument'. 
<p>It will work in the following manner: when a template has its FirstPageOfDocument satisfied on a PDF page, it will be chosen for processing of this page and the next ones until the first page of a new invoice is detected. And when a new invoice starts, the previously captured fields should be processed/recorded and cleaned.
<p>Thus, the condition collection in our application will consist of only condition FirstPageOfDocument which is sufficient for the task.


<h3>Custom algorithm</h3>
Now, summing up the said above, the algorithm of processing a PDF file in our application should be the following:
<pre>
<code class="language-csharp">//pseudo-code: parsing an invoice
//Note: the classes and methods are not real and serve for simplicity and clarity only.

object INVOICE#, JOB#, PO#, COST;
Template currentTemplate;
foreach(page in pdfFile)
{ 
    foreach(template in templates)
    {
        PdfDocumentParser.ActiveTemplate = template;
        if(PdfDocumentParser.IsCondition(page, "DocumentFirstPage"))
        {
            if(INVOICE# != null)
            {
                //do something with INVOICE#, JOB#, PO#, COST extracted from the previous invoice...
                <...>
                INVOICE# = null;
            }
            currentTemplate = PdfDocumentParser.ActiveTemplate;
            break;
        }
    }
    if(currentTemplate != null)
    {  
        PdfDocumentParser.ActiveTemplate = currentTemplate;
        object INVOICE# = PdfDocumentParser.GetValue(page, "INVOICE#");
        object JOB# = PdfDocumentParser.GetValue(page, "JOB#");
        object PO# = PdfDocumentParser.GetValue(page, "PO#");
        object COST = PdfDocumentParser.GetValue(page, "COST");
    }
}</code>
</pre>

Refer to <a href='#InvoiceParser'>InvoiceParser</a> as live code.










<h1><a name="templateEditor">Template Editor</a></h1>
Template Editor is a GUI object that is called from the application whenever configuring <a href="#template">template</a> is required. 

<p>How to configure a template, see in <a href='#tutorialTemplateEditor'>the tutorial of setting template</a>.

<h2><a name='templateEditorApi'>Template Editor API</a></h2>
<table>
<tr><th class='title_column'>Object</th><th>Description</th></tr>
<tr><td class='title_column'><code>Cliver.PdfDocumentParser.TemplateForm</code></td>
<td>.NET Windows Form that provides abilities of editing/debugging a template. Create <code>TemplateForm</code> with a <code>TemplateManager</code> instance as a parameter and call <code>Show()</code> or <code>ShowDialog()</code> on it.</td></tr>
<tr><td class='title_column'><code>Cliver.PdfDocumentParser.TemplateManager</code></td>
<td>Abstract class that must be defined with custom routines. Passed to <code>TemplateForm()</code> as a parameter.</td></tr>
</table>
<p>Refer to <a href='#InvoiceParser'>InvoiceParser</a> as a sample of use.




<h2><a name='tutorialTemplateEditor'>Tutorial: setting template</a></h2>
This tutorial proceeds with the sample considered in <a href='#tutorialParsingApi'>tutorial of Parsing API</a>.
<p><a href='#InvoiceParser'>InvoiceParser</a> is used as a sample application.


<h3>Open Template Editor</h3>
<p>The way of opening Template Editor depends on the application. In <a href='#InvoiceParser'>InvoiceParser</a> a <a href="#template">template</a> can be created from scratch or copied from an existing one and then modified as needed. Let's start with a blank template: click the blank row in the table in the main window of InvoiceParser and then click button Edit.
<p class='screenshot_title'>Open a test PDF file in Template Editor:
<img src='img/tutorial0.png'/>

<h3><a name='tutorialAnchor'>Create anchors</a></h3>
<p>Templates in our application have 1 condition and 4 fields (see <a href='#customConfiguration'>the configuration</a>). 
<p>Let's first create anchors for the condition. As FirstPageOfDocument is intended to identify the type of a document, it needs an anchor targeted to some fragment of a document that is unique to its type. Obviously, such a fragment must identify the document type with a high confidence. Usually the logo of a company that issued the document can serve well this goal.
<p class='screenshot_title'>Create an anchor that captures the logo and thus detects if a page corresponds to the template:
<img src='img/tutorial1.png'/>

<p>In addition, as FirstPageOfDocument must be capable to detect the beginning page of a document, it needs an anchor that will do it.
<p class='screenshot_title'>Create an anchor that checks if a page is the first page of a document:
<img src='img/tutorial2.png'/>

<p>Anchors for the fields will be created later.

<p><span class='attention'>NOTE: </span>when you select a row in either table: anchors, conditions or fields, its status is updated in the head cell and the captured place is displayed in the page viewer.

<p><span class='attention'>NOTE: </span>while setting an anchor, if you keep Ctrl pressed, you can select more than 1 element on a PDF page for the same anchor. In that case, to stop selecting and make the anchor set, you have to release Ctrl before releasing the mouse button.

<h3><a name='tutorialCondition'>Specify condition</a></h3>
We already have created anchors #1 and #2 that are needed to specify FirstPageOfDocument's expression. It must be True only when the anchors are found together on a page.

<p class='screenshot_title'>Set condition FirstPageOfDocument with boolean expression "1 & 2":
<img src='img/tutorial3.png'/>

<p>While in this sample FirstPageOfDocument is quite good with 2 anchors, sometimes more anchors may be needed: for instance when the same company issues documents of different types and thus company's logo is not sufficient to detect the type.

<p>If the sample task considered here did not stated that every page belongs to an invoice then one more condition to detect last pages of invoices would be needed. However, in accordance with the requirements, such a condition is redundant.


<h3><a name='tutorialField'>Set fields</a></h3>
<p class='screenshot_title'>Set <a href='#field'>field</a> INVOICE#:
<img src='img/tutorial4.png'/>

<p class='screenshot_title'>In the same way as above set the rest fields and create anchors for them:
<img src='img/tutorial5.png'/>

<p>Though <a href='#field'>fields</a> INVOICE#, JOB#, PO# seem not to need linking to anchors, they were anchored just in case to minimize the probability of mistaken parsing in the future when the layout may change.

<h3>Check template</h3>
<p>When all the conditions and fields are set, it's time to walk through the file and see how the template works on every page.
<p class='screenshot_title'>The page #2 begins a new invoice:
<img src='img/tutorial6.png'/>
<p class='screenshot_title'>The page #3 continues and ends an invoice: 
<img src='img/tutorial7.png'/>
<p>The template worked properly on the test file. Click OK to save it.










<h1><a name='generalSettings'>Global settings</a></h1>
PdfDocumentParser has parameters that are the same within the application's scope and can be modified in the configuration dialog invoked from Template Editor.
<table>
<tr><th class='title_column'>Parameter</th><th>Description</th></tr>
<tr><td class='title_column'><a name='PdfPageImageResolution'>PdfPageImageResolution</a></td>
<td>It is the resolution with which PdfDocumentParser converts PDF pages into images. It influences on the quality of PDF view in Template Editor. 
<p>What is more important, it also impacts on work of OctText anchors and fields. It must be not less than 300dpi (even if the resolution of input documents is lower), otherwise OCR will not work properly. The higher the resolution, the better quality of OCR is. On the other hand, increasing the resolution increases processing time.
<p> Usually there is no need to touch it.</td></tr>
<tr><td class='title_column'><a name='CoordinateDeviationMargin'>CoordinateDeviationMargin</a></td>
<td>It is a zero value threshold while comparing pixel coordinates which may have slight discrepancy because of conversions. 
<p>Usually there is no need to touch it.</td></tr>
</table>












<h1><a name='InvoiceParser'>InvoiceParser</a></h1>
Invoice Parser is a customized desktop application based on <a href='#overview'>PdfDocumentParser</a>. It can be referred to as an example of incorporating PdfDocumentParser. Also, as its custom specificity lays only in a way of how PDF files are parsed, the rest code can be used as a framework.
<p>Generally, it does the following:
<ul>
<li>enhances <code>PdfDocumentParser.Template</code> with auxiliary properties that are not related to parsing;</li>
<li>stores and manages templates;</li>
<li>predetermines the <a href='#condition'>condition</a> and <a href='#field'>field</a> collections;</li>
<li>defines <code>PdfDocumentParser.TemplateForm.TemplateManager</code> and calls <code>PdfDocumentParser.TemplateForm</code> for template editing;</li>
<li>processes PDF files in a custom manner;</li>
</ul>
<img src='img/invoiceparser2_1.png'/>

<h2>Assumptions</h2>
<ul>
<li>by default, a PDF file can contain documents of the same type only. However, it can be tuned for every template individually;</li>
<li>once detected, a document is considered continued until the next document begins or the file ends;</li>
</ul>


<h2>Enhanced template parameters</h2>
<table>
<tr><th class='title_column'>Parameter</th><th>Description</th></tr>
<tr><td class='title_column'>Active</td>
<td>Inactive template is ignored while parsing.</td></tr>
<tr><td class='title_column'>Group</td>
<td>An optional mark that can be helpful for managing templates.</td></tr>
<tr><td class='title_column'>Order</td>
<td>A weight indicating template's order in check line. It is intended to reduce processing time. Templates with the less order are tried first.</td></tr>
<tr><td class='title_column'>DTLPage</td>
<td>The last page in PDF files that is to be checked for this template. It is intended to reduce processing time.</td></tr>
<tr><td class='title_column'>Filter</td>
<td>It is a Regex applied to PDF file path to recognize the proper template. Optional. It is intended to reduce processing time.</td></tr>
<tr><td class='title_column'>Filter</td>
<td>It is a Regex applied to PDF file path to recognize the proper template. Optional. It is intended to reduce processing time.</td></tr>
<tr><td class='title_column'>SFTRegex</td>
<td>It is a Regex that matches to names of templates that can share the same PDF file. By default it is NULL meaning that such a template if chosen for processing a PDF file cannot be changed for this file.</td></tr>
</table>

<h2>Considerations</h2>
<p>When processing documents InvoiceParser applies every active template to every new document to recognize a proper template. So, if you have 50 templates and 1000 files evenly distributed for templates, InvoiceParser will do on average 1000/2 *50 = 25,000 template tries. It may take a considerable time especially when templates use OCR. Processing time can be reduced by the following ways:
<ul> 
<li> specify file filters for templates. If it can be done then the other tips are not needed;
<li> specify template orders so that templates that require a longer time for recognition have a higher order. E.g. templates that use auto-deskew should be checked in the last place;
<li> keep templates that are known as not corresponding to the files to be processed right now, inactive;
</ul>

























</div>

<div class='footer'>
        <script src='copyright.js'></script>
        &nbsp;2018,&nbsp;&nbsp;<a href="javascript:window.location.href = '&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#115;&#101;&#114;&#103;&#101;&#121;&#46;&#115;&#116;&#111;&#121;&#97;&#110;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#109;'" target="_top">Sergey Stoyan</a>
</script>
        
</div>

<script>
if(!window.location.href.match(/\#./ig)){
    window.location.href = window.location.href.replace(/#.*/, '') + '#1';
    location.reload();
}
</script>
<script src='menu_generator.js' shiftHeaderAndFooterToContentView=''></script>

</body>
</html>