<html>
<head>
<title>Pdf Document Parser</title>
<link rel="stylesheet" type="text/css" href="main.css">
<link rel="stylesheet" type="text/css" href="menu_generator.css">

</head>
<body>
<div class='header'>
<div class='mainHeader'>Pdf Document Parser</div>
</div>

<div class='content'>
<h1>Overview</h1>
<p>PdfDocumentParser is a parsing engine designed to extract text/images from PDF documents that conform to a predefined graphic layout - such as invoices and the like. The main parsing approach is based on finding certain text or image fragments in page and then extracting text/images located relatively to those fragments.
<p>Within this scope PdfDocumentParser is capable of the following:
<ul>
<li>processing PDF entities (used for native PDF files);</li>
<li>processing OCR'ed text (used for scanned PDF files);</li>
<li>image search/comparison (used for either native or scanned PDF files);</li>
</ul> 

<p>PdfDocumentParser was designed to be incorporated into custom applications hopefully without need of change. 
<p>PdfDocumentParser API consists of:
<ul>
<li><a href="#templateEditor">Template Editor</a> where parsing templates can be created or debugged in an easy manner;</li>
<li><a href="#api">Parsing API</a> that allows custom applications to parse PDF files in a custom manner with little effort required;</li>
</ul> 


<h2>Text/image operations</h2>
<p>PdfDocumentParser implements the following strategies to operate with text and images:
<ul>
<li>Extracting text directly from PDF structure. This way is based on native text presentation inside PDF files and should be used whenever possible since it is the most robust and fast.</li>
<li>Getting text from image by OCR technology incorporated into PdfDocumentParser. This option should be chosen only when direct PDF processing does not work. It is usually needed when PDF file consists completely or partially of images such as scanned documents, photos etc. This way cannot not give 100% accuracy against PDF processing and will acceptably work only for images with resolution not less than 300dpi. Also this way is slower.</li>
<li>Seeking and comparing page fragments as images. This strategy is slower than PDF processing and so must be avoided when possible. Also, it may not provide 100% accuracy on scanned documents if they have essential discrepancy in size, contrast, brightness, orientation etc.</li>
</ul>


 


<h2>Assumptions</h2>
<ul>
<li>a PDF file can consist of multiple documents (e.g. multiple invoices);</li>
<li>a document (e.g. invoice) can consist of multiple pages;</li>
</ul>



<h1><a name="templateEditor">Template Editor</a></h1>
Template Editor is a GUI object that can be called from a desktop application whenever editing <a href="#template">template</a> is required. 

<h2><a name='templateEditorApi'>Template Editor API</a></h2>
<table>
<tr><th class='title_column'>Object</th><th>Description</th></tr>
<tr><td class='title_column'><code>Cliver.PdfDocumentParser.TemplateForm</code></td>
<td>.NET Windows Form that provides abilities of editing/debugging a template. Create <code>TemplateForm</code> with a <code>TemplateManager</code> instance as a parameter and call <code>Show()</code> or <code>ShowDialog()</code> on it.</td></tr>
<tr><td class='title_column'><code>Cliver.PdfDocumentParser.TemplateManager</code></td>
<td>Abstract class that must be defined with custom routines. Passed to <code>TemplateForm()</code> as a parameter.</td></tr>
</table>
<p>Refer <a href='#InvoiceParser'>InvoiceParser</a> as a sample of use.

<h2><a name='tutorial'>Tutorial: configuring template</a></h2>
<p>A parsing <a href="#template">template</a> can be created from scratch or copied from an existing one and modified as needed. 
<p>This tutorial starts with a blank template.
<p class='screenshot_title'>Open a test PDF file in the template editor window:
<img src='img/tutorial0.png'/>

<h3>Create anchors</h3>
<p>Any template needs at least one <a href='#anchor'>anchor</a> that will certainly identify type of document and distinguish it from the rest documents you may want to parse. Such an anchor should be targeted to some fragment of a document that is unique to its type. Obviously, that this fragement must identify the document type with a high confidence. Usually a logo of company that issued the document can serve well this goal.
<p class='screenshot_title'>Create an anchor that captures the logo and thus detects if the page corresponds to the template:
<img src='img/tutorial1.png'/>

<p>In addition to the first anchor which is a must, one more anchor is usually needed to check if page is first page of document. It is necessary while parsing a multi-document PDF file - when application finds this anchor, it knows that the current document if exists should be closed and a new document should be started.
<p class='screenshot_title'>Create an anchor that checks if the page is document's first page:
<img src='img/tutorial2.png'/>

<p><span class='attention'>NOTE: </span>when you select a row in either table: anchors, conditions or fields, its status is updated in the head cell and the captured place is displayed in the page viewer.

<h3>Specify conditions</h3>
<p>Generally, <a href='#condition'>condition</a> collection can be any being predefined by a custom application. In this tutorial only one condition named FirstPageOfDocument is used which is highly likely suitable for any application. Each PDF page is to be examined with it to check the following:
<ul>
<li>does a page belong to a document that this template was created for?</li>
<li>if it does, is the page the first page of a document?</li>
</ul>
If this condition is met then this template is chosen to process this page and the next ones until a new document beginning is detected. 
<p>Sometimes one more condition that checks if a page is the last page of a document is required but the necessity of it depends on what is known about PDF files to be parsed with it. In this sample it is considered redundant.
<p class='screenshot_title'>FirstPageOfDocument must relate on anchors #1 and #2 created above. Fill it with boolean expression "1 & 2" which is true only when both anchors are found together:
<img src='img/tutorial3.png'/>

<p>While in this sample FirstPageOfDocument is quite good with 2 anchors, sometimes more anchors may be needed: for instance when the same company issues documents of different types and thus company's logo is not sufficient to detect the type.



<h3>Set fields</h3>
<p>Though some of the <a href='#field'>fields</a> in this sample seem not to need linking to anchors, it is advisable to always link fields to acnhors to drastically reduce the probability of mistaken parsing. It will be done so in this tutorial.
<p class='screenshot_title'>Set <a href='#field'>field</a> INVOICE#:
<img src='img/tutorial4.png'/>

<p class='screenshot_title'>In the same way as above set the rest fields and create anchors for them:
<img src='img/tutorial5.png'/>




<h3>Check template</h3>
<p>When all the conditions and fields are set, it's time to walk through the file and see how the template works on every page.
<p class='screenshot_title'>The page #2 begins a new invoice:
<img src='img/tutorial6.png'/>
<p class='screenshot_title'>The page #3 continues and ends an invoice: 
<img src='img/tutorial7.png'/>
<p>The template worked properly on the test file. Click OK to save it.
















<h1><a name='api'>API</a></h1>
Refer <a href='#InvoiceParser'>InvoiceParser</a> for an alive example of using PdfDocumentParser in a custom application.

<h2>Methods</h2>
<table>
<tr><th class='title_column'>Method</th><th>Description</th></tr>
<tr><td class='title_column'><code>Cliver.PdfDocumentParser.PageCollection::ActiveTemplate</code></td>
<td>Set active template in PdfDocumentParser.</td></tr>
<tr><td class='title_column'><code>Cliver.PdfDocumentParser.Page::IsCondition()</code></td>
<td>Checks if a condition is met in page.</td></tr>
<tr><td class='title_column'><code>Cliver.PdfDocumentParser.Page::GetValue()</code></td>
<td>Extracts a field from page. If anchor of the field was not found, NULL is returned.</td></tr>
</table>
Refer <a href='#InvoiceParser'>InvoiceParser</a> as a usage example.


<h2>Pseudo-code</h2>
A basic algorithm of processing a PDF file with PdfDocumentParser would look like the following:
<pre>
forech(page in PDF)
{
    if(PdfDocumentParser.ActiveTemplate == null)
    {
        foreach(template in templates)
        {
            PdfDocumentParser.ActiveTemplate = template;
            if(PdfDocumentParser.IsCondition(page, 'DocumentFirstPage'))
                break;
            PdfDocumentParser.ActiveTemplate = null;
        }
    }
    if(PdfDocumentParser.ActiveTemplate != null)
    {      
        object value1 = PdfDocumentParser.GetValue(page, 'field1');
        do something with value1
        object value2 = PdfDocumentParser.GetValue(page, 'field2');
        do something with value2
        ...
        if(PdfDocumentParser.IsCondition(page, 'DocumentLastPage'))
            PdfDocumentParser.ActiveTemplate = null;
    }
}
</pre>

The main idea is that custom operations are performed depending on conditions.









<h1><a name="template">Parsing template</a></h1>
<p>To parse documents that comply with a certain layout (e.g. invoices issued by the same company) a parsing template is configured. It contains information about which data is to be extracted and how. Applying a template to documents with layout different from that it was designed for brings obviously to wrong parsing.
<p>Configuring a template is done in <a href='#templateEditor'>Template Editor<a/> and consists of the following steps:
<ul>
<li> create <a href="#anchor">anchors</a> required for <a href="#condition">conditions</a>;</li>
<li> define <a href="#condition">conditions</a> using created anchors;</li>
<li> set <a href="#field">fields</a>;</li>
<li> create <a href="#anchor">anchors</a> for fields that need it and link those fields to them;</li>
<li> test the template on the rest pages of the file;</li>
</ul>
Refer <a href="#tutorial">the tutorial</a> for more details.



<h2><a name="anchor">Anchor</a></h2>
<p>Anchor is a fragment of either text or image that PdfDocumentParser will look for in PDF page. If found, the anchor is then used by conditions or fields. A not engaged anchor itself is useless. Anchor can be used in the following ways:
<ul>
<li> it can be linked by fields whose positions in page may vary like 'total amount' field whose position usually depends on size of invoice's content;</li> 
<li> it can be engaged in conditions that needs to detect if a certain pattern exists in PDF page;</li>
<li> it can be linked by another anchor so that the latter becomes valid only when the former is found;</li>
</ul>
<p>While native PDF documents in some cases can be parsed without anchors, scanned documents that usually have their margins vary should be processed only with anchors.

<p>Linking to acnhor means that coordinates of a linked field or anchor become relative to the anchor they are linked to. That's PdfDocumentParser first will look for the anchor and if it is found, it will locate the linked fields or anchors depending on the location of their anchor.
<p>The same anchor can be used by multiple conditions and fields.

<h3>General structure of anchor</h3>
<p>An anchor consists of a single or many elements of the same type where the first element is master and the rest are secondary. Position of the master element is considered position of the anchor itself. Secondary elements are searched relatively to the master element's position.  
<p>When an anchor is linked to another anchor, its master element is treated like a secondary element of the linking anchor.


<h3>Create anchor</h3>
<p>To create an anchor, select a new row in the anchors table and choose its type which can be one of the following:

<p> Each of types is processed by its own very different way and so choosing the right type is crucial in successful and robust parsing.
<p>Then select with mouse a rectangle in the document page. The text or image within the selection box will be a fragment that PdfDocumentParser will look for.
<p>If you keep Ctrl pressed while selecting, you can select more than 1 element for the same anchor. To stop selecting, you have to release Ctrl before releasing mouse button.

<h3><a name='anchorPdfText'>Anchor types</a></h3>
<h4><a name='anchorPdfText'>PdfText</a></h4>
Elements of this type anchor are PDF character boxes which together present a text to be found in page. Every character is a separate anchor element.
<table>
<tr><th class='title_column'>Parameter</th><th>Description</th></tr>
<tr><td class='title_column'>Position deviation</td>
<td>It allows to loose bonds between master element and secondary elements in a anchor when for some reason they can shift relatively to each other. It is measured in pixels and must be a positive float number, non-zero even for identical documents because of discrepancy reasoned by internal image re-scaling.</td></tr>
<tr><td class='title_column'>Position deviation is absolute</td>
<td>If set then position of each element is compared to the master element's position, otherwise, with the previous element's position. It makes no sense if the anchor contains no secondary element.</td></tr>
<td class='title_column'>Search rectangle margin</td>
<td>When set, area where the anchor is looked for is the entire page. Otherwise, the searched area is restricted by Search rectangle margin that specifies a rectangular area around the anchor's initial rectangle which is where the anchor was located while creating. It is measured in pixels. It should be set only when it is known that the anchor is always belongs to a certain part of page. It helps to avoid undesired matching and speed up processing.</td></tr>
</table>

<h4>OcrText</h4>
It works similarly to <a href='#anchorPdfText'>PdfText</a> type except that difference that character boxes are provided by OCR engine instead of native PDF entities. 
<table>
<tr><th class='title_column'>Parameter</th><th>Description</th></tr>
<tr><td class='title_column'>Position deviation</td>
<td>See <a href='#anchorPdfText'>PdfText</a>.</td></tr>
<tr><td class='title_column'>Position deviation is absolute</td>
<td>See <a href='#anchorPdfText'>PdfText</a>.</td></tr>
<td class='title_column'>Search rectangle margin</td>
<td>See <a href='#anchorPdfText'>PdfText</a>.</td></tr>
<tr><td class='title_column'>OCR entire page</td>
<td><span class='attention'>NOTE: </span>This switch can completely change parsing. It is because OCR by Tesseract of a larger image and a smaller fragment can give different recognition of the same text. 
<br>Which is better? OCR of entire page gives sometimes more correct results, sometimes otherwise. But it always takes considerably longer time than OCR of a smaller fragment defined by Search rectangle margin. 
<br>This switch makes sense only if Search rectangle margin is set, otherwise the entire page is OCR'ed anyway.</td></tr>
</table>

<h4>ImageData</h4>
Elements of this type anchor is images which are page fragments picked by the selection box.
<p><span class='attention'>NOTE: </span> even if an image fragment is looked for within the same page where it was extracted from, it cannot be found without a non-zero tolerance. It happens since hash maps produced after downsizing image and thus results of their pixel interpolation differ for entire image and a fragment. 
<table>
<tr><th class='title_column'>Parameter</th><th>Description</th></tr>
<tr><td class='title_column'>Position deviation</td>
<td>See <a href='#anchorPdfText'>PdfText</a>.</td></tr>
<tr><td class='title_column'>Position deviation is absolute</td>
<td>See <a href='#anchorPdfText'>PdfText</a>.</td></tr>
<td class='title_column'>Search rectangle margin</td>
<td>See <a href='#anchorPdfText'>PdfText</a>. It reduces search time and helps to avoid undesired matching.</td></tr>
<tr><td class='title_column'>Brightness tolerance</td>
<td>While for native PDF documents it can be 0.1 - 0.2, scanned documents which have brightness discrepancy may need it higher. A higher tolerance brings to a less certain result.</td></tr>
<tr><td class='title_column'>Different pixel number tolerance</td>
<td>While for native PDF documents it can be 0.1 - 0.2, scanned documents which have brightness discrepancy may need it higher. A higher tolerance brings to a less certain result.</td></tr>
<tr><td class='title_column'>Find best match</td>
<td>If set, looks for the match with the least difference, otherwise returns the first match within the tolerance specified.</td></tr>
</table>





<h2><a name="condition">Condition</a></h2> 
<p>Condition is a boolean expression that depends on anchors and is configured in every template.
<p>Condition can have meaning True or False which depends on the pair [PDF page, template]. It can be checked by <a href='#api'>PdfDocumentParser API</a> method IsCondition(<condition name>). 
<p>Conditions are identified by their names. Their name collection is dictated by logic of custom application and thus is predefined within its scope and is the same for all templates.

<h3>Mostly used condition</h3>
<p>While condition collection can vary, the following checks highly likely are needed in any application:
<ul>
<li>does a document correspond to the template?</li>
<li>is a page the first page of a document? (Obviously, it is only required when the PDF files that are to be parsed can be multi-document.)</li>
</ul>
Usually these checks are united in a single condition which thus allows choosing the right template while parsing a PDF file page by page consequently.
<p>Depending on the parsing task, more conditions may be required: for instance that one that can detect the last page of a document.

<h3>Boolean expression</h3>
Condition expressions are composed of the following symbols: &lt;anchor id&gt;, '!', '&', '|', '(', ')'. When anchor referenced by &lt;anchor id&gt; is found then it is treated as True, otherwise False. Meaning of a condition is the boolean result of its expression. 
<p><span class='attention'>NOTE: </span>Operands '&' and '|' are processed consequently, therefore for instance "1 | 2 & 3" and "2 & 3 | 1" are not equivalent. Parentheses should be used to manage precedence of operations.
<p>Sample expressions:

<table>
<tr><th class='title_column_center'>Expression</th><th>Description</th></tr>
<tr><td class='title_column_center'>1</td>
<td>The simplest expression which is True when anchor #1 is found.</td></tr>
<tr><td class='title_column_center'>(1 | 7 | 8) & 2</td>
<td>Such kind of expression is useful for instance when a company can use different logos for documents of the same structure. In such a case, instead of creating several separate templates, a single template can be configured that can accept more than 1 logo image. Respectively anchors #1,7 and 8 are targeted to the expected logos.</td></tr>
<td class='title_column_center'>!2 | (2 & 3)</td>
<td>This expression could be used for instance for a decision whether a certain field should be parsed or passed off.</td></tr>
</table>





<h2><a name="field">Field</a></h2>
<p>Field defines certain text or image that is to be extracted from PDF file. 
<p>Fields are identified by their names. Their name collection is dictated by logic of custom application and thus is predefined within its scope and is the same for all templates. 
<p>A field optionally can be linked to an anchor. When a field has no anchor, its selecting rectangle retains absolute position which was its position during creation. When a field has anchor, PdfDocumentParser locates the field's rectangle relatively to its anchor's actual position so that if on some page the anchor shifts, the field shifts together with it. It is advisable always to link fields to anchors thus drastically decreasing probability of incorrect parsing.  
<p>To set a field, select the respective row in fields table, choose its <a href='#fieldTypes'>type</a> and then select in the page view a rectangle from where text or image must be extracted. Then, if a field has a variable position then it must be linked to an anchor that will detect its proper location on a page. If the anchor of a linked field is not found then this field is not found too. 
<p>When it is known that a field is always has the same position and appears on every page then there is no need to link it to an anchor.

<h3><a name='fieldTypes'>Field types</a></h3>
<h4><a name='fieldPdfText'>PdfText</a></h4>
Its value is a text surrounded by field's rectangle. It is obtained from PDF text entities.
<h4>OcrText</h4>
Its value is a text surrounded by field's rectangle. It is recognized by OCR engine.
<p>For native PDF documents this type should never be used. But for scanned documents it is the only way to get text in the digital form which can be recorded in a file or database, indexed, searched and so on.
<h4>ImageData</h4>
Its value is a <code>System.Drawing.Bitmap</code> object that contains a fragment of page surrounded by the field's rectangle. 
<p>It is used when image is required rather than text or when OCR is not reliable.







<h1>Scanned documents</h1>
<p>Scanned documents are not the first subject for PdfDocumentParser but they are supported. PdfDocumentParser provides auto-deskew and page rotation options which are usually needed for scanned documents. 
<p>Because of quality deviations in scanned documents the image comparison tolerance parameters may need to be tuned.
<p>The image resolution in PdfDocumentParser must be set to not less than 300dpi, otherwise OCR will not work properly. The higher the resolution, the better OCR is. On the other hand, increasing resolution increases processing time. Also, setting resolution in PdfDocumentParser higher than the resolution of original images will not make sense. Image resolution parameter is common for all templates and is set in the configuration window. 










<h1><a name='InvoiceParser'></a>InvoiceParser</h1>
Invoice Parser is a custom desktop application based on PdfDocumentParser. It can be used as a sample of incorporating PdfDocumentParser into a custom code. Actually its custom specificity lays only in a way how PDF files are parsed while the rest code can be used unchanged as a framework in a new application.
<p>Generally, it does the following:
<ul>
<li>enhances <code>PdfDocumentParser.Template</code> with custom properties that are not related to parsing;</li>
<li>stores and manages templates;</li>
<li>defines <code>PdfDocumentParser.TemplateForm.TemplateManager</code> and calls <code>PdfDocumentParser.TemplateForm</code> for editing templates;</li>
<li>processes PDF files in accordance with the custom needs;</li>
</ul>
<img src='img/invoiceparser2_1.png'/>

<h2>Assumptions</h2>
<ul>
<li>by default, a PDF file can contain documents of the same type only but it can be tuned for every template separately;</li>
<li>once detected, a document is considered continued until the next document begins or the file ends;</li>
</ul>
<p>These assumptions is not something deep rooted in the code and can be easily modified.


<h2>Custom template parameters</h2>
<table>
<tr><th class='title_column'>Parameter</th><th>Description</th></tr>
<tr><td class='title_column'>Active</td>
<td>Inactive template is not ignored while parsing.</td></tr>
<tr><td class='title_column'>Group</td>
<td>An optional mark that can be helpful for managing templates.</td></tr>
<tr><td class='title_column'>Order</td>
<td>A weight indicating template's order in check line. It is intended to reduce processing time. Templates with the less order are tried first.</td></tr>
<tr><td class='title_column'>DTLPage</td>
<td>The last page in PDF files that is to be checked for this template. It is intended to reduce processing time.</td></tr>
<tr><td class='title_column'>Filter</td>
<td>It is a Regex applied to PDF file path to recognize the proper template. Optional. It is intended to reduce processing time.</td></tr>
<tr><td class='title_column'>Filter</td>
<td>It is a Regex applied to PDF file path to recognize the proper template. Optional. It is intended to reduce processing time.</td></tr>
<tr><td class='title_column'>SFTRegex</td>
<td>It is a Regex that matches to names of templates that can share the same PDF file. By default it is NULL meaning that such a template if chosen for processing a PDF file cannot be changed for this file.</td></tr>
</table>

<h2>Considerations</h2>
<p>When processing documents InvoiceParser applies every active template to every new document to recognize a proper template. So, if you have 50 templates and 1000 files evenly distributed for templates, InvoiceParser will do on average 1000/2 *50 = 25,000 template tries. It may take a considerable time when templates use OCR. Processing time can be reduced by the following ways:
<ul> 
<li> specify file filters for templates. If it can be done then the tips below are not needed;
<li> specify template orders so that templates that require a longer time for recognition have a higher order. E.g. templates that use auto-deskew should be checked in the last place;
<li> keep templates that are known as not corresponding to the files to be processed right now, inactive;
</ul>

























</div>

<div class='footer'>
        <script src='copyright.js'></script>
        &nbsp;2018,&nbsp;&nbsp;<a href='mailto:sergey.stoyan@gmail.com?Subject=PdfDocumentParser request' target='_top'>Sergey Stoyan</a>
</div>

<script src='menu_generator.js'></script>

</body>
</html>