<html>
<head>
<title>Pdf Document Parser</title>
<link rel="stylesheet" type="text/css" href="main.css">
<link rel="stylesheet" type="text/css" href="menu_generator.css">

</head>
<body>
<div class='header'>
<div class='mainHeader'>Pdf Document Parser</div>
</div>

<div class='content'>
<h1><a name='overview'>Overview</a></h1>
<p>PdfDocumentParser is a parsing engine intended to extract of text/images from PDF documents that conform to a recognizable graphic layout - such as invoices and the like. The main parsing approach is based on finding certain text or image fragments in page and then extracting text/images located relatively to those fragments.
<p>Within this scope PdfDocumentParser is capable of the following:
<ul>
<li>operating with text represented by PDF entities (meant for native PDF files);</li>
<li>processing OCR'ed text (meant for scanned PDF files);</li>
<li>image search/comparison/extraction (meant for either native or scanned PDF files);</li>
</ul> 
For more details see <a href='#anchorTypes'>anchor types</a> and <a href='#fieldTypes'>field types</a>.

<p>PdfDocumentParser was designed to be incorporated into custom applications hopefully without need of change. 
<p>PdfDocumentParser API consists of:
<ul>
<li><a href="#templateEditor">Template Editor</a> where parsing templates can be created or debugged in an easy manner;</li>
<li><a href="#api">Parsing API</a> that allows custom applications to parse PDF files in a custom manner with little effort required;</li>
</ul> 
<p>PdfDocumentParser is a .NET DLL.






<h1><a name="template">Template</a></h1>
<p>To parse documents that comply with a certain layout (e.g. invoices issued by the same company) a parsing template is to be configured. It contains information what data should be extracted and how. 
<p>Obviously, applying a template to documents with layout different from that it was designed for, would bring to incorrect parsing.
<p>Configuring a template is done by <a href='#templateEditor'>Template Editor<a/>



<h2><a name='anchor'>Anchor</a></h2>
<p>An anchor is a fragment of either text or image extracted from a test PDF page in order to be looked for on any PDF page when needed afterwards. An anchor can be used in the following ways:
<ul>
<li>can be linked by <a href="#field">fields</a>;</li> 
<li>can be engaged in <a href="#condition">conditions</a>;</li>
<li>can be linked by <a href='#anchor'>anchors</a>;</li>
</ul>
<p>Being used does not impose any restriction to an anchor. Thus, an anchor can be used in many ways at the same time.
 

<h3>General structure of anchor</h3>
<p>An anchor consists of a single or many elements of the same type where the first element is 'master' and the rest are 'secondary'. Position of the master element is considered the position of the anchor itself. Secondary elements are searched in relation to the master element's position. 
<p>If some of an anchor's elements is not found, the anchor itself is set not found too.
<p>The rectangle where an anchor was located on the page while creating, is named 'initial rectangle' and contains all the anchor's elements.

<h3>Anchor linked to anchor</h3>
<p>A linked anchor is named 'child' of the linking one which is named 'parent'. 
<p>When an anchor is linked to another anchor, its search area (when it is not the entire page) becomes related to its parent anchor's position.
<p>When a parent anchor is not found, its child anchors are set not found too.
<p>Number of anchors linked successively in a chain can be any.



<h3><a name='anchorTypes'>Anchor types</a></h3>
<p>Each of types is processed by its own very different way therefore choosing the right type is crucial in successful and robust parsing. 
<p>When using OcrText and ImageData types, be acquainted with <a href='#scannedDocuments'>scanned document treatment</a>.

<h4><a name='anchorPdfText'>PdfText</a></h4>
<p>This type is based on native text presentation inside a PDF file. Elements of this type are character boxes extracted from PDF entities which together present a text to be found in page. Every character is a separate anchor element.
<p>It should be used whenever possible because it is most robust and fast. 

<table>
<tr><th class='title_column'>Parameter</th><th>Description</th></tr>
<tr><td class='title_column'>Position deviation</td>
<td>It allows to loose bonds between master element and secondary elements in a anchor when for some reason they can shift relatively to each other. It is measured in pixels and must be a positive float number, non-zero even for identical documents because of discrepancy reasoned by internal image re-scaling.</td></tr>
<tr><td class='title_column'>Position deviation is absolute</td>
<td>If set then position of each element is compared to the master element's position, otherwise, with the previous element's position. It makes no sense if the anchor contains no secondary element.</td></tr>
<td class='title_column'>Search rectangle margin</td>
<td>When set, area where the anchor is looked for is the entire page. Otherwise, the searched area is restricted by Search rectangle margin that specifies a rectangular area around the anchor's initial rectangle. It is measured in pixels. It should be set only when it is known that the anchor is always belongs to a certain part of page. It helps to avoid undesired matching and speed up processing.</td></tr>
</table>

<h4>OcrText</h4>
<p>This type works similarly to <a href='#anchorPdfText'>PdfText</a> type except that difference that character boxes are provided by OCR engine instead of native PDF entities.
<p>It should be used only when PdfText type does not work which happens on scanned or mixed documents. It cannot not give 100% accuracy like PdfText type does and will acceptably work only for images with resolution not less than 300dpi. Also, its perfomance is slower than that of PdfText type. 
<table>
<tr><th class='title_column'>Parameter</th><th>Description</th></tr>
<tr><td class='title_column'>Position deviation</td>
<td>See <a href='#anchorPdfText'>PdfText</a>.</td></tr>
<tr><td class='title_column'>Position deviation is absolute</td>
<td>See <a href='#anchorPdfText'>PdfText</a>.</td></tr>
<td class='title_column'>Search rectangle margin</td>
<td>See <a href='#anchorPdfText'>PdfText</a>.</td></tr>
<tr><td class='title_column'>OCR entire page</td>
<td><span class='attention'>NOTE: </span>This switch can completely change parsing. It is because OCR by Tesseract of a larger image and a smaller fragment can give different recognition of the same text. 
<br>Which is better? OCR of entire page gives sometimes more correct results, sometimes otherwise. But it always takes considerably longer time than OCR of a smaller fragment defined by Search rectangle margin. 
<br>This switch makes sense only if Search rectangle margin is set, otherwise the entire page is OCR'ed anyway.</td></tr>
</table>

<h4>ImageData</h4>
<p>Elements of this type are images which are fragments of page selected while creating an anchor.
<p>This type should be used when anchoring to images, not to text, is required. Its perfomance is slower than that of PdfText type. Also, it may not provide 100% accuracy on scanned documents if they have essential discrepancy in size, contrast, brightness, orientation etc. In such cases, OcrText type may work better.
<p><span class='attention'>NOTE: </span> even when an image fragment is sought within the same page where it was extracted from, it cannot be found without a non-zero tolerance. It happens because the search hash is produced after downsizing an image and thus pixel interpolation while restoring to the initial size gives different results for an entire image and for its fragment. 
<table>
<tr><th class='title_column'>Parameter</th><th>Description</th></tr>
<tr><td class='title_column'>Position deviation</td>
<td>See <a href='#anchorPdfText'>PdfText</a>.</td></tr>
<tr><td class='title_column'>Position deviation is absolute</td>
<td>See <a href='#anchorPdfText'>PdfText</a>.</td></tr>
<td class='title_column'>Search rectangle margin</td>
<td>See <a href='#anchorPdfText'>PdfText</a>. It reduces search time and helps to avoid undesired matching.</td></tr>
<tr><td class='title_column'>Brightness tolerance</td>
<td>While for native PDF documents it can be 0.1 - 0.2, scanned documents which have brightness discrepancy may need it higher. A higher tolerance brings to a less certain result.</td></tr>
<tr><td class='title_column'>Different pixel number tolerance</td>
<td>While for native PDF documents it can be 0.1 - 0.2, scanned documents which have brightness discrepancy may need it higher. A higher tolerance brings to a less certain result.</td></tr>
<tr><td class='title_column'>Find best match</td>
<td>If set, looks for the match with the least difference, otherwise returns the first match within the tolerance specified.</td></tr>
</table>


<h3>Create anchor</h3>
<p>How to create anchors, see in <a href='#tutorialAnchor'>the tutorial</a>.






<h2><a name="condition">Condition</a></h2> 
<p>A condition is a boolean expression that depends on anchors and is set individually in every template.
<p>The meaning of a condition can be True or False and depends on pair [PDF page, template]. It can be checked by PdfDocumentParser <a href='#api'>API</a> method <a href='#IsCondition'><code>IsCondition(<condition name>)</code></a>. 
<p>Conditions are identified by their names. The condition collection is dictated by the logic of a custom application, therefore condition names are predetermined within the application's scope and are the same for all templates that belong to it.

<h3>Mostly expected condition</h3>
<p>While the condition collection depends on custom application, the following one is unavoidable in any application that operates with more than one template: "is this template appropriate for this page"?
<p>Depending on parsing task, this condition may include additional checks.

<h3>Boolean expression</h3>
Condition expressions are composed of the following symbols: &lt;anchor id&gt;, '!', '&', '|', '(', ')'. When an anchor referenced by &lt;anchor id&gt; is found then it is treated as True, otherwise False. The meaning of a condition is the boolean result of its expression. 
<p><span class='attention'>NOTE: </span>Operands '&' and '|' are processed successively, therefore, for instance, "1 | 2 & 3" and "2 & 3 | 1" are not equivalent. Parentheses should be used to manage precedence of operations.
<p>Sample expressions:
<table>
<tr><th class='title_column_center'>Expression</th><th>Description</th></tr>
<tr><td class='title_column_center'>1</td>
<td>The simplest expression which is True when anchor #1 is found.</td></tr>
<tr><td class='title_column_center'>(1 | 7 | 8) & 2</td>
<td>An expression of this kind is useful for instance when a company uses different logos for documents of the same structure. In such a case, instead of creating several separate templates, a single template can be set to accept more than 1 logo image. Respectively anchors #1,7 and 8 are targeted to the expected logos.</td></tr>
<td class='title_column_center'>!2 | (2 & 3)</td>
<td>This expression could be used for instance for a decision whether a certain field should be parsed or passed off.</td></tr>
</table>

For more details refer to <a href='#tutorialCondition'>the tutorial</a>.


<h3>Set condition</h3>
<p><p>How to set conditions, see in <a href='#tutorialCondition'>the tutorial</a>.



<h2><a name="field">Field</a></h2>
<p>A field defines certain text or image that is to be extracted from a PDF page. 
<p>Fields are identified by their names. The field collection is dictated by the logic of a custom application and thus their names are predetermined within its scope and are the same for all templates that belong to it. 

<h3>Anchoring</h3>  
<p>A field optionally can be linked to an anchor.
<p>When a field has no anchor, its selecting rectangle retains the initial position which was its position during creation.
<p>When a field has anchor, PdfDocumentParser locates the field's rectangle depending on its anchor's actual position so that if on some page the anchor shifts, the field shifts together with it. 
<p>When it is known definitely about a field that it appears on every page and always keeps the same position then there is no need to link it to an anchor.
<p>In scanned documents whose margins vary, fields cannot have constant positions and so always must be processed with anchors.
<p>It is advisable always to link fields to anchors thus minimizing probability of mistaken parsing.


<h3><a name='fieldTypes'>Field types</a></h3>
<p>When using OcrText and ImageData types, be acquainted with <a href='#scannedDocuments'>scanned document treatment</a>.

<h4><a name='fieldPdfText'>PdfText</a></h4>
Its value is a text surrounded by field's rectangle. It is obtained from PDF entities.
<h4>OcrText</h4>
Its value is a text surrounded by field's rectangle. It is recognized by OCR engine.
<p>For native PDF documents this type should never be used. But for scanned documents it is the only way to get text in the digital form which can be recorded in a file or database, indexed, searched and so on.
<h4>ImageData</h4>
Its value is a <code>System.Drawing.Bitmap</code> object that contains a fragment of page surrounded by the field's rectangle. 
<p>It is used when image is required rather than text or when OCR is not reliable.


<h3>Set field</h3> 
<p>How to set fields, see in <a href='#tutorialField'>the tutorial</a>.














<h1><a name='api'>API</a></h1>
Refer to <a href='#InvoiceParser'>InvoiceParser</a> as an alive example of using PdfDocumentParser in a custom application.

<h2>Methods</h2>
<table>
<tr><th class='title_column'>Method | Property</th><th>Description</th></tr>
<tr><td class='title_column'><code>Cliver.PdfDocumentParser.PageCollection::ActiveTemplate</code></td>
<td>Set active template in PdfDocumentParser.</td></tr>
<tr><td class='title_column'><a name='IsCondition'><code>Cliver.PdfDocumentParser.Page::IsCondition()</code></a></td>
<td>Check if a condition is met in page.</td></tr>
<tr><td class='title_column'><code>Cliver.PdfDocumentParser.Page::GetValue()</code></td>
<td>Extract a field from page. If anchor of the field was not found, NULL is returned.</td></tr>
</table>


<h2>Pseudo-code</h2>
The main idea of using PdfDocumentParser in a custom application is that custom operations are performed depending on custom <a href='#condition'>conditions</a>. 
<p>Because of the fact that the collection of <a href='#condition'>conditions</a> is determined by a custom application, it is impossible to outline 'the most common algorithm' of using PdfDocumentParser. But some basic algorithm of processing a PDF file would look like the following:
<pre>
foreach(page in PdfFile)
{
    if(PdfDocumentParser.ActiveTemplate == null)
    {
        foreach(template in templates)
        {
            PdfDocumentParser.ActiveTemplate = template;
            if(PdfDocumentParser.IsCondition(page, "DocumentFirstPage"))
                break;
            PdfDocumentParser.ActiveTemplate = null;
        }
    }
    if(PdfDocumentParser.ActiveTemplate != null)
    {      
        if(PdfDocumentParser.IsCondition(page, "Field1Page"))
        {
            object value1 = PdfDocumentParser.GetValue(page, "field1");
            ...do something with value1...
        }
        if(PdfDocumentParser.IsCondition(page, "Field2Page"))
        {
            object value2 = PdfDocumentParser.GetValue(page, "field2");
            ...do something with value2...
        }
        ...
        if(PdfDocumentParser.IsCondition(page, "DocumentLastPage"))
            PdfDocumentParser.ActiveTemplate = null;
    }
}
</pre>
<p>Notice that the above algorithm implies that only one template can be applied to a PDF page while it is not mandatory in general. 






<h2><a name='tutorialApi'>Tutorial: custom application</a></h2>
<p>PdfDocumentParser can only be called from within an application developed for a certain parsing task. Therefore, in this tutorial we'll consider a sample task and an application developed for it.

<h3>Custom task</h3>
<p>The parsing task, that is considered in this tutorial, follows:
<p>There are PDF files that consist of invoices issued by different companies. Values INVOICE#, JOB#, PO#, COST should be parsed from every invoice.
<p>It is known that the PDF files to be parsed comply with the following:
<ul>
<li>a file can consist of multiple invoices;</li>
<li>an invoice can consist of multiple pages;</li>
<li>any page in a file participates in an invoice;</li>
</ul>
<p><a href='#InvoiceParser'>InvoiceParser</a> is an application developed for this task so it can be referred to while learning this tutorial.

<h3><a name='customConfiguration'>Custom configuration<a/></h3>
<p>As is obvious from the task requirements, the <a href='#field'>field</a> collection predetermined in our application should be: INVOICE#, JOB#, PO#, COST.
<p>Now let's decide which <a href='#condition'>conditions</a> are needed in our applcation. 
<p>Because the invoices are issued by different companies and hence have different layouts, there will be needed as many parsing templates as many layouts are. Therefore, our application has to <b>A)</b>recognize which template should be applied to a PDF page. 
<p>Additionaly, as invoice can be multi-page, our application has to <b>B)</b>detect the first page of invoice. 
<p>(A) and (B) can be joined into one <a href='#condition'>condition</a>. Let's name it 'FirstPageOfDocument'. 
<p>When a template has its FirstPageOfDocument satisfied on a PDF page, it must be chosen for processing that page and the next ones until the first page of a new invoice is detected. And when a new invoice starts, the previously captured fields are to be processed and cleaned.
<p>So, the condition collection in our application should consist of only condition FirstPageOfDocument which is sufficient for the task.


<h3>Custom algorithm</h3>
Now, summing up the said above, the algorithm of processing a PDF file in our application should be the following:
<pre>
object INVOICE#, JOB#, PO#, COST;
Template currentTemplate;
foreach(page in PdfFile)
{ 
    foreach(template in templates)
    {
        PdfDocumentParser.ActiveTemplate = template;
        if(PdfDocumentParser.IsCondition(page, "DocumentFirstPage"))
        {
            if(INVOICE# != null)
            {
                ...do something with INVOICE#, JOB#, PO#, COST extracted from the previous invoice...
                INVOICE# = null;
            }
            currentTemplate = PdfDocumentParser.ActiveTemplate;
            break;
        }
    }
    if(currentTemplate != null)
    {  
        PdfDocumentParser.ActiveTemplate = currentTemplate;
        object INVOICE# = PdfDocumentParser.GetValue(page, "INVOICE#");
        object JOB#, = PdfDocumentParser.GetValue(page, "JOB#");
        object PO# = PdfDocumentParser.GetValue(page, "PO#");
        object COST = PdfDocumentParser.GetValue(page, "COST");
    }
}
</pre>

Refer to <a href='#InvoiceParser'>InvoiceParser</a> as a real code.










<h1><a name="templateEditor">Template Editor</a></h1>
Template Editor is a GUI object that is called in a desktop application whenever configuring <a href="#template">a template</a> is required. 

<p>How to configure a template, see in <a href='#tutorialTemplateEditor'>the tutorial of setting template</a>.

<h2><a name='templateEditorApi'>Template Editor API</a></h2>
<table>
<tr><th class='title_column'>Object</th><th>Description</th></tr>
<tr><td class='title_column'><code>Cliver.PdfDocumentParser.TemplateForm</code></td>
<td>.NET Windows Form that provides abilities of editing/debugging a template. Create <code>TemplateForm</code> with a <code>TemplateManager</code> instance as a parameter and call <code>Show()</code> or <code>ShowDialog()</code> on it.</td></tr>
<tr><td class='title_column'><code>Cliver.PdfDocumentParser.TemplateManager</code></td>
<td>Abstract class that must be defined with custom routines. Passed to <code>TemplateForm()</code> as a parameter.</td></tr>
</table>
<p>Refer to <a href='#InvoiceParser'>InvoiceParser</a> as a sample of use.




<h2><a name='tutorialTemplateEditor'>Tutorial: setting template</a></h2>
This tutorial proceeds with the sample considered in <a href='#tutorialApi'>the tutorial of custom application</a>.
<p>Refer to <a href='#InvoiceParser'>InvoiceParser</a> as the sample's custom application.


<h3>Open Template Editor</h3>
<p>The way of opening Template Editor depends on a custom application. In <a href='#InvoiceParser'>InvoiceParser</a> a <a href="#template">template</a> can be created from scratch or copied from an existing one and then modified as needed. Let's start with a blank template: click the blank row in the table in the main window of InvoiceParser and then click button Edit.
<p class='screenshot_title'>Open a test PDF file in Template Editor:
<img src='img/tutorial0.png'/>

<h3><a name='tutorialAnchor'>Create anchors</a></h3>
<p>Templates in our custom application have 1 condition and 4 fields (see <a href='#customConfiguration'>the configuration</a>). 
<p>Let's first create anchors for the condition. As FirstPageOfDocument is intended to identify the type of a document, it needs an anchor targeted to some fragment of a document that is unique to its type. Obviously, such a fragment must identify the document type with a high confidence. Usually the logo of a company that issued the document can serve well this goal.
<p class='screenshot_title'>Create an anchor that captures the logo and thus detects if a page corresponds to the template:
<img src='img/tutorial1.png'/>

<p>In addition, as FirstPageOfDocument must be capable to detect the beginning page of a document, it needs an anchor that will do it.
<p class='screenshot_title'>Create an anchor that checks if a page is the first page of a document:
<img src='img/tutorial2.png'/>

<p>Anchors for the fields will be created later.

<p><span class='attention'>NOTE: </span>when you select a row in either table: anchors, conditions or fields, its status is updated in the head cell and the captured place is displayed in the page viewer.

<p><span class='attention'>NOTE: </span>while setting an anchor, if you keep Ctrl pressed, you can select more than 1 element on a PDF page for the same anchor. In that case, to stop selecting and make the anchor set, you have to release Ctrl before releasing the mouse button.

<h3><a name='tutorialCondition'>Specify condition</a></h3>
We already have created anchors #1 and #2 that are needed to specify FirstPageOfDocument's expression. It must be True only when the anchors are found together on a page.

<p class='screenshot_title'>Set condition FirstPageOfDocument with boolean expression "1 & 2":
<img src='img/tutorial3.png'/>

<p>While in this sample FirstPageOfDocument is quite good with 2 anchors, sometimes more anchors may be needed: for instance when the same company issues documents of different types and thus company's logo is not sufficient to detect the type.

<p>If the sample task considered here did not stated that every page belongs to an invoice then one more condition to detect last pages of invoices would be needed. However, in accordance with the requirements, such a condition is redundant.


<h3><a name='tutorialField'>Set fields</a></h3>
<p class='screenshot_title'>Set <a href='#field'>field</a> INVOICE#:
<img src='img/tutorial4.png'/>

<p class='screenshot_title'>In the same way as above set the rest fields and create anchors for them:
<img src='img/tutorial5.png'/>

<p>Though <a href='#field'>fields</a> INVOICE#, JOB#, PO# seem not to need linking to anchors, they were anchored just in case to minimize the probability of mistaken parsing in the future when the layout may change.

<h3>Check template</h3>
<p>When all the conditions and fields are set, it's time to walk through the file and see how the template works on every page.
<p class='screenshot_title'>The page #2 begins a new invoice:
<img src='img/tutorial6.png'/>
<p class='screenshot_title'>The page #3 continues and ends an invoice: 
<img src='img/tutorial7.png'/>
<p>The template worked properly on the test file. Click OK to save it.










<h1><a name='scannedDocuments'>Scanned documents</a></h1>
<p>Scanned documents are not the first subject for PdfDocumentParser but they are supported. PdfDocumentParser provides auto-deskew and page rotation options which are usually needed for scanned documents. 
<p>Because of quality deviations in scanned documents the image comparison tolerance parameters in anchors of ImageData type may need to be tuned for every anchor.
<p>The image resolution in PdfDocumentParser is a resolution with which a PDF page is converted into image to be then passed to the OCR engine. It must be set to not less than 300dpi, otherwise OCR will not work properly. The higher the resolution, the better quality of OCR is. On the other hand, increasing the resolution increases processing time. Also, setting the resolution in PdfDocumentParser higher than the resolution of original images will not make sense. Image resolution parameter is the same within application's scope and can be set in the configuration window invoked from Template Editor. 










<h1><a name='InvoiceParser'></a>InvoiceParser</h1>
Invoice Parser is a custom desktop application based on <a href='#overview'>PdfDocumentParser</a>. It can be used as an example of incorporating PdfDocumentParser into a custom code. Also, as its custom specificity lays only in a way how PDF files are parsed, the rest code can be used as a framework in a new application.
<p>Generally, it does the following:
<ul>
<li>enhances <code>PdfDocumentParser.Template</code> with auxiliary properties that are not related to parsing;</li>
<li>stores and manages templates;</li>
<li>predetermines the <a href='#condition'>condition</a> and <a href='#field'>field</a> collections;</li>
<li>defines <code>PdfDocumentParser.TemplateForm.TemplateManager</code> and calls <code>PdfDocumentParser.TemplateForm</code> for template editing;</li>
<li>processes PDF files in accordance with custom needs;</li>
</ul>
<img src='img/invoiceparser2_1.png'/>

<h2>Assumptions</h2>
<ul>
<li>by default, a PDF file can contain documents of the same type only. However, it can be tuned for every template separately;</li>
<li>once detected, a document is considered continued until the next document begins or the file ends;</li>
</ul>
<p>These assumptions is not something deep rooted in the code and can be easily modified.


<h2>Custom template parameters</h2>
<table>
<tr><th class='title_column'>Parameter</th><th>Description</th></tr>
<tr><td class='title_column'>Active</td>
<td>Inactive template is ignored while parsing.</td></tr>
<tr><td class='title_column'>Group</td>
<td>An optional mark that can be helpful for managing templates.</td></tr>
<tr><td class='title_column'>Order</td>
<td>A weight indicating template's order in check line. It is intended to reduce processing time. Templates with the less order are tried first.</td></tr>
<tr><td class='title_column'>DTLPage</td>
<td>The last page in PDF files that is to be checked for this template. It is intended to reduce processing time.</td></tr>
<tr><td class='title_column'>Filter</td>
<td>It is a Regex applied to PDF file path to recognize the proper template. Optional. It is intended to reduce processing time.</td></tr>
<tr><td class='title_column'>Filter</td>
<td>It is a Regex applied to PDF file path to recognize the proper template. Optional. It is intended to reduce processing time.</td></tr>
<tr><td class='title_column'>SFTRegex</td>
<td>It is a Regex that matches to names of templates that can share the same PDF file. By default it is NULL meaning that such a template if chosen for processing a PDF file cannot be changed for this file.</td></tr>
</table>

<h2>Considerations</h2>
<p>When processing documents InvoiceParser applies every active template to every new document to recognize a proper template. So, if you have 50 templates and 1000 files evenly distributed for templates, InvoiceParser will do on average 1000/2 *50 = 25,000 template tries. It may take a considerable time especially when templates use OCR. Processing time can be reduced by the following ways:
<ul> 
<li> specify file filters for templates. If it can be done then the other tips are not needed;
<li> specify template orders so that templates that require a longer time for recognition have a higher order. E.g. templates that use auto-deskew should be checked in the last place;
<li> keep templates that are known as not corresponding to the files to be processed right now, inactive;
</ul>

























</div>

<div class='footer'>
        <script src='copyright.js'></script>
        &nbsp;2018,&nbsp;&nbsp;<a href='mailto:sergey.stoyan@gmail.com?Subject=PdfDocumentParser request' target='_top'>Sergey Stoyan</a>
</div>

<script src='menu_generator.js'></script>

</body>
</html>