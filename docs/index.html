<html>
<head>
<title>Pdf Document Parser</title>
 
<link rel="stylesheet" type="text/css" href="main.css">
<link rel="stylesheet" type="text/css" href="menu_generator.css">

<link href="prism.css" rel="stylesheet" />

</head>
<body>
<script src="prism.js"></script>
<div class='header'>
<div class='mainHeader'>Pdf Document Parser</div>
</div>

<div class='content'>
<h1><a name='overview'>Overview</a></h1>
<p>PdfDocumentParser is a .NET engine designed for parsing PDF documents that conform to predictable graphical layouts - such as reports, forms, tickets, invoices and the like. PdfDocumentParser was designed to be incorporated into an application, thus, drastically reducing efforts of building PDF parsers. 

<p>PdfDocumentParser provides the following facilities:
<ul>
<li><a href="#templateEditor">Template Editor</a> where parsing templates can be created and debugged in an easy manner;</li>
<li><a href="#parsingApi">Parsing API</a> that allows parsing PDF files in a custom manner with a little effort required;</li>
</ul> 

<h2><a name='approach'>Approach</a></h2>
<p>The main approach of parsing by PdfDocumentParser is based on finding certain text or image fragments on a PDF page and then extracting text/images located relatively to those fragments.
<p>Within this scope PdfDocumentParser is capable of the following:
<ul>
<li>search/extract text represented by PDF entities - meant for native PDF files;</li>
<li>search/extract text obtained by OCR - meant for scanned PDF files;</li>
<li>search/compare/extract page fragments as images - meant for either native or scanned PDF files;</li>
</ul> 
For more details see <a href='#anchorTypes'>anchor types</a> and <a href='#fieldTypes'>field types</a>.

<p>Also, PdfDocumentParser allows to check custom <a href='#condition'>conditions</a> on a PDF page to decide which actions should be taken on it.


<h2><a name='customApplication'>Developing application</a></h2>
<p>An application based on PdfDocumentParser has to care about the following main aspects:
<ul>
<li>provide storage and management of parsing templates;</li>
<li>allow a user to create and modify templates with <a href="#templateEditor">Template Editor</a>;</li>
<li>implement a custom algorithm of processing PDF files:
    <ul>
    <li>choose a template to be applied on a PDF page;</li>
    <li>process data parsed by the chosen template;</li>
    </ul> 
</li>
</ul> 
For more details see <a href='#pseudoCode'>pseudo-code</a>, <a href='#tutorialParsingApi'>tutorial: using Parsing API</a> and <a href='#sampleParser'>SampleParser</a>.

<h3><a name='creatingSolution'>Visual Studio</a></h3>
In Visual Studio:
<ul>
<li>create your project;</li>
<li>add PdfDocumentParser project to the solution;</li>
<li>reference PdfDocumentParser in your project;</li>
<li>update nuget packages for the solution;</li>
<li>start developing your parser using PdfDocumentParser API;</li>
</ul> 



<h2><a name='licensing'>Licensing</a></h2>
PdfDocumentParser is provided under GNU Affero General Public License v3.0. Contact me if you want another license.
<p>Be noticed that PdfDocumentParser may use third-party software as command line tools or linked libraries that are licensed separately.


<h2><a name='repository'>Source code</a></h2>
Open <a href='https://github.com/sergeystoyan/PdfDocumentParser' target='_blank'>repository</a>
<br><span class='attention'>NOTE: </span>do not download the latest code as is in a branch because it may be in development. Instead, go to releases and download the latest (pre-)release source code. 



<h2><a name='gettingStarted'>Getting started</a></h2>
To get the idea of what can be done with PdfDocumentParser and how it is used, review <a href='#tutorialParsingApi'>tutorial: using Parsing API</a> and then <a href='#tutorialTemplateEditor'>tutorial: setting template</a>.  


<h1><a name="template">Template</a></h1>
<p>A parsing template is intended for parsing documents that comply with the same layout (e.g. reports issued by the same company). It contains information what data should be extracted, where and how. 
<p>Obviously, applying a template to documents with layouts different from that it was designed for, brings to incorrect parsing.
<p>Creating and modifying templates is preformed with <a href='#templateEditor'>Template Editor<a/>



<h2><a name='anchor'>Anchor</a></h2>
<p>An anchor is a fragment of either text or image captured on a PDF page in order to be searched on any page needed afterwards. An anchor can be used in the following ways:
<ul>
<li><a href="#field">fields</a> can be linked to it;</li> 
<li>it can be engaged in <a href="#condition">conditions</a>;</li>
<li>other <a href='#anchor'>anchors</a> can be linked to it;</li>
</ul>
<p>Being used does not impose any restriction on an anchor. Thus, an anchor can be used in many ways at the same time.

<p>Anchors are identified by their numbers assigned automatically.
<p>An anchor consists of a single or many elements of the same type which can be either text characters or images. The first element is 'master' and the rest are 'secondary'. Position of its master element is position of the anchor itself. 
<p>When an anchor is searched on a page, its elements are searched together starting from the first element until the first satisfactory combination of them is found. 
<p>Only the first match of the elements is used to locate an anchor on the page. No further match is searched.
<p>An anchor is set found only when all its elements are found. 


<h3>Compound anchor</h3>
<p>A compound anchor is a chain of successively linked anchors. It is represented by the last anchor in the chain which gives one's position to it. It is used just like a simple anchor.
<p>Compound anchors are used when more conditioned search is required. 
<p>A compound anchor is not found when some of its anchors is not found.
<p>A linked anchor is named 'child' of the linking one which is named 'parent'. When an anchor is linked to another anchor, its search area (when it is set to not entire page) becomes related to its parent anchor's position. That means that a parent anchor is searched not until its first match found as done for a stand-alone anchor, but until a match found that satisfies to the child anchor as well. 
<br>More specifically, when a child anchor has <a href='#anchorPdfText'>Search Rectangle Margin</a> set to not entire page,  position of its parent anchor, while searching as parent, may differ from position of the very same anchor, while searching stand-alone. 
<br>The same consideration is true for child anchors too: an anchor, whose search area is set to not entire page, may change its position after linking to another anchor. 
<br>Thus, <span class='attention'>NOTE: </span>An anchor acting stand-alone and the same anchor acting as a part of a compound anchor should be considered different anchors because they can have different positions. 
<p>Number of anchors in a compound anchor can be any. Though, it should be taken to account that processing time of recursive search performed for a compound anchor exponentially increases with the chain length.



<h3><a name='anchorTypes'>Anchor types</a></h3>
<p>Each type is processed by its own very different way, therefore choosing the right type is crucial in successful and robust parsing. 


<h4><a name='anchorPdfText'>PdfText</a></h4>
<p>This type can only be used to anchor to text. It should be used whenever possible because it is most robust and fast. 
<p>It is based on the native text presentation inside a PDF file. Elements of this type are character boxes extracted from PDF entities. Every character is a separate anchor element. Together they present a text fragment to be found on page.

<table>
<tr><th class='title_column'>Parameter</th><th>Description</th></tr>
<tr><td class='title_column'>Position deviation</td>
<td>It allows to loose bonds between master element and secondary elements in an anchor when for some reason they can shift relative to each other. It is measured in pixels and must be a positive float number, non-zero even for identical documents because of discrepancy reasoned by internal image re-scaling.
<br>It makes no sense for an anchor having no secondary element.</td></tr>
<tr><td class='title_column'>Position deviation is absolute</td>
<td>If True, position deviation of every secondary element is measured by the master element's position, otherwise, by position of the previous element. The latter is looser than the former.</td></tr>
<td class='title_column'>Search rectangle margin</td>
<td>When set, the area where the anchor is searched is the entire page. Otherwise, the search area is restricted by Search rectangle margin that specifies a rectangular area around the anchor's initial rectangle which is the rectangle where the anchor was located on page while creating. It is measured in pixels. It should be used only when it is known definitely that the anchor is always located in a certain part of page. It helps to avoid undesired matching and speed up processing.</td></tr>
</table>

<h4>OcrText</h4>
<p>This type can only be used to anchor to text. It should be used only when PdfText does not work which happens on scanned or mixed documents. 
<p>It works similarly to <a href='#anchorPdfText'>PdfText</a> type except that difference that character boxes are provided by OCR engine instead of native PDF entities.
<p>In contrast to PdfText, OcrText type does not ensure 100% accuracy and can acceptably work only with images of resolution not less than 300dpi (see <a href='#PdfPageImageResolution'>PdfPageImageResolution</a> parameter). 
<table>
<tr><th class='title_column'>Parameter</th><th>Description</th></tr>
<tr><td class='title_column'>Position deviation</td>
<td>See <a href='#anchorPdfText'>PdfText</a>.</td></tr>
<tr><td class='title_column'>Position deviation is absolute</td>
<td>See <a href='#anchorPdfText'>PdfText</a>.</td></tr>
<td class='title_column'>Search rectangle margin</td>
<td>See <a href='#anchorPdfText'>PdfText</a>.</td></tr>
<tr><td class='title_column'>OCR entire page</td>
<td><span class='attention'>NOTE: </span>This switch can completely change parsing. It is because OCR by Tesseract of a larger and a smaller fragments can give different recognition of the same text. 
<br>Which is better? OCR of entire page gives sometimes more correct results, sometimes otherwise. But it always takes considerably longer time than OCR of a smaller fragment which is defined by Search rectangle margin. 
<br>This switch makes sense only if Search rectangle margin is on, otherwise the entire page is OCR'ed anyway.</td></tr>
</table>

<h4>ImageData</h4>
<p>This type is used to anchor to images. 
<p>Elements of an ImageData anchor are images that were selected on PDF page while creating the anchor.
<p>For native PDF documents where images are without discrepancy in quality, ImageData type works quite well. 
<p>When anchoring to a text which is presented by image as happens in scanned or mixed documents, there is a choice between ImageData and OcrText types. Which one to choose? If a target image does not change much from document to document and looks the same (no matter how poor its quality is), ImageData is more reliable and fast. However, if a target image has an essential discrepancy in size, contrast, brightness, orientation etc. in documents, OcrText may work better.
<p><span class='attention'>NOTE: </span> even when an image fragment is searched within the same page where it was extracted from, it cannot be found without a non-zero tolerance. It happens because search hashes of a whole page image and a fragment are produced after downsizing them, and then, when restoring from the hashes, pixel interpolation gives different results for the entire page and the fragment. 
<p><span class='attention'>NOTE: </span> the search of ImageData differs from the other types: if some secondary element is not found then all the found element chain is dropped instead of dropping only the previous element so that the main element is moved to its next match. This difference comes into play only when ImageData anchor has more than 2 elements. In theory this means that an anchor consisting of 3 images might not be found on a page while the match does exist. In practice such ImageData anchors are rarely needed.
<table>
<tr><th class='title_column'>Parameter</th><th>Description</th></tr>
<tr><td class='title_column'>Position deviation</td>
<td>See <a href='#anchorPdfText'>PdfText</a>.</td></tr>
<tr><td class='title_column'>Position deviation is absolute</td>
<td>See <a href='#anchorPdfText'>PdfText</a>.</td></tr>
<td class='title_column'>Search rectangle margin</td>
<td>See <a href='#anchorPdfText'>PdfText</a>.</td></tr>
<tr><td class='title_column'>Brightness tolerance</td>
<td>While for native PDF documents it can be 0.1 - 0.2, scanned documents which have brightness discrepancy may need it higher. A higher tolerance gives a less accuracy.</td></tr>
<tr><td class='title_column'>Different pixel number tolerance</td>
<td>While for native PDF documents it can be 0.1 - 0.2, scanned documents which have brightness discrepancy may need it higher. A higher tolerance gives a less accuracy.</td></tr>
<tr><td class='title_column'>Find best match</td>
<td>If True, looks for the match with the least difference, otherwise returns the first match within the tolerance specified.</td></tr>
</table>


<h3>Create anchor</h3>
<p>How to create anchors, see in <a href='#tutorialAnchor'>tutorial</a>.






<h2><a name="condition">Condition</a></h2> 
<p>A condition is defined by a boolean expression that depends on anchors. It is intended to be used in a custom application for deciding which actions should be performed on a PDF page. It is checked by method <a href='#IsCondition'><code>IsCondition(<condition name>)</code></a>.
<p>Conditions are identified by their names. 
<p>The condition collection is dictated by logic of the application, and thus, is predetermined within its scope and is the same for all templates that belong to it.


<h3>Boolean expression</h3>
Condition expressions are composed of the following symbols: &lt;anchor id&gt;, '!', '&', '|', '(', ')', 'T', 'F'. When an anchor referenced by &lt;anchor id&gt; is found then it is treated as True, otherwise False. The meaning of condition is the boolean result of its expression and is a function of pair [PDF page, template].  
<p><span class='attention'>NOTE: </span>Operands '&' and '|' are processed successively, therefore, for instance, "1 | 2 & 3" and "2 & 3 | 1" are not equivalent. Parentheses should be used to manage precedence of operations.
<p>Sample expressions:
<table>
<tr><th class='title_column_center'>Expression</th><th>Description</th></tr>
<tr><td class='title_column_center'>1</td>
<td>The simplest expression which is True when anchor #1 is found.</td></tr>
<tr><td class='title_column_center'>(1 | 7 | 8) & 2</td>
<td>This kind of expression is useful for instance when a company uses different logos for documents of the same structure. In such a case, instead of creating several separate templates, a single template can be set to accept more than 1 logo image. Respectively anchors #1,7 and 8 are targeted to the possible logos.</td></tr>
<td class='title_column_center'>!2 | (2 & 3)</td>
<td>Such an expression could be used for instance in decision whether a certain field should be parsed or passed off.</td></tr>
</tr>
<td class='title_column_center'>T</td>
<td>In order to keep the processing code unified, a condition can be predefined in some templates.</td></tr>
</table>

For more details refer to <a href='#tutorialCondition'>tutorial</a>.


<h3>Set condition</h3>
<p><p>How to set conditions, see in <a href='#tutorialCondition'>tutorial</a>.



<h2><a name="field">Field</a></h2>
<p>A field defines certain text or image that is to be extracted from a PDF page. It is retrieved by method <a href='#GetValue'><code>GetValue()</code></a>.
<p>Fields are identified by their names. The field collection is dictated by logic of the application, and thus is predetermined within its scope and is the same for all templates that belong to it. 

<h3>Anchoring</h3>  
<p>A field optionally can be linked to an anchor.
When a field has no anchor, its selecting rectangle retains the initial position which was its position during creation.
When a field is linked to an anchor, its rectangle is bonded to its anchor's actual position so that if on some page the anchor shifts, the field shifts together with it. 
<p>When it is definitely known about some field that it appears on every page and always keeps the same position then there is no need to link it to an anchor.
<p>In scanned documents whose margins vary, fields cannot retain constant positions and so always should be processed with anchors.
<p>It is advisable always to link fields to anchors thus minimizing probability of mistaken parsing.


<h3><a name='fieldTypes'>Field types</a></h3>

<h4><a name='fieldPdfText'>PdfText</a></h4>
Its value is text surrounded by the field's rectangle and obtained from native PDF entities. 
<p>It is the preferable type for extracting text. However, it does not work with text presented by image.

<h4>OcrText</h4>
Its value is text surrounded by the field's rectangle and recognized by OCR engine. 
<p>For native PDF documents, this type should never be used. But for scanned documents, it is the only way to get text in the digital form which can be indexed, searched and so on.
<p>In contrast to PdfText, OcrText type does not ensure 100% accuracy and can acceptably work only with images of resolution not less than 300dpi (see <a href='#PdfPageImageResolution'>PdfPageImageResolution</a> parameter). 

<h4>ImageData</h4>
Its value is a <code>System.Drawing.Bitmap</code> object that contains a fragment of page surrounded by the field's rectangle. 
<p>It is used when image is required rather than text or when OcrText type is not reliable enough.


<h3>Set field</h3> 
<p>How to set fields, see in <a href='#tutorialField'>the tutorial</a>.




<h2><a name='templateSettings'>Settings</a></h2>
A template has the following settings that influence on parsing:
<table>
<tr><th class='title_column'>Parameter</th><th>Description</th></tr>
<tr><td class='title_column'><a name='AutoDeskew'>Auto-Deskew</a></td>
<td>It is used for scanned documents. It is always advisable to keep it active in templates targeted to scanned documents. </td></tr>
<tr><td class='title_column'><a name='PageRotation'>Rotate Pages</a></td>
<td>It is used mostly for scanned documents. A page must be correctly oriented to get OCR working properly on it.</td></tr>
<tr><td class='title_column'><a name='TextAutoInsertSpaceThreshold'>Space Auto-Insert Threshold</a></td>
<td>It is used while splitting text, captured for PdfText field, onto words.
<br>Also, it is used when displaying PdfText anchor's patterns but has no influence on parsing here. 
<br>When needed, it should be tuned experimentally.</td></tr>
</table>











<h1><a name='parsingApi'>Parsing API</a></h1>

<h2>Methods</h2>
<table>
<tr><th class='title_column'>Method | Property</th><th>Description</th></tr>
<tr><td class='title_column'><code>Cliver.PdfDocumentParser.PageCollection::ActiveTemplate</code></td>
<td>Set active template in PdfDocumentParser.</td></tr>
<tr><td class='title_column'><a name='IsCondition'><code>Cliver.PdfDocumentParser.Page::IsCondition()</code></a></td>
<td>Check if a condition is met on the page.</td></tr>
<tr><td class='title_column'><a name='GetValue'><code>Cliver.PdfDocumentParser.Page::GetValue()</code></a></td>
<td>Extract a field from the page. If anchor of the field was not found, NULL is returned.</td></tr>
</table>
<p>Refer to <a href='#sampleParser'>SampleParser</a> as an live example of using PdfDocumentParser in an application.


<h2><a name='pseudoCode'>Pseudo-code</a></h2>
The main idea of using PdfDocumentParser in an application is that custom operations are performed depending on custom <a href='#condition'>conditions</a>. 
<p>Since the collection of <a href='#condition'>conditions</a> is predetermined by the application, it is impossible to outline 'the most general algorithm' of processing a PDF file with PdfDocumentParser. Still, some basic algorithms are considered below. 

<h3><a name='pseudoCode2'>Single-page documents</a></h3>
An algorithm of parsing a PDF file where pages has no logical relation between each other and so every page requires choosing a template:
<pre>
<code class="language-csharp">//pseudo-code: processing a PDF file where every page is a new document.
//Note: the classes and methods are not real and serve for simplicity and clarity only.

foreach(page in pdfFile)
{
    //find the right template for the page
    if(PdfDocumentParser.ActiveTemplate == null)
    {
        foreach(template in templates)
        {
            PdfDocumentParser.ActiveTemplate = template;
            if(PdfDocumentParser.IsCondition(page, "RightTemplateForPage"))
                break;
            PdfDocumentParser.ActiveTemplate = null;
        }
    }
    
    if(PdfDocumentParser.ActiveTemplate == null)
    {
        logWarning("No template matched to page: " + page.Number);
        continue;
    }
        
    //applying the chosen template to the page 
    object value1 = PdfDocumentParser.GetValue(page, "field1");
    //doing something with value1...
    <...>    
    object value2 = PdfDocumentParser.GetValue(page, "field2");
    //doing something with value2...
    <...>
}</code>
</pre>
<p>Notice that the above algorithm assumes that only one template can be applied to a PDF page while it is not mandatory in general. 


<h3><a name='pseudoCode2'>Multi-page documents</a></h3>
Here is a more advanced algorithm designed for parsing a PDF file that contains multi-page documents. 
<p>Notice that term 'document' is used here for a range of pages that are to be processed with the same single template. However, generally speaking, there is no problem to process a document with many templates.
<pre>
<code class="language-csharp">//pseudo-code: processing a PDF file that contains multi-page documents.
//Note: the classes and methods are not real and serve for simplicity and clarity only.

foreach(page in pdfFile)
{
    //find a template appropriate for the document
    if(PdfDocumentParser.ActiveTemplate == null)
    {
        foreach(template in templates)
        {
            PdfDocumentParser.ActiveTemplate = template;
            if(PdfDocumentParser.IsCondition(page, "DocumentFirstPage"))
                break;
            PdfDocumentParser.ActiveTemplate = null;
        }
    }
    
    if(PdfDocumentParser.ActiveTemplate != null)
    {        
        //applying the chosen template    
        if(PdfDocumentParser.IsCondition(page, "Field1MustBeParsed"))
        {
            object value1 = PdfDocumentParser.GetValue(page, "field1");
            //doing something with value1...
            <...>
        }
        if(PdfDocumentParser.IsCondition(page, "Field2MustBeParsed"))
        {
            object value2 = PdfDocumentParser.GetValue(page, "field2");
            //doing something with value2...
            <...>
        }
    
        if(PdfDocumentParser.IsCondition(page, "DocumentLastPage"))
            PdfDocumentParser.ActiveTemplate = null;
    }
}</code>
</pre>




<h2><a name='tutorialParsingApi'>Tutorial: using Parsing API</a></h2>

<h3>Sample task & application</h3>
<p>Since PdfDocumentParser can only be used from within an application developed for a certain parsing task, this tutorial consider a certain sample task that is general enough to cover a broad range of practical tasks. The task follows:
<p>there are PDF files that contain invoices issued by different companies. Values InvoiceId and TotalAmount must be parsed from every invoice. (Below, to keep the task more abstract, term 'document' is used instead of 'invoice'.)
<p>It is known that the PDF files to be parsed comply with the following:
<ul>
<li>a file can contain more than one document;</li>
<li>a document can consist of multiple pages;</li>
<li>documents can not share the same page;</li>
<li>between documents there may be pages that do not belong to a document and so should be passed off;</li>
</ul>
<p>The application developed for this task and referred to during this tutorial is <a href='#sampleParser'>SampleParser</a>.

<h3><a name='customConfiguration'>Custom configuration<a/></h3>
<p>As is obvious from the task requirements, the <a href='#field'>field</a> collection predetermined in SampleParser should be: InvoiceId, TotalAmount.
<p>Now let's decide which <a href='#condition'>conditions</a> are needed in SampleParser. 
<p>Since the documents are issued by different companies, they have different layouts. Every layout will require its own parsing template. On the other hand, a whole document can be processed with a single template. Therefore, SampleParser should be able to <b>A)</b>detect the first page of every document in a file and <b>B)</b>choose the right template for the document.
<p>Checks (A) and (B) can be joined into one <a href='#condition'>condition</a>. Let's name it 'FirstPageOfDocument'. 
<p>Also, another <a href='#condition'>condition</a> is required to detect the end of a document. Let's name it 'LastPageOfDocument'.
<p>It will work in the following manner: when a template has its FirstPageOfDocument satisfied on a PDF page then it is to be chosen for processing of this page and the next ones until LastPageOfDocument is met. When it happens, the previously captured fields should be processed and emptied and next pages must be examined for FirstPageOfDocument condition until it is met for some template.
<p>So, the condition collection in SampleParser will consist of FirstPageOfDocument and LastPageOfDocument which is sufficient for the task.


<h3>Custom algorithm</h3>
Now, summing up the said above, the algorithm of processing a PDF file in SampleParser should be the following:
<pre>
<code class="language-csharp">//pseudo-code: parsing a document
//Note: the classes and methods are not real and serve for simplicity and clarity only.

object InvoiceId, TotalAmount;

foreach(page in pdfFile)
{ 
    if(PdfDocumentParser.ActiveTemplate == null)
    {
        foreach(template in templates)
        {
            PdfDocumentParser.ActiveTemplate = template;
            if(PdfDocumentParser.IsCondition(page, "DocumentFirstPage"))
                break;
            PdfDocumentParser.ActiveTemplate = null;
        }
    }
    
    if(PdfDocumentParser.ActiveTemplate != null)
    {        
        InvoiceId = PdfDocumentParser.GetValue(page, "INVOICE");
        TotalAmount = PdfDocumentParser.GetValue(page, "TOTAL");
        
        if(PdfDocumentParser.IsCondition(page, "DocumentLastPage"))
        {
            record(InvoiceId, TotalAmount);
            InvoiceId, TotalAmount = null;
            PdfDocumentParser.ActiveTemplate = null;
        }
    }
}</code>
</pre>

Refer to <a href='#sampleParser'>SampleParser</a> as live code.






<h1><a name="templateEditor">Template Editor</a></h1>
Template Editor is a GUI object that is called from the application whenever configuring <a href="#template">template</a> is required. 

<p>How to configure a template, see in <a href='#tutorialTemplateEditor'>tutorial</a>.

<h2><a name='templateEditorApi'>Template Editor API</a></h2>
<table>
<tr><th class='title_column'>Object</th><th>Description</th></tr>
<tr><td class='title_column'><code>Cliver.PdfDocumentParser.TemplateForm</code></td>
<td>.NET Windows Form that provides abilities of editing/debugging a template. Create <code>TemplateForm</code> with a <code>TemplateManager</code> instance as a parameter and call <code>Show()</code> or <code>ShowDialog()</code> on it.</td></tr>
<tr><td class='title_column'><code>Cliver.PdfDocumentParser.TemplateManager</code></td>
<td>Abstract class that must be defined with custom routines. Passed to <code>TemplateForm()</code> as a parameter.</td></tr>
</table>
<p>Refer to <a href='#sampleParser'>SampleParser</a> as a sample of use.




<h2><a name='tutorialTemplateEditor'>Tutorial: setting template</a></h2>
This tutorial proceeds with the sample considered in <a href='#tutorialParsingApi'>tutorial: using Parsing API</a>. 
<p>The custom application is <a href='#sampleParser'>SampleParser</a>.


<h3>Open Template Editor</h3>
<p>The way of opening Template Editor depends on the application. In <a href='#sampleParser'>SampleParser</a> a <a href="#template">template</a> can be created from scratch or copied from an existing one and then modified as needed. 

<p>The tutorial shows creating a template for a pdf file by repository path PdfDocumentParser\SampleParser\test_files\102.pdf. A template created for this file is supplied in SampleParser under name 'test'. The template created below should be identical with it.
<p>Let's start with a blank template: click the blank row in the table in the main window of SampleParser and then click button Edit.
<p class='screenshot_title'>Open a test PDF file in Template Editor:
<img src='img/tutorial0.png'/>

<h3><a name='tutorialAnchor'>Create anchors</a></h3>
<p>Templates in SampleParser have 2 conditions and 2 fields (see <a href='#customConfiguration'>configuration</a>). 
<p>Let's first create anchors for the condition. As FirstPageOfDocument should identify documents that correspond to the template, it needs an anchor targeted to such a fragment of the document that is distinctive for its type. Obviously, such a fragment must identify the document type with a high confidence. In the case of invoices, the company's logo can serve well this goal.
<p class='screenshot_title'>Create an anchor that captures the logo and thus detects if the template corresponds to the page:
<img src='img/tutorial1.png'/>

<p>In addition, as FirstPageOfDocument must be capable to detect the beginning page of a document, it needs an anchor that will do it.
<p class='screenshot_title'>Create an anchor that checks if a page is the first page of a document:
<img src='img/tutorial2.png'/>

<p>Anchors for the fields will be created later.

<p><span class='attention'>NOTE: </span>when you select a row in either table: anchors, conditions or fields, its status is updated in the head cell and the captured place is displayed in the page viewer.

<p><span class='attention'>NOTE: </span>while setting an anchor, if you keep Ctrl pressed, you can select more than 1 element on a PDF page for the same anchor. In that case, to stop selecting and make the anchor set, you have to release Ctrl before releasing the mouse button.

<h3><a name='tutorialCondition'>Specify conditions</a></h3>
We already have created anchors #1 and #2 that are needed to specify FirstPageOfDocument's expression. It must be True only when the anchors are found together on a page.

<p class='screenshot_title'>Set condition FirstPageOfDocument with boolean expression "1 & 2":
<img src='img/tutorial3.png'/>

<p>While in this sample FirstPageOfDocument is quite good with 2 anchors, sometimes more anchors may be needed: for instance when the same company issues documents of different types and thus company's logo is not sufficient to detect the type.

<p>Condition LastPageOfDocument will be set later.


<h3><a name='tutorialField'>Set fields</a></h3>
<p class='screenshot_title'>Set <a href='#field'>field</a> InvoiceId:
<img src='img/tutorial4.png'/>

<p class='screenshot_title'>In the same way as above set the rest fields and create anchors for them:
<img src='img/tutorial5.png'/>


<p class='screenshot_title'>And now it's time to set condition LastPageOfDocument. Assume that the total amount is always showed only on the last page of a document:
<img src='img/tutorial6.png'/>


<h3>Check template</h3>
<p>When all the conditions and fields are set, it's time to walk through the file and see how the template works on every page.
<p class='screenshot_title'>The page #2 begins a new document:
<img src='img/tutorial7.png'/>
<p class='screenshot_title'>The page #3 continues and ends an document: 
<img src='img/tutorial8.png'/>
<p>The template worked properly on the test file. Click OK to save it.










<h1><a name='generalSettings'>Global settings</a></h1>
PdfDocumentParser has parameters that are the same within the application's scope and can be modified in the configuration dialog invoked from Template Editor.
<table>
<tr><th class='title_column'>Parameter</th><th>Description</th></tr>
<tr><td class='title_column'><a name='PdfPageImageResolution'>PdfPageImageResolution</a></td>
<td>It is the resolution with which PdfDocumentParser converts PDF pages into images. It influences on the quality of PDF view in Template Editor. 
<p>What is more important, it also impacts on work of OctText anchors and fields. It must be not less than 300dpi (even if the resolution of input documents is lower), otherwise OCR will not work properly. The higher the resolution, the better quality of OCR is. On the other hand, increasing the resolution increases processing time.
<p> Usually there is no need to touch it.</td></tr>
<tr><td class='title_column'><a name='CoordinateDeviationMargin'>CoordinateDeviationMargin</a></td>
<td>It is a zero value threshold while comparing pixel coordinates which may have slight discrepancy because of conversions. 
<p>Usually there is no need to touch it.</td></tr>
</table>








<h1><a name='guidance'></a>Guidance</h1>

<h2>Parsing tables</h2>
Tables can be processed by the following ways:
<ul>
<li><i>create fields as columns;</i>
<p>It is the most gracious way....
</li>
<li><i>extract the whole table as a field;</i>
<p>Sometimes tables can not be clearly separated onto columns because they include sub-headers that break the structure or because their fields have unpredictable length etc. In such a case, if the table data still is logically structured, the whole table should be extracted as a single field and then parsed by regexes or other syntax parsing engine;
</li>
<li><i>substitute auto-insert spaces with "|" and then split to columns (unreliabe);</i>
<p>as a simplification of the pre
</li>
<li><i>get char boxes and do anything </i>
<p>It is the most potentially powerful approach but unfortunately too abstract. Having all the information about the table content, it is up to you, how to process it.
</li>
</ul>









<h1><a name='sampleParser'>SampleParser</a></h1>
SampleParser is a customized desktop application based on <a href='#overview'>PdfDocumentParser</a>. It can be used as a demo or framework of incorporating PdfDocumentParser. 
<p>It does the following:
<ul>
<li>enhances <code>PdfDocumentParser.Template</code> with auxiliary properties that are not related to parsing;</li>
<li>stores and manages templates;</li>
<li>predetermines the <a href='#condition'>condition</a> and <a href='#field'>field</a> collections;</li>
<li>defines <code>PdfDocumentParser.TemplateForm.TemplateManager</code> and calls <code>PdfDocumentParser.TemplateForm</code> for template editing;</li>
<li>processes PDF files in a custom manner;</li>
</ul>

Some more details on SampleParser can be found in tutorials: <a href='#tutorialParsingApi'>using Parsing API</a> and <a href='#tutorialTemplateEditor'>setting template</a>. 

<img src='img/sampleparser.png'/>


<h2>Source code</h2>
Download PdfDocumentParser (pre-)release <a href='#repository'>source code</a>. Find SampleParser.sln there and open it in Visual Studio. It will give a complete example of using PdfDocumentParser which you can modify according to your requirements.


<h2>Enhanced template parameters</h2>
<table>
<tr><th class='title_column'>Parameter</th><th>Description</th></tr>
<tr><td class='title_column'>Active</td>
<td>Inactive template is ignored while parsing.</td></tr>
<tr><td class='title_column'>Order</td>
<td>A weight indicating template's order in check line. Templates with the less order are tried first. It is intended to reduce processing time.</td></tr>
<tr><td class='title_column'>Filter</td>
<td>A Regex applied to PDF file path to recognize the proper template. Optional. It is intended to reduce processing time.</td></tr>
</table>

<h2>Considerations</h2>
<p>Processing time depends on the custom algorithm. However, it is possible to make some general tips. Processing time can be reduced by the following ways:
<ul> 
<li> specify file filters for templates. If it can be done then the other tips are not needed;
<li> specify template orders so that templates that require a longer time for recognition have a higher order. E.g. templates that use auto-deskew should be checked in the last place;
<li> keep templates that are known as not corresponding to the files to be processed right now, inactive;
</ul>

























</div>

<div class='footer'>
        <script src='copyright.js'></script>
        &nbsp;2018,&nbsp;&nbsp;<a href="javascript:window.location.href = '&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#115;&#101;&#114;&#103;&#101;&#121;&#46;&#115;&#116;&#111;&#121;&#97;&#110;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#109;'" target="_top">Sergey Stoyan</a>
</script>
        
</div>

<script>
if(!window.location.href.match(/\#./ig)){
    window.location.href = window.location.href.replace(/#.*/, '') + '#1';
    location.reload();
}
</script>
<script src='menu_generator.js' shiftHeaderAndFooterToContentView=''></script>

</body>
</html>