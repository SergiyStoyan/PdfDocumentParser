<?xml version="1.0"?>
<doc>
    <assembly>
        <name>CliverRoutines</name>
    </assembly>
    <members>
        <member name="T:Cliver.CommandLine">
            <summary>
            A helper class to process command line parameters.
            </summary>
        </member>
        <member name="M:Cliver.CommandLine.IsParameterSet(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="parameter"></param>
            <param name="commandLine"></param>
            <returns></returns>
        </member>
        <member name="M:Cliver.CommandLine.ParseParameter(System.String,System.String,System.String)">
            <summary>
            Get a command line paramter from the command line.
            It must be formed as space separated pairs 'parameter name'='parameter value'
            </summary>
            <param name="parameter"></param>
            <param name="defaultValue"></param>
            <param name="commandLine"></param>
            <returns></returns>
        </member>
        <member name="M:Cliver.CommandLine.ToString(System.ValueTuple{System.String,System.String}[])">
            <summary>
            
            </summary>
            <param name="parameters">values are expected to be unescaped</param>
            <returns></returns>
        </member>
        <member name="T:Cliver.Config">
            <summary>
            Config manages values of the static public fields/properties of Settings-derived types that are declared anywhere in the application.
            It provides:
            - detecting static public fields of Settings types declared in the application and initiating them with values;
            - serializing/deserializing those Settings fields/properties;
            Every Settings field/property has it own storage file which is defined by its type and its full name in code. 
            Usually it's that only one field is declared per Settings type, but generally there can be any number of fields of the same Settings type.
            </summary>
        </member>
        <member name="M:Cliver.Config.CreateResetClone``1(``0)">
            <summary>
            Creates a new instance of the given Settings field initiated with default values.
            Tries to load values from the initial file located in the app's directory. 
            If this file does not exist, it creates an object with the hardcoded values.
            The new instance shares the same __Info object with the original instance.
            </summary>
            <typeparam name="S"></typeparam>
            <param name="settings"></param>
            <returns></returns>
        </member>
        <member name="M:Cliver.Config.CreateReloadedClone``1(``0)">
            <summary>
            Creates a new instance of the given Settings field initiated with stored values.
            Tries to load values from the storage file.
            If this file does not exist, it tries to load values from the initial file located in the app's directory. 
            If this file does not exist, it creates an object with the hardcoded values.
            The new instance shares the same __Info object with the original instance.
            </summary>
            <typeparam name="S"></typeparam>
            <param name="settings"></param>
            <returns></returns>
        </member>
        <member name="M:Cliver.Config.CreateClone``1(``0)">
            <summary>
            Creates a new instance of the given Settings field with cloned values.
            The new instance shares the same __Info object with the original instance.
            </summary>
            <typeparam name="S"></typeparam>
            <param name="settings"></param>
            <returns></returns>
        </member>
        <member name="M:Cliver.Config.ExportStorageFiles(System.String)">
            <summary>
            Copies storage files of all the Settings fields in the application to the specified directory.
            </summary>
            <param name="toDirectory">folder where files are to be copied</param>
        </member>
        <member name="M:Cliver.Config.Reset(System.String)">
            <summary>
            Can be used to initialize an optional Settings field.
            </summary>
            <param name="settingsFieldFullName">full name of Settings field; it equals to the name of its storage file without extention</param>
        </member>
        <member name="M:Cliver.Config.Reset(System.Type,System.String)">
            <summary>
            Can be used to initialize an optional Settings field.
            </summary>
            <param name="settingsFieldHostingType">full type name of the class hosting the Settings field</param>
            <param name="settingsFieldName">name of the Settings field</param>
        </member>
        <member name="M:Cliver.Config.Reload(System.String)">
            <summary>
            Can be used to initialize an optional Settings field.
            </summary>
            <param name="settingsFieldFullName">full name of Settings field; it equals to the name of its storage file without extention</param>
        </member>
        <member name="M:Cliver.Config.Reload(System.Type,System.String)">
            <summary>
            Can be used to initialize an optional Settings field.
            </summary>
            <param name="settingsFieldHostingType">full type name of the class hosting the Settings field</param>
            <param name="settingsFieldName">name of the Settings field</param>
        </member>
        <member name="M:Cliver.Config.GetSettingsFieldInfo(System.Type,System.String)">
            <summary>
            Allows to get the Settings field's properties before its value has been created (i.e. before the Settings field has been initialized).
            </summary>
            <param name="settingsFieldHostingType">full type name of the class hosting the Settings field</param>
            <param name="settingsFieldName">name of the Settings field</param>
            <returns>Settings field's properties</returns>
        </member>
        <member name="M:Cliver.Config.GetSettingsFieldInfos">
            <summary>
            Get all the SettingsFieldInfo's in the app.
            ATTENTION: potentially, SettingsFieldInfo objects may become out of game so be careful while operating with them.
            </summary>
            <returns>SettingsFieldInfo ennumerator</returns>
        </member>
        <member name="F:Cliver.Config.RequiredOptionalFieldFullNames">
            <summary>
            Tells Config which optional (i.e. attributed with [Settings.Optional]) Settings fields are to be initialized. 
            It must be set before calling Reload() or Reset().
            </summary>
        </member>
        <member name="P:Cliver.Config.InitializationOrderedSettingsTypes">
            <summary>
            Tells Config in which order Settings fields ordered by their types are to be initalized.        
            It may be necessary due to dependencies between Settings types.
            Types listed here will be initialized first in the provided order.
            It must be set before calling Reload() or Reset().
            </summary>
        </member>
        <member name="F:Cliver.Config.ExplicitlyTrackedAssemblies">
            <summary>
            Tells Config in which assemblies to look for Settings fields.
            If not set, the default assemblies are processed.      
            It must be set before calling Reload() or Reset().
            </summary>
        </member>
        <member name="F:Cliver.Config.AssemblyChainMaxLength">
            <summary>
            Tells Config how long to go through referenced assemblies to look for Settings fields.
            The search scope is limited by it in order not to load all the possible assemblies which is unavoidable while enumerating through them.
            It is 0-based.
            It must be set before calling Reload() or Reset().
            </summary>
        </member>
        <member name="M:Cliver.Config.Reload">
            <summary>
            Reloads all the Settings fields in the application.
            It's the usual method to be called in the beginning of an application to initialize Config.
            First it tries to load each Settings object from its default storage directory. 
            If this file does not exist, it tries to load from the initial settings file in app's directory.
            Only if this file does not exist, it resets to the hardcoded values.
            </summary>
        </member>
        <member name="M:Cliver.Config.Reset">
            <summary>
            Resets all the Settings fields in the application.
            First it tries to load each Settings object from the initial settings file in app's directory. 
            Only if this file does not exist, it resets to the hardcoded values.
            </summary>
        </member>
        <member name="M:Cliver.Config.Save">
            <summary>
            Serializes all the Settings fields initialized in the application to their storage files.
            </summary>
        </member>
        <member name="M:Cliver.Config.GetSettingsFieldInfo(System.String)">
            <summary>
            Allows to get the Settings field's properties before its value has been created (i.e. before the Settings field has been initialized).
            </summary>
            <param name="settingsFieldFullName">full name of Settings field; it equals to the name of its storage file without extention</param>
            <returns>Settings field's properties</returns>
        </member>
        <member name="T:Cliver.Encrypted`1">
            <summary>
            A field/property of this type is implicitly encrypted when it is a member of a Settings class.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:Cliver.Encrypted`1._Value">
            <summary>
            Encypted value. It must not be called from the custom code.
            </summary>
        </member>
        <member name="P:Cliver.Encrypted`1.Value">
            <summary>
            Decrypted value to be used in the custom code.
            </summary>
        </member>
        <member name="T:Cliver.StringEndec">
            <summary>
            Abstract string encrypting/decrypting class
            </summary>
        </member>
        <member name="T:Cliver.Endec`1">
            <summary>
            Abstract encrypting/decrypting class
            </summary>
        </member>
        <member name="T:Cliver.Settings">
            <summary>
            Alternative to .NET settings. Fields/properties of Settings based types in the application are automatically managed by Config. 
            Those Settings field to be managed must be static and public.
            In practice, usually only one field is declared per a Settings derived type, but generally there can be any number of fields of the same Settings type.
            </summary>
        </member>
        <member name="P:Cliver.Settings.__Info">
            <summary>
            This info identifies a certain Settings field/property in the application to which this object belongs. 
            All __Info instances are paired one-to-one with all Settings fields in the application. 
            Cloned Settings objects share the same __Info instance which means that while multiple Settings objects can reference the same Settings field, the field can reference only one of them (which is called as 'attached object').
            For some rare needs (for instance when a Settings object was created by deserialization/cloning and therefore has empty __Info), setting __Info from an application's code is allowed (with caution!).
            </summary>
        </member>
        <member name="M:Cliver.Settings.IsAttached">
            <summary>
            Indicates whether this Settings object is the value of the Settings field defined by __Info.
            </summary>
        </member>
        <member name="M:Cliver.Settings.Save">
            <summary>
            Serializes this Settings object to its storage file.
            </summary>
        </member>
        <member name="M:Cliver.Settings.Reset">
            <summary>
            Replaces the value of the field defined by __Info with a new object initiated with the default values. 
            Tries to load it from the initial file located in the app's directory. 
            If this file does not exist, it creates an object with the hardcoded values.
            (!)Calling this method on a detached Settings object throws an exception because otherwise it could lead to a confusing effect. 
            Nevertheless, it can be called from Loaded() method.
            </summary>
        </member>
        <member name="M:Cliver.Settings.Reload">
            <summary>
            Replaces the value of the field defined by __Info with a new object initiated with the stored values.
            Tries to load it from the storage file.
            If this file does not exist, it tries to load it from the initial file located in the app's directory. 
            If this file does not exist, it creates an object with the hardcoded values.
            (!)Calling this method on a detached Settings object throws an exception because otherwise it could lead to a confusing effect. 
            Nevertheless, it can be called from Loaded() method.
            </summary>
        </member>
        <member name="M:Cliver.Settings.IsChanged">
            <summary>
            Compares serializable fields/properties of this object with the ones stored in the file or the default ones.
            </summary>
            <returns>False if the values are identical.</returns>
        </member>
        <member name="P:Cliver.Settings.__TypeVersion">
            <summary>
            Actual version of the Settings type as it is restored from the storage file.
            </summary>
        </member>
        <member name="M:Cliver.Settings.UnsupportedFormatHandler(System.Exception)">
            <summary>
            Called by Config if either: 
            - the storage/init file content does not match the Settings type version;
            - the storage/init file could not be deserialized;
            Here is your chance to amend the data to migrate to the current version.
            </summary>
        </member>
        <member name="M:Cliver.Settings.Loaded">
            <summary>
            
            </summary>
        </member>
        <member name="M:Cliver.Settings.Saving">
            <summary>
            
            </summary>
        </member>
        <member name="M:Cliver.Settings.Saved">
            <summary>
            
            </summary>
        </member>
        <member name="P:Cliver.Settings.__StorageDir">
            <summary>
            Storage folder for this Settings derivative.
            Each Settings derived class must have it defined. 
            Despite of the fact it is not static, actually it is instance independent as only the initial value is used.
            (It is not static because C# does not support static polymorphism.)
            </summary>
        </member>
        <member name="T:Cliver.AppSettings">
            <summary>
            Instances of this class are to be stored in CommonApplicationData folder.
            CliverWinRoutines lib contains AppSettings adapted for Windows.
            </summary>
        </member>
        <member name="P:Cliver.AppSettings.__StorageDir">
            <summary>
            Storage folder for this Settings located in CommonApplicationData.
            </summary>
        </member>
        <member name="F:Cliver.AppSettings.StorageDir">
            <summary>
            Storage folder for this Settings located in CommonApplicationData.
            </summary>
        </member>
        <member name="T:Cliver.UserSettings">
            <summary>
            Instances of this class are to be stored in LocalApplicationData folder.
            </summary>
        </member>
        <member name="P:Cliver.UserSettings.__StorageDir">
            <summary>
            Storage folder for this Settings located in LocalApplicationData.
            </summary>
        </member>
        <member name="F:Cliver.UserSettings.StorageDir">
            <summary>
            Storage folder for this Settings located in LocalApplicationData.
            </summary>
        </member>
        <member name="F:Cliver.SettingsAttributes.ConfigAttribute.Optional">
            <summary>
            Whether a Settings field/type be initiated by Config implicitly. Used to save the loading time/memory.
            An optional field, when needed, must be initiated explicitly by Config.Reload(string settingsFieldFullName)
            </summary>
        </member>
        <member name="F:Cliver.SettingsAttributes.ConfigAttribute.Indented">
            <summary>
            Whether a Settings field/type be serialized with indention. Used to make the storage file smaller.
            </summary>
        </member>
        <member name="F:Cliver.SettingsAttributes.ConfigAttribute.NullSerialized">
            <summary>
            Whether the serializable fields/properties of a Settings field/type whose values are NULL, be serialized.
            </summary>
        </member>
        <member name="T:Cliver.SettingsAttributes.TypeVersionAttribute">
            <summary>
            Check if the type version of the data stored in the storage file is supported.
            </summary>
        </member>
        <member name="F:Cliver.SettingsAttributes.TypeVersionAttribute.Value">
            <summary>
            The version of the Settings type to which this attribute is applied.
            </summary>
        </member>
        <member name="M:Cliver.SettingsAttributes.TypeVersionAttribute.#ctor(System.UInt32)">
            <summary>
            Settings type attribute. Used to check if the storage file format is supported.
            </summary>
            <param name="value">Version of the Settings type to which this attribute is applied.</param>
        </member>
        <member name="T:Cliver.SettingsAttributes.EncryptedAttribute">
            <summary>
            Provides a Settings field or a Settings type with encryption facility.
            </summary>
        </member>
        <member name="F:Cliver.SettingsAttributes.EncryptedAttribute.Endec">
            <summary>
            Encryption/decryption engine.
            </summary>
        </member>
        <member name="M:Cliver.SettingsAttributes.EncryptedAttribute.#ctor(System.Type,System.String)">
            <summary>
            Settings field attribute that is used for encrypting.
            </summary>
            <param name="endecGetterHostingType">Class that exposes the StringEndec getter.</param>
            <param name="endecGetterName">Name of the StringEndec getter. The getter must be static.</param>
        </member>
        <member name="T:Cliver.SettingsFieldInfo">
            <summary>
            Settings attributes which are defined by a Settings field.
            </summary>
        </member>
        <member name="F:Cliver.SettingsFieldInfo.FullName">
            <summary>
            Settings field's full name is the string that is used in code to refer to this field/property. 
            It defines exactly the Settings field/property in code but has nothing to do with the one's type. 
            </summary>
        </member>
        <member name="F:Cliver.SettingsFieldInfo.Name">
            <summary>
            Settings field's name. 
            </summary>
        </member>
        <member name="F:Cliver.SettingsFieldInfo.File">
            <summary>
            Path of the storage file. It consists of a directory which defined by the Settings based type and the file name which is the field's full name in the code.
            </summary>
        </member>
        <member name="F:Cliver.SettingsFieldInfo.InitFile">
            <summary>
            Path of the init file. It consists of the directory where the entry assembly is located and the file name which is the field's full name in the code.
            </summary>
        </member>
        <member name="F:Cliver.SettingsFieldInfo.Type">
            <summary>
            Settings derived type.
            </summary>
        </member>
        <member name="F:Cliver.SettingsFieldInfo.TypeVersion">
            <summary>
            Version info of the Settings type defined in the present code.
            </summary>
        </member>
        <member name="F:Cliver.SettingsFieldInfo.Endec">
            <summary>
            Encryption/decryption engine.
            </summary>
        </member>
        <member name="F:Cliver.SettingsFieldInfo.Optional">
            <summary>
            When TRUE, the Settings field is not initialized by default and needs an explicit initializing. 
            Such a field, when needed, must be initiated explicitly by Config.Reload(string settingsFieldFullName)
            </summary>
        </member>
        <member name="F:Cliver.SettingsFieldInfo.Indented">
            <summary>
            When TRUE, the Settings field is serialized with indention.
            </summary>
        </member>
        <member name="F:Cliver.SettingsFieldInfo.NullSerialized">
            <summary>
            When FALSE, those serializable fields/properties of the Settings field whose values are NULL, are ignored while serializing.
            </summary>
        </member>
        <member name="M:Cliver.SettingsFieldInfo.GetObject">
            <summary>
            Get the object to which this SettingsFieldInfo is attached to.
            </summary>
            <returns>The Settings object linked with this SettingsFieldInfo</returns>
        </member>
        <member name="M:Cliver.SettingsFieldInfo.ReadStorageFileAsJObject">
            <summary>
            Read the storage file as a JObject in order to migrate to the current format.
            </summary>
            <returns>storage file content presented as JObject</returns>
        </member>
        <member name="M:Cliver.SettingsFieldInfo.WriteStorageFileAsJObject(Newtonsoft.Json.Linq.JObject,System.Nullable{System.Boolean})">
            <summary>
            Write the JObject to the storage file in order to migrate to the current format.
            </summary>
            <param name="o">JObject presenting Settings field serialized as JSON</param>
            <param name="indented">whether the storage file content be indented</param>
        </member>
        <member name="M:Cliver.SettingsFieldInfo.ReadStorageFileAsString">
            <summary>
            Read the storage file as a string in order to migrate to the current format.
            </summary>
            <returns>storage file content</returns>
        </member>
        <member name="M:Cliver.SettingsFieldInfo.WriteStorageFileAsString(System.String)">
            <summary>
            Write the string to the storage file in order to migrate to the current format.
            </summary>
            <param name="s">serialized Settings field</param>
        </member>
        <member name="M:Cliver.SettingsFieldInfo.UpdateTypeVersionInStorageFileString(System.UInt32,System.String@)">
            <summary>
            Update __TypeVersion value in the storage file content. __TypeVersion must exist in it to be updated. 
            </summary>
            <param name="typeVersion">new __TypeVersion</param>
            <param name="s">serialized Settings field</param>
        </member>
        <member name="M:Cliver.SettingsFieldInfo.ResetObject">
            <summary>
            Replaces the value of the field with a new object initiated with the default values. 
            Tries to load it from the initial file located in the app's directory. 
            If this file does not exist, it creates an object with the hardcoded values.
            </summary>
        </member>
        <member name="M:Cliver.SettingsFieldInfo.ReloadObject">
            <summary>
            Replaces the value of the field a new object initiated with the stored values.
            Tries to load it from the storage file.
            If this file does not exist, it tries to load it from the initial file located in the app's directory. 
            If this file does not exist, it creates an object with the hardcoded values.
            </summary>
        </member>
        <member name="M:Cliver.Crypto.Halojoy.convert_by_halojoy(System.String)">
            <summary>
            EnCrypt to/from DeCrypt
            </summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="P:Cliver.DbConnection.Database">
            <summary>
            Current database
            </summary>
        </member>
        <member name="P:Cliver.DbConnection.RefreshedNativeConnection">
            <summary>
            Native connection that must be casted.
            </summary>
        </member>
        <member name="P:Cliver.DbConnection.Item(System.String)">
            <summary>
            Creates and caches a command.
            </summary>
            <param name="sql"></param>
            <returns></returns>
        </member>
        <member name="M:Cliver.DbConnection.Get(System.String)">
            <summary>
            Creates a not cached command.
            </summary>
            <param name="sql"></param>
            <returns></returns>
        </member>
        <member name="T:Cliver.Enum`1">
            <summary>
            Base class for Enum implementation.
            </summary>
            <typeparam name="V">value type</typeparam>
        </member>
        <member name="M:Cliver.Enum`1.#ctor(`0)">
            <summary>
            Create a Enum from a value.
            </summary>
            <param name="value"></param>
        </member>
        <member name="P:Cliver.Enum`1.Value">
            <summary>
            Value of this Enum.
            </summary>
        </member>
        <member name="M:Cliver.Enum`1.ToDictionary``1">
            <summary>
            
            </summary>
            <typeparam name="E"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Cliver.Enum`1.ToList``1">
            <summary>
            
            </summary>
            <typeparam name="E"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Cliver.Enum`1.Parse``1(System.String,System.Boolean)">
            <summary>
            Convert a value string into a Enum.
            </summary>
            <typeparam name="E"></typeparam>
            <param name="valueStr"></param>
            <param name="ignoreCase"></param>
            <returns></returns>
        </member>
        <member name="M:Cliver.Enum`1.IsAmong``1(``0[])">
            <summary>
            Check if this Enum is included in a given collection.
            </summary>
            <typeparam name="E"></typeparam>
            <param name="objects"></param>
            <returns></returns>
        </member>
        <member name="M:Cliver.Enum`1.IsAmong``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Check if this Enum is included in a given collection.
            </summary>
            <typeparam name="E"></typeparam>
            <param name="objects"></param>
            <returns></returns>
        </member>
        <member name="M:Cliver.Extensions.BeginInvoke(System.Delegate,System.Object[])">
            <summary>
            Replacement for BeginInvoke() which is not supported in .NET5
            </summary>
            <param name="delegate"></param>
            <param name="ps"></param>
        </member>
        <member name="T:Cliver.HandyDictionary`2">
            <summary>
            Features:
            - auto-generating values;
            - auto-disposing IDisposable values that have left the dictionary;
            </summary>
            <typeparam name="KT">key type</typeparam>
            <typeparam name="VT">value type</typeparam>
        </member>
        <member name="M:Cliver.HandyDictionary`2.#ctor(Cliver.HandyDictionary{`0,`1}.GetValue,Cliver.HandyDictionary{`0,`1}.DisposeValue)">
            <summary>
            Create HandyDictionary with auto-generating value function.
            </summary>
            <param name="getValue">method of creating an object for a key</param>
            <param name="disposeValue">method of disposing a value</param>
        </member>
        <member name="T:Cliver.HandyDictionary`2.GetValue">
            <summary>
            Method of creating an object for a key.
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="T:Cliver.HandyDictionary`2.DisposeValue">
            <summary>
            Method of disposing a value.
            </summary>
            <param name="value"></param>
        </member>
        <member name="F:Cliver.HandyDictionary`2.disposeValue">
            <summary>
            Method of disposing a value.
            </summary>
        </member>
        <member name="M:Cliver.HandyDictionary`2.#ctor(`1,Cliver.HandyDictionary{`0,`1}.DisposeValue)">
            <summary>
            Create HandyDictionary without auto-generating value function.
            </summary>
            <param name="defaultValue">the default value returned for an unset key</param>
            <param name="disposeValue">method of disposing a value</param>
        </member>
        <member name="M:Cliver.HandyDictionary`2.#ctor(Cliver.HandyDictionary{`0,`1}.DisposeValue)">
            <summary>
            Create HandyDictionary without auto-generating value function.
            </summary>
            <param name="disposeValue">method of disposing a value</param>
        </member>
        <member name="M:Cliver.HandyDictionary`2.Finalize">
            <summary>
            
            </summary>
        </member>
        <member name="M:Cliver.HandyDictionary`2.Dispose">
            <summary>
            
            </summary>
        </member>
        <member name="M:Cliver.HandyDictionary`2.Clear">
            <summary>
            Clear the dictionary and dispose disposable elements.
            </summary>
        </member>
        <member name="M:Cliver.HandyDictionary`2.Remove(`0)">
            <summary>
            Remove the element by the key and dispose it if disposable.
            </summary>
            <param name="key"></param>
        </member>
        <member name="P:Cliver.HandyDictionary`2.Item(`0)">
            <summary>
            It is safe: returns default if does not exists.
            To check for existance, use TryGetValue().
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:Cliver.HandyDictionary`2.GetEnumerator">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:Cliver.HandyDictionary`2.Keys">
            <summary>
            Actual key collection.
            </summary>
        </member>
        <member name="P:Cliver.HandyDictionary`2.Values">
            <summary>
            Actual value collection.
            </summary>
        </member>
        <member name="M:Cliver.HandyDictionary`2.TryGetValue(`0,`1@)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Cliver.HandyDictionary`2.Add(`0,`1)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="P:Cliver.HandyDictionary`2.Count">
            <summary>
            (!)The count can be implicitly changed by the auto-generating value function.
            </summary>
        </member>
        <member name="T:Cliver.HandyList`1">
            <summary>
            Features:
            - auto-disposing IDisposable values which have left the list;
            </summary>
            <typeparam name="VT"></typeparam>
        </member>
        <member name="P:Cliver.HandyList`1.Item(System.Int32)">
            <summary>
            It is safe: returns default if does not exists.
            To check for existance, use TryGetValue().
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Cliver.ListDb.IndexedTable`1.Save(`0)">
            <summary>
            Table works as an ordered HashSet
            </summary>
            <param name="document"></param>
            <returns></returns>
        </member>
        <member name="M:Cliver.ListDb.IndexedTable`1.Add(`0)">
            <summary>
            Table works as an ordered HashSet
            </summary>
            <param name="document"></param>
        </member>
        <member name="M:Cliver.ListDb.IndexedTable`1.Insert(System.Int32,`0)">
            <summary>
            Table works as an ordered HashSet
            </summary>
            <param name="index"></param>
            <param name="document"></param>
        </member>
        <member name="M:Cliver.ListDb.Table`1.Save(`0)">
            <summary>
            Table works as an ordered HashSet
            </summary>
            <param name="document"></param>
            <returns></returns>
        </member>
        <member name="M:Cliver.ListDb.Table`1.Add(`0)">
            <summary>
            Table works as an ordered HashSet
            </summary>
            <param name="document"></param>
        </member>
        <member name="M:Cliver.ListDb.Table`1.Insert(System.Int32,`0)">
            <summary>
            Table works as an ordered HashSet
            </summary>
            <param name="document"></param>
        </member>
        <member name="T:Cliver.Log">
            <summary>
            Multithreaded logging routines
            </summary>
            <summary>
            
            </summary>
            <summary>
            Writting log methods for the head session
            </summary>
        </member>
        <member name="M:Cliver.Log.DeleteOldLogs(System.Int32,System.Func{System.String,System.Boolean})">
            <summary>
            Deletes Log data from disk that is older than the specified threshold
            </summary>
        </member>
        <member name="M:Cliver.Log.GetStackString(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Get stack information for the caller.
            </summary>
            <param name="startFrame">frame to start with</param>
            <param name="frameCount">number of frames to take</param>
            <param name="endOnEmptyFile">if true, stop when going out of the app</param>
            <returns>stack info</returns>
        </member>
        <member name="M:Cliver.Log.GetExceptionMessage2(System.Exception)">
            <summary>
            Get exception message without stack info.
            </summary>
            <param name="e">exception</param>
            <returns>exception message chain</returns>
        </member>
        <member name="M:Cliver.Log.GetExceptionMessage(System.Exception,System.Boolean)">
            <summary>
            Get the exception message chain.
            </summary>
            <param name="e">exception</param>
            <param name="withDetails">add stack info</param>
            <returns>exception message chain</returns>
        </member>
        <member name="M:Cliver.Log.GetThisMethodName(System.String)">
            <summary>
            Return name of the method which called this function
            </summary>
            <param name="name">don't change it</param>
            <returns>name of the calling method</returns>
        </member>
        <member name="F:Cliver.Log.ProgramName">
            <summary>
            Name of the assembly considered first in the program.
            </summary>
        </member>
        <member name="F:Cliver.Log.CompanyName">
            <summary>
            Company name of the executing file.
            </summary>
        </member>
        <member name="P:Cliver.Log.CompanyCommonDataDir">
            <summary>
            User-independent company data directory.
            (!)No write permission on macOS
            </summary>
        </member>
        <member name="P:Cliver.Log.AppCompanyCommonDataDir">
            <summary>
            User-independent company-application data directory.
            (!)No write permission on macOS
            </summary>
        </member>
        <member name="P:Cliver.Log.CompanyUserDataDir">
            <summary>
            User-specific company data directory.
            </summary>
        </member>
        <member name="P:Cliver.Log.AppCompanyUserDataDir">
            <summary>
            User-specific company-application data directory.
            </summary>
        </member>
        <member name="F:Cliver.Log.AppDir">
            <summary>
            Directory where the application binary is located.
            </summary>
        </member>
        <member name="M:Cliver.Log.Initialize(System.Nullable{Cliver.Log.Mode},System.Collections.Generic.List{System.String},System.Int32,System.String)">
            <summary>
            Shuts down the log engine and re-initializes it. Optional.
            </summary>
            <param name="mode">log configuration</param>
            <param name="baseDirs">directories for logging, ordered by preference. When NULL, the built-in directory list is used.</param>
            <param name="deleteLogsOlderThanDays">old logs that are older than the number of days will be deleted. When negative, no clean-up is performed.</param>
            <param name="rootDirName">RootDir folder name</param>
        </member>
        <member name="F:Cliver.Log.DefaultLevel">
            <summary>
            Log level which is passed to each log as default.
            </summary>
        </member>
        <member name="F:Cliver.Log.DefaultMaxFileSize">
            <summary>
            Maximum log file length in bytes which is passed to each log as default.
            If negative than no effect.
            </summary>
        </member>
        <member name="F:Cliver.Log.TimePattern">
            <summary>
            Pattern of time recorded before a log message. See DateTime.ToString() format.
            </summary>
        </member>
        <member name="F:Cliver.Log.ReuseThreadLogIndexes">
            <summary>
            Whether thread log indexes of closed logs can be reused.
            </summary>
        </member>
        <member name="F:Cliver.Log.FileExtension">
            <summary>
            Extension of log files.
            </summary>
        </member>
        <member name="F:Cliver.Log.RootDirNameSuffix">
            <summary>
            Suffix to the RootDir folder name.
            </summary>
        </member>
        <member name="T:Cliver.Log.Mode">
            <summary>
            Log configuration.
            </summary>
        </member>
        <member name="F:Cliver.Log.Mode.ONE_FOLDER">
            <summary>
            No session folder is created. Log files are in one folder.
            It is default option if not FOLDER_PER_SESSION, otherwise, ignored.
            </summary>
        </member>
        <member name="F:Cliver.Log.Mode.FOLDER_PER_SESSION">
            <summary>
            Each session creates its own folder.
            </summary>
        </member>
        <member name="F:Cliver.Log.Mode.DEFAULT_NAMED_LOG">
            <summary>
            Default log is named log.
            It is default option if not THREAD_DEFAULT_LOG, otherwise, ignored.
            </summary>
        </member>
        <member name="F:Cliver.Log.Mode.DEFAULT_THREAD_LOG">
            <summary>
            Default log is thread log.
            </summary>
        </member>
        <member name="P:Cliver.Log.Head">
            <summary>
            Head session which is created by default.
            </summary>
        </member>
        <member name="P:Cliver.Log.Default">
            <summary>
            Default log of the head session. 
            </summary>
        </member>
        <member name="P:Cliver.Log.Main">
            <summary>
            Main log of the head session.
            </summary>
        </member>
        <member name="P:Cliver.Log.Thread">
            <summary>
            Thread log of the head session.
            </summary>
        </member>
        <member name="T:Cliver.Log.Level">
            <summary>
            Message importance levels.
            </summary>
        </member>
        <member name="T:Cliver.Log.MessageType">
            <summary>
            Message types.
            </summary>
        </member>
        <member name="M:Cliver.Log.CloseAll">
            <summary>
            Clear all existing sessions and close all the logs.
            </summary>
        </member>
        <member name="P:Cliver.Log.RootDir">
             <summary>
            Directory where logs and log sessions are written.
             </summary>
        </member>
        <member name="P:Cliver.Log.BaseDir">
             <summary>
            Actual base directory where RootDir is created.
             </summary>
        </member>
        <member name="M:Cliver.Log.Get(System.String)">
            <summary>
            Creates or retrieves a session-less log writer which allows continuous writing to the same log file in Log.RootDir. 
            </summary>
            <param name="name">log name</param>
            <returns>wirter</returns>
        </member>
        <member name="M:Cliver.Log.IWriteApi.Error(System.Exception)">
            <summary>
            Write exception with details.
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:Cliver.Log.IWriteApi.Error2(System.Exception)">
            <summary>
            Write exception without details.
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:Cliver.Log.IWriteApi.Error(System.String)">
            <summary>
            Write error with trace details.
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:Cliver.Log.IWriteApi.Error(System.String,System.Exception)">
            <summary>
            Write error with exception and details.
            </summary>
            <param name="message"></param>
            <param name="e"></param>
        </member>
        <member name="M:Cliver.Log.IWriteApi.Error2(System.String)">
            <summary>
            Write error without trace details.
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:Cliver.Log.IWriteApi.Error2(System.String,System.Exception)">
            <summary>
            Write error with exception and without trace details.
            </summary>
            <param name="message"></param>
            <param name="e"></param>
        </member>
        <member name="M:Cliver.Log.IWriteApi.Trace(System.Object)">
            <summary>
            Write object with the stack information.
            </summary>
            <param name="object_"></param>
        </member>
        <member name="M:Cliver.Log.IWriteApi.Exit(System.String)">
            <summary>
            Write error with details and terminate the process.
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:Cliver.Log.IWriteApi.Exit2(System.String)">
            <summary>
            Write error without details and terminate the process.
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:Cliver.Log.IWriteApi.Exit(System.Exception)">
            <summary>
            Write exception with details and terminate the process.
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:Cliver.Log.IWriteApi.Warning(System.String)">
            <summary>
            Write warning with stack details.
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:Cliver.Log.IWriteApi.Warning(System.String,System.Exception)">
            <summary>
            Write warning with exception and details.
            </summary>
            <param name="message"></param>
            <param name="e"></param>
        </member>
        <member name="M:Cliver.Log.IWriteApi.Warning2(System.String)">
            <summary>
            Write warning without details.
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:Cliver.Log.IWriteApi.Warning2(System.String,System.Exception)">
            <summary>
            Write warning with exception and without details.
            </summary>
            <param name="message"></param>
            <param name="e"></param>
        </member>
        <member name="M:Cliver.Log.IWriteApi.Warning(System.Exception)">
            <summary>
            Write exception with details.
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:Cliver.Log.IWriteApi.Warning2(System.Exception)">
            <summary>
            Write exception without details.
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:Cliver.Log.IWriteApi.Inform0(System.String)">
            <summary>
            Write message with details.
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:Cliver.Log.IWriteApi.Inform(System.String)">
            <summary>
            Write message without details.
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:Cliver.Log.IWriteApi.Debug0(System.String)">
            <summary>
            Write debug message with details.
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:Cliver.Log.IWriteApi.Debug(System.String)">
            <summary>
            Write debug message without details.
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:Cliver.Log.IWriteApi.Write0(System.String)">
            <summary>
            Write message without type and with details.
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:Cliver.Log.IWriteApi.Write(System.String)">
            <summary>
            Write message without type and without details.
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:Cliver.Log.IWriteApi.Write(Cliver.Log.MessageType,System.String,System.String)">
            <summary>
            Base writting log method.
            </summary>
            <param name="messageType"></param>
            <param name="message"></param>
            <param name="details"></param>
        </member>
        <member name="T:Cliver.Log.NamedWriter">
            <summary> 
            A session-less named log writer that allows to write the same log file directly to RootDir. 
            </summary>
        </member>
        <member name="M:Cliver.Log.NamedWriter.Get(System.String)">
            <summary>
            Creates or retrieves a session-less log writer which allows continuous writing to the same log file in Log.RootDir. 
            </summary>
            <param name="name">log name</param>
            <returns>wirter</returns>
        </member>
        <member name="M:Cliver.Log.NamedWriter.CloseAll">
            <summary>
            Close all the session-less log files. 
            </summary>
        </member>
        <member name="T:Cliver.Log.Session">
            <summary>
            Log session.
            </summary>
        </member>
        <member name="F:Cliver.Log.Session.NamePrefix">
            <summary>
            Prefix to the session folder name.
            </summary>
        </member>
        <member name="P:Cliver.Log.Session.Name">
            <summary>
            Session name.
            </summary>
        </member>
        <member name="P:Cliver.Log.Session.Dir">
            <summary>
            Session directory.
            </summary>
        </member>
        <member name="P:Cliver.Log.Session.CreatedTime">
            <summary>
            Time when the session was created.
            </summary>
        </member>
        <member name="P:Cliver.Log.Session.TimeMark">
            <summary>
            Time mark in the session directory of log names.
            </summary>
        </member>
        <member name="P:Cliver.Log.Session.Default">
            <summary>
            Default log of the session.
            Depending on Mode, it is either Main log or Thread log.
            </summary>
        </member>
        <member name="M:Cliver.Log.Session.Rename(System.String,System.Int32,System.Int32)">
            <summary>
            Close all log files in the session.  
            Nevertheless the session can be re-used after.
            Make sure that during this call no log of this session is used.
            </summary>
            <param name="newName">new name</param>
            <param name="tryMaxCount">number of attempts if the session foldr is locked</param>
            <param name="tryDelayMss">time span between attempts</param>
        </member>
        <member name="M:Cliver.Log.Session.Close(System.Boolean)">
            <summary>
            Close all log files in the session. 
            </summary>
            <param name="reuse">if true, the same session folder can be used again, otherwise a new folder will be created for this session</param>
        </member>
        <member name="P:Cliver.Log.Session.Item(System.String)">
            <summary>
            Get log by name.
            It will be created if not exists.
            </summary>
            <param name="name">log name that can not be a number</param>
            <returns>named log</returns>
        </member>
        <member name="P:Cliver.Log.Session.Main">
            <summary>
            Main log of the session.
            </summary>
        </member>
        <member name="T:Cliver.Log.Session.NamedWriter">
            <summary>
            Named log
            </summary>
        </member>
        <member name="M:Cliver.Log.Session.CloseAll">
            <summary>
            Close all the sessions.
            </summary>
        </member>
        <member name="M:Cliver.Log.Session.Get(System.String)">
            <summary>
            Get the session.
            It will be created if not exists.
            </summary>
            <param name="sessionName">session name</param>
            <returns>session</returns>
        </member>
        <member name="M:Cliver.Log.Session.GetAll">
            <summary>
            Get all the existing sessions.
            </summary>
            <returns>existing sessions</returns>
        </member>
        <member name="P:Cliver.Log.Session.Thread">
            <summary>
            Get log for this thread.
            It will be created if not exists.
            </summary>
            <returns>thread log</returns>
        </member>
        <member name="T:Cliver.Log.Session.ThreadWriter">
            <summary>
            Thread log.
            </summary>
        </member>
        <member name="F:Cliver.Log.Session.ThreadWriter.Id">
            <summary>
            Log ID.
            </summary>
        </member>
        <member name="F:Cliver.Log.Session.ThreadWriter.Thread">
            <summary>
            Log thread.
            </summary>
        </member>
        <member name="T:Cliver.Log.Session.Writer">
            <summary>
            The underlaying class for Session.NamedWriter and Session.ThreadWriter
            </summary>
        </member>
        <member name="F:Cliver.Log.Session.Writer.Session">
            <summary>
            Session to which this log belongs.
            </summary>
        </member>
        <member name="P:Cliver.Log.Session.Writer.Level">
            <summary>
            Message importance level.
            </summary>
        </member>
        <member name="M:Cliver.Log.Error(System.Exception)">
            <summary>
            Write exception with details.
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:Cliver.Log.Error2(System.Exception)">
            <summary>
            Write exception without details.
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:Cliver.Log.Error(System.String)">
            <summary>
            Write error with trace details.
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:Cliver.Log.Error(System.String,System.Exception)">
            <summary>
            Write error with exception and details.
            </summary>
            <param name="message"></param>
            <param name="e"></param>
        </member>
        <member name="M:Cliver.Log.Error2(System.String)">
            <summary>
            Write error without trace details.
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:Cliver.Log.Error2(System.String,System.Exception)">
            <summary>
            Write error with exception and without trace details.
            </summary>
            <param name="message"></param>
            <param name="e"></param>
        </member>
        <member name="M:Cliver.Log.Trace(System.Object)">
            <summary>
            Write object with the stack information.
            </summary>
            <param name="object_"></param>
        </member>
        <member name="M:Cliver.Log.Exit(System.String)">
            <summary>
            Write error with details and terminate the process.
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:Cliver.Log.Exit2(System.String)">
            <summary>
            Write error without details and terminate the process.
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:Cliver.Log.Exit(System.Exception)">
            <summary>
            Write exception with details and terminate the process.
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:Cliver.Log.Warning(System.String)">
            <summary>
            Write warning with stack details.
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:Cliver.Log.Warning(System.String,System.Exception)">
            <summary>
            Write warning with exception and details.
            </summary>
            <param name="message"></param>
            <param name="e"></param>
        </member>
        <member name="M:Cliver.Log.Warning2(System.String)">
            <summary>
            Write warning without details.
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:Cliver.Log.Warning2(System.String,System.Exception)">
            <summary>
            Write warning with exception and without details.
            </summary>
            <param name="message"></param>
            <param name="e"></param>
        </member>
        <member name="M:Cliver.Log.Warning(System.Exception)">
            <summary>
            Write exception with details.
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:Cliver.Log.Warning2(System.Exception)">
            <summary>
            Write exception without details.
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:Cliver.Log.Inform0(System.String)">
            <summary>
            Write message with details.
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:Cliver.Log.Inform(System.String)">
            <summary>
            Write message without details.
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:Cliver.Log.Debug0(System.String)">
            <summary>
            Write debug message with details.
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:Cliver.Log.Debug(System.String)">
            <summary>
            Write debug message without details.
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:Cliver.Log.Write0(System.String)">
            <summary>
            Write message without type and with details.
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:Cliver.Log.Write(System.String)">
            <summary>
            Write message without type and without details.
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:Cliver.Log.Write(Cliver.Log.MessageType,System.String,System.String)">
            <summary>
            General writting log method.
            </summary>
            <param name="messageType"></param>
            <param name="message"></param>
            <param name="details"></param>
        </member>
        <member name="T:Cliver.Log.Writer">
            <summary>
            The base log writer. 
            </summary>
        </member>
        <member name="F:Cliver.Log.Writer.Name">
            <summary>
            Log name.
            </summary>
        </member>
        <member name="P:Cliver.Log.Writer.Level">
            <summary>
            Message importance level.
            </summary>
        </member>
        <member name="P:Cliver.Log.Writer.File">
            <summary>
            Log file path.
            </summary>
        </member>
        <member name="F:Cliver.Log.Writer.MaxFileSize">
            <summary>
            Maximum log file length in bytes.
            If negative than no effect.
            </summary>
        </member>
        <member name="M:Cliver.Log.Writer.Close">
            <summary>
            Close the log
            </summary>
        </member>
        <member name="M:Cliver.Log.Writer.Write(Cliver.Log.MessageType,System.String,System.String)">
            <summary>
            Base writting log method.
            </summary>
        </member>
        <member name="T:Cliver.Log.Writer.OnWrite">
            <summary>
            Called for Writing. 
            </summary>
            <param name="logWriterName"></param>
            <param name="messageType"></param>
            <param name="message"></param>
            <param name="details"></param>
        </member>
        <member name="E:Cliver.Log.Writer.Writing">
            <summary>
            Triggered before writing message.
            </summary>
        </member>
        <member name="T:Cliver.Exception2">
            <summary>
            Trace info for such Exception is not logged. 
            It is intended for foreseen errors.
            </summary>
        </member>
        <member name="M:Cliver.ConvertionRoutines.Normalize(System.Decimal)">
            <summary>
            (Credit to stackoverflow people)
            Makes the decimal lose the right trailing zero's
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Cliver.ConvertionRoutines.ToTrimmedString(System.Decimal)">
            <summary>
            Due to internal implementation a decimal retains the number of positions after '.'
            Those positions go to string output by default and this function removes them if they are insignificant.
            </summary>
            <param name="d"></param>
            <returns></returns>
        </member>
        <member name="T:Cliver.DateTimeRoutines">
            <summary>
            Miscellaneous and parsing methods for DateTime
            </summary>
        </member>
        <member name="M:Cliver.DateTimeRoutines.GetSecondsSinceUnixEpoch(System.DateTime)">
            <summary>
            Amount of seconds elapsed between 1970-01-01 00:00:00 and the date-time.
            </summary>
            <param name="dateTime">date-time</param>
            <returns>seconds</returns>
        </member>
        <member name="T:Cliver.DateTimeRoutines.ParsedDateTime">
            <summary>
            Defines a substring where date-time was found and result of conversion
            </summary>
        </member>
        <member name="F:Cliver.DateTimeRoutines.ParsedDateTime.IndexOfDate">
            <summary>
            Position of the date substring found
            </summary>
        </member>
        <member name="F:Cliver.DateTimeRoutines.ParsedDateTime.LengthOfDate">
            <summary>
            Length of the date substring found
            </summary>
        </member>
        <member name="F:Cliver.DateTimeRoutines.ParsedDateTime.IndexOfTime">
            <summary>
            Position of the time substring found
            </summary>
        </member>
        <member name="F:Cliver.DateTimeRoutines.ParsedDateTime.LengthOfTime">
            <summary>
            Length of the time substring found
            </summary>
        </member>
        <member name="F:Cliver.DateTimeRoutines.ParsedDateTime.DateTime">
            <summary>
            DateTime detected
            </summary>
        </member>
        <member name="F:Cliver.DateTimeRoutines.ParsedDateTime.IsDateFound">
            <summary>
            True if a date was found, False if it was constructed
            </summary>
        </member>
        <member name="F:Cliver.DateTimeRoutines.ParsedDateTime.IsTimeFound">
            <summary>
            True if a time was found, False if it was constructed
            </summary>
        </member>
        <member name="F:Cliver.DateTimeRoutines.ParsedDateTime.UtcOffset">
            <summary>
            UTC offset if it was found
            </summary>
        </member>
        <member name="F:Cliver.DateTimeRoutines.ParsedDateTime.IsUtcOffsetFound">
            <summary>
            True if UTC offset was found
            </summary>
        </member>
        <member name="F:Cliver.DateTimeRoutines.ParsedDateTime.UtcDateTime">
            <summary>
            Utc gotten from DateTime if IsUtcOffsetFound is True
            </summary>
        </member>
        <member name="P:Cliver.DateTimeRoutines.DefaultDate">
            <summary>
            Date that is used in the following cases:
            - no date was parsed by TryParseDateOrTime();
            - no year was found by TryParseDate();
            - no century was found by TryParseDate();
            It is ignored if DefaultDateIsNow = true was set after DefaultDate 
            </summary>
        </member>
        <member name="F:Cliver.DateTimeRoutines.DefaultDateIsNow">
            <summary>
            If true then DefaultDate property is ignored and DefaultDate is always DateTime.Now
            </summary>
        </member>
        <member name="T:Cliver.DateTimeRoutines.DateTimeFormat">
            <summary>
            Defines default date-time format.
            </summary>
        </member>
        <member name="F:Cliver.DateTimeRoutines.DateTimeFormat.USA_DATE">
            <summary>
            month number goes before day number
            </summary>
        </member>
        <member name="F:Cliver.DateTimeRoutines.DateTimeFormat.UK_DATE">
            <summary>
            day number goes before month number
            </summary>
        </member>
        <member name="M:Cliver.DateTimeRoutines.TryParseDateTime(System.String,Cliver.DateTimeRoutines.DateTimeFormat,System.DateTime@)">
            <summary>
            Tries to find date and time within the passed string and return it as DateTime structure. 
            </summary>
            <param name="str">string that contains date and/or time</param>
            <param name="default_format">format to be used preferably in ambivalent instances</param>
            <param name="date_time">parsed date-time output</param>
            <returns>true if both date and time were found, else false</returns>
        </member>
        <member name="M:Cliver.DateTimeRoutines.TryParseDateOrTime(System.String,Cliver.DateTimeRoutines.DateTimeFormat,System.DateTime@)">
            <summary>
            Tries to find date and/or time within the passed string and return it as DateTime structure. 
            If only date was found, time in the returned DateTime is always 0:0:0.
            If only time was found, date in the returned DateTime is DefaultDate.
            </summary>
            <param name="str">string that contains date and(or) time</param>
            <param name="default_format">format to be used preferably in ambivalent instances</param>
            <param name="date_time">parsed date-time output</param>
            <returns>true if date and/or time was found, else false</returns>
        </member>
        <member name="M:Cliver.DateTimeRoutines.TryParseTime(System.String,Cliver.DateTimeRoutines.DateTimeFormat,System.DateTime@)">
            <summary>
            Tries to find time within the passed string and return it as DateTime structure. 
            It recognizes only time while ignoring date, so date in the returned DateTime is always 1/1/1.
            </summary>
            <param name="str">string that contains time</param>
            <param name="default_format">format to be used preferably in ambivalent instances</param>
            <param name="time">parsed time output</param>
            <returns>true if time was found, else false</returns>
        </member>
        <member name="M:Cliver.DateTimeRoutines.TryParseDate(System.String,Cliver.DateTimeRoutines.DateTimeFormat,System.DateTime@)">
            <summary>
            Tries to find date within the passed string and return it as DateTime structure. 
            It recognizes only date while ignoring time, so time in the returned DateTime is always 0:0:0.
            If year of the date was not found then it accepts the current year. 
            </summary>
            <param name="str">string that contains date</param>
            <param name="default_format">format to be used preferably in ambivalent instances</param>
            <param name="date">parsed date output</param>
            <returns>true if date was found, else false</returns>
        </member>
        <member name="M:Cliver.DateTimeRoutines.TryParseDateTime(System.String,Cliver.DateTimeRoutines.DateTimeFormat,Cliver.DateTimeRoutines.ParsedDateTime@)">
            <summary>
            Tries to find date and time within the passed string and return it as ParsedDateTime object. 
            </summary>
            <param name="str">string that contains date-time</param>
            <param name="default_format">format to be used preferably in ambivalent instances</param>
            <param name="parsed_date_time">parsed date-time output</param>
            <returns>true if both date and time were found, else false</returns>
        </member>
        <member name="M:Cliver.DateTimeRoutines.TryParseTime(System.String,Cliver.DateTimeRoutines.DateTimeFormat,Cliver.DateTimeRoutines.ParsedDateTime@)">
            <summary>
            Tries to find time within the passed string and return it as ParsedDateTime object. 
            It recognizes only time while ignoring date, so date in the returned ParsedDateTime is always 1/1/1
            </summary>
            <param name="str">string that contains date-time</param>
            <param name="default_format">format to be used preferably in ambivalent instances</param>
            <param name="parsed_time">parsed date-time output</param>
            <returns>true if time was found, else false</returns>
        </member>
        <member name="M:Cliver.DateTimeRoutines.TryParseDateOrTime(System.String,Cliver.DateTimeRoutines.DateTimeFormat,Cliver.DateTimeRoutines.ParsedDateTime@)">
            <summary>
            Tries to find date and/or time within the passed string and return it as ParsedDateTime object. 
            If only date was found, time in the returned ParsedDateTime is always 0:0:0.
            If only time was found, date in the returned ParsedDateTime is DefaultDate.
            </summary>
            <param name="str">string that contains date-time</param>
            <param name="default_format">format to be used preferably in ambivalent instances</param>
            <param name="parsed_date_time">parsed date-time output</param>
            <returns>true if date or time was found, else false</returns>
        </member>
        <member name="M:Cliver.DateTimeRoutines.TryParseTime(System.String,Cliver.DateTimeRoutines.DateTimeFormat,Cliver.DateTimeRoutines.ParsedDateTime@,Cliver.DateTimeRoutines.ParsedDateTime)">
            <summary>
            Tries to find time within the passed string (relatively to the passed parsed_date if any) and return it as ParsedDateTime object.
            It recognizes only time while ignoring date, so date in the returned ParsedDateTime is always 1/1/1
            </summary>
            <param name="str">string that contains date</param>
            <param name="default_format">format to be used preferably in ambivalent instances</param>
            <param name="parsed_time">parsed date-time output</param>
            <param name="parsed_date">ParsedDateTime object if the date was found within this string, else NULL</param>
            <returns>true if time was found, else false</returns>
        </member>
        <member name="M:Cliver.DateTimeRoutines.TryParseDate(System.String,Cliver.DateTimeRoutines.DateTimeFormat,Cliver.DateTimeRoutines.ParsedDateTime@)">
            <summary>
            Tries to find date within the passed string and return it as ParsedDateTime object. 
            It recognizes only date while ignoring time, so time in the returned ParsedDateTime is always 0:0:0.
            If year of the date was not found then it accepts the current year. 
            </summary>
            <param name="str">string that contains date</param>
            <param name="default_format">format to be used preferably in ambivalent instances</param>
            <param name="parsed_date">parsed date output</param>
            <returns>true if date was found, else false</returns>
        </member>
        <member name="M:Cliver.FileSystemRoutines.FindFullCommandLinePath(System.String,System.String,System.String)">
            <summary>
            
            </summary>
            <param name="fileName"></param>
            <param name="PATHs">dirs listes like environmentVariable PATH</param>
            <param name="PATHEXTs">extensions listed like environmentVariable PATHEXT</param>
            <returns></returns>
        </member>
        <member name="M:Cliver.FileSystemRoutines.CopyFile(System.String,System.String,System.Boolean)">
            <summary>
            Creates the dir if it is missing.
            (!)It throws an exception when the destination file exists and !overwrite.
            </summary>
            <param name="file1"></param>
            <param name="file2"></param>
            <param name="overwrite"></param>
        </member>
        <member name="T:Cliver.PathRoutines">
            <summary>
            Miscellaneous useful methods for file path/name construction
            </summary>
        </member>
        <member name="M:Cliver.PathRoutines.GetLegalizedPath(System.String,System.Boolean,System.String)">
            <summary>
            Convert illegal characters in the path.
            </summary>
            <param name="path"></param>
            <param name="webDecode"></param>
            <param name="illegalCharReplacement"></param>
            <returns></returns>
        </member>
        <member name="M:Cliver.PathRoutines.GetLegalizedFileName(System.String,System.Boolean,System.String)">
            <summary>
            Exctract the file name and convert illegal characters in it.
            </summary>
            <param name="file"></param>
            <param name="webDecode"></param>
            <param name="illegalCharReplacement"></param>
            <returns></returns>
        </member>
        <member name="M:Cliver.PathRoutines.GetLegalizedFile(System.String,System.Boolean,System.String)">
            <summary>
            Convert illegal characters in the directory and in the file name.
            </summary>
            <param name="file"></param>
            <param name="webDecode"></param>
            <param name="illegalCharReplacement"></param>
            <returns></returns>
        </member>
        <member name="M:Cliver.PathRoutines.GetFileName(System.String)">
            <summary>
            Works for any length path unlike Path.GetFileName()
            </summary>
            <param name="file"></param>
            <returns></returns>
        </member>
        <member name="M:Cliver.PathRoutines.GetDirName(System.String)">
            <summary>
            Works for any length path unlike Path.GetFileName()
            </summary>
            <param name="dir"></param>
            <returns></returns>
        </member>
        <member name="M:Cliver.PathRoutines.GetFileExtension(System.String)">
            <summary>
            Works for any length path unlike Path.GetFileName()
            </summary>
            <param name="file"></param>
            <returns></returns>
        </member>
        <member name="M:Cliver.PathRoutines.GetFileDir(System.String,System.Boolean)">
            <summary>
            Get the parent dir of a file or dir.
            Works for any length path unlike Path.GetDir().
            </summary>
            <param name="file"></param>
            <param name="removeTrailingSeparator"></param>
            <returns></returns>        
        </member>
        <member name="M:Cliver.ProcessRoutines.Open(System.String)">
            <summary>
            Opens a file in editor/veiwer determined by the file's extension.
            </summary>
            <param name="file"></param>
        </member>
        <member name="M:Cliver.ProcessRoutines.Exit">
            <summary>
            Must be invoked if this process needs some time to exit.
            </summary>
        </member>
        <member name="M:Cliver.ProcessRoutines.Restart(System.Boolean,System.String)">
            <summary>
            
            </summary>
            <param name="as_administarator"></param>
            <param name="arguments">if NULL then reuse parameters of the calling process</param>
        </member>
        <member name="M:Cliver.ProcessRoutines.IsRunning(System.Diagnostics.Process)">
            <summary>
            Safe method instead of HasExited
            </summary>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="M:Cliver.ReflectionRoutines.GetNameOfVariablePassedInAsParameter(System.String,System.Int32)">
            <summary>
            !!!not debugged! It will not work for Release
            </summary>
            <param name="parameterName"></param>
            <param name="frame"></param>
            <returns></returns>
        </member>
        <member name="T:Cliver.ThreadRoutines">
            <summary>
            Sleep not freezing the app
            </summary>
        </member>
        <member name="T:Cliver.Serialization">
            <summary>
            Serialization helpers.
            </summary>
        </member>
        <member name="M:Cliver.Serialization.Binary.Serialize(System.Object)">
            <summary>
            Serialize object
            </summary>
            <param name="o"></param>
            <returns></returns>
        </member>
        <member name="T:Cliver.Serialization.Json">
            <summary>
            Serialization to JSON.
            </summary>
        </member>
        <member name="T:Cliver.Serialization.Json.NoIndentConverter">
            <summary>
            Usage: [Newtonsoft.Json.JsonConverter(typeof(Serialization.Json.NoIndentConverter))]
            !!!Issue: does not work on types
            </summary>
        </member>
        <member name="M:Cliver.Serialization.Xml.Serialize2``1(``0)">
            <summary>
            Serialize object
            </summary>
            <typeparam name="T"></typeparam>
            <param name="o"></param>
            <returns></returns>
        </member>
        <member name="M:Cliver.Serialization.Xml.Deserialize2``1(System.String)">
            <summary>
            Deserialize object
            </summary>
            <typeparam name="T"></typeparam>
            <param name="xml"></param>
            <returns></returns>
        </member>
        <member name="M:Cliver.Serialization.Xml.Serialize``1(``0)">
            <summary>
            Serialize object
            </summary>
            <typeparam name="T"></typeparam>
            <param name="o"></param>
            <returns></returns>
        </member>
        <member name="M:Cliver.Serialization.Xml.Deserialize``1(System.String)">
            <summary>
            Deserialize object
            </summary>
            <typeparam name="T"></typeparam>
            <param name="xml"></param>
            <returns></returns>
        </member>
        <member name="T:Cliver.Set`2">
            <summary>
            Base class for Set implementation.
            </summary>
            <typeparam name="V">Cliver.Enum type</typeparam>
            <typeparam name="T">Cliver.Enum value type</typeparam>
        </member>
        <member name="M:Cliver.Set`2.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Create a Set from a collection of values.
            </summary>
            <param name="values"></param>
        </member>
        <member name="P:Cliver.Set`2.Values">
            <summary>
            Collection of Enum's contained by this Set
            </summary>
        </member>
        <member name="M:Cliver.Set`2.Add``1(``0)">
            <summary>
            Enhance this Set with another one.
            </summary>
            <typeparam name="S"></typeparam>
            <param name="set"></param>
            <returns></returns>
        </member>
        <member name="M:Cliver.Set`2.Add``1(`0[])">
            <summary>
            Enhance this Set with a collection of Enum's.
            </summary>
            <typeparam name="S"></typeparam>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="M:Cliver.Set`2.Subtract``1(``0)">
            <summary>
            Diminish this Set by another Set.
            </summary>
            <typeparam name="S"></typeparam>
            <param name="set"></param>
            <returns></returns>
        </member>
        <member name="M:Cliver.Set`2.Subtract``1(`0[])">
            <summary>
            Diminish this Set by a collection of Enum's.
            </summary>
            <typeparam name="S"></typeparam>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="M:Cliver.Set`2.op_Equality(Cliver.Set{`0,`1},Cliver.Set{`0,`1})">
            <summary>
            2 Set's comprise of the same Enum's.
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:Cliver.Set`2.op_Inequality(Cliver.Set{`0,`1},Cliver.Set{`0,`1})">
            <summary>
            2 Set's do not comprise of the same Enum's.
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:Cliver.Set`2.Parse``1(System.String,System.String,System.Boolean)">
            <summary>
            Convert a values string into a Set.
            </summary>
            <typeparam name="S"></typeparam>
            <param name="valuesStr"></param>
            <param name="separator"></param>
            <param name="ignoreCase"></param>
            <returns></returns>
        </member>
        <member name="M:Cliver.Set`2.Contains``1(`0[])">
            <summary>
            Checks if this Set includes all given values.
            </summary>
            <typeparam name="S"></typeparam>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="M:Cliver.Set`2.Contains``1(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Checks if this Set includes all given values.
            </summary>
            <typeparam name="S"></typeparam>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="M:Cliver.Set`2.Contains``1(``0)">
            <summary>
            Checks if this Set includes all the values of a given Set.
            </summary>
            <typeparam name="S"></typeparam>
            <param name="set"></param>
            <returns></returns>
        </member>
        <member name="T:Cliver.Synchronization">
            <summary>
            Template for synchronizing Settings storage files, any files and application setup files through a cloud service. (The local system is required to have the service synchronizing app running.)  
            </summary>
        </member>
        <member name="P:Cliver.Synchronization.synchronizedSettingsFieldFullNames">
            <summary>
            
            </summary>
        </member>
        <member name="M:Cliver.Synchronization.onNewerSettingsFile(Cliver.Settings)">
            <summary>
            
            </summary>
            <param name="settings"></param>
        </member>
        <member name="P:Cliver.Synchronization.synchronizedFolders">
            <summary>
            
            </summary>
        </member>
        <member name="M:Cliver.Synchronization.onNewerFile(System.String)">
            <summary>
            
            </summary>
            <param name="file"></param>
        </member>
        <member name="P:Cliver.Synchronization.appSetupFileFilter">
            <summary>
            
            </summary>
        </member>
        <member name="P:Cliver.Synchronization.programVersion">
            <summary>
            
            </summary>
        </member>
        <member name="M:Cliver.Synchronization.onNewerAppVersion(System.String)">
            <summary>
            
            </summary>
            <param name="appSetupFile"></param>
        </member>
        <member name="M:Cliver.Synchronization.ErrorHandler(System.Exception)">
            <summary>
            
            </summary>
            <param name="e"></param>
        </member>
        <member name="T:Cliver.Synchronization.Parameters">
            <summary>
            
            </summary>
        </member>
        <member name="F:Cliver.Synchronization.Parameters.SynchronizationFolder">
            <summary>
            
            </summary>
        </member>
        <member name="F:Cliver.Synchronization.Parameters.DownloadFolderName">
            <summary>
            
            </summary>
        </member>
        <member name="F:Cliver.Synchronization.Parameters.UploadFolderName">
            <summary>
            
            </summary>
        </member>
        <member name="F:Cliver.Synchronization.Parameters.Synchronize">
            <summary>
            
            </summary>
        </member>
        <member name="F:Cliver.Synchronization.Parameters.PollingPeriodMss">
            <summary>
            
            </summary>
        </member>
        <member name="M:Cliver.Synchronization.Switch(Cliver.Synchronization.Parameters)">
            <summary>
            Actualize new parameters.
            </summary>
            <param name="parameters"></param>
        </member>
        <member name="T:Cliver.WebClient">
            <summary>
            Enhanced System.Net.WebClient
            </summary>
        </member>
        <member name="M:Cliver.WebClient.GetWebResponse(System.Net.WebRequest,System.IAsyncResult)">
            <summary>
            
            </summary>
            <param name="request"></param>
            <param name="asyncResult"></param>
            <returns></returns>
        </member>
        <member name="M:Cliver.WebClient.GetWebResponse(System.Net.WebRequest)">
            <summary>
            
            </summary>
            <param name="request"></param>
            <returns></returns>
        </member>
        <member name="P:Cliver.WebClient.Response">
            <summary>
            
            </summary>
        </member>
        <member name="P:Cliver.WebClient.Exception">
            <summary>
            
            </summary>
        </member>
        <member name="M:Cliver.WebClient.GetWebRequest(System.Uri)">
            <summary>
            
            </summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="P:Cliver.WebClient.Request">
            <summary>
            
            </summary>
        </member>
        <member name="F:Cliver.WebClient.CookieContainer">
            <summary>
            
            </summary>
        </member>
    </members>
</doc>
