<html>
<head>
    <title>CliverRoutines</title>

    <link rel="stylesheet" type="text/css" href="main.css">
    <link rel="stylesheet" type="text/css" href="menu_generator.css">

    <link href="prism.css" rel="stylesheet" />

</head>
<body>
    <script src="prism.js"></script>
    <div class='header'>
        <div class='mainHeader'>CliverRoutines 6.*</div>
    </div>

    <div class='content'>
        <h1><a name='overview'>Overview</a></h1>
        <p> CliverRoutines is a cross-platform C# lib which contains:

 <ul>
                <li> <a href="#config">application settings manager</a> superseding .NET <code>ConfigurationManager</code>;</li>
                <li> <a href="#log">logger</a> with <a href='#thread_log'>threading</a> and <a href='#log_session'>session</a> support;</li>
                <li> <a href="#miscellaneous">auxiliary routines</a>;</li>
            </ul>
			
<p><b>Compatibility</b>
<br>CliverRoutines has been developed in .NET Standard 2.0 and supposed to run on any platform that adopts C# including .NET, Xamarin, Mono.			
<br>A possible concern about certain platform might arise due to peculiarities of its file system.

			<p>CliverRoutines has been used on:
<br> - Windows 7, 10 in C# projects including windows services;
<br> - macOS High Sierra 10.12 in Xamarin.Mac projects built in Visual Studio for Mac;


            <h2><a name='licensing'>Licensing</a></h2>
			
			 See <a href='https://raw.githubusercontent.com/sergeystoyan/CliverRoutines/master/LICENSE' target='_blank'>the license source</a>.
			<br><br>
			<textarea id="license" rows="30" cols="100">
           
</textarea>
<script>
function setLicense() {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', 'https://raw.githubusercontent.com/sergeystoyan/CliverRoutines/master/LICENSE');
    xhr.send(null);

    xhr.onreadystatechange = function () {
        var status = 4;
        var http_code = 200;
        if (xhr.readyState === status) {
            if (xhr.status === http_code)  {
                var textarea = document.getElementById('license');
                textarea.value = xhr.responseText;
            } else {
                // do something with an error here
            }
        } 
    }
};

setLicense();
</script>
        <p>*Notice that CliverRoutines may use third-party software as command line tools or linked libraries which should be licensed independently.

            <h2><a name='licensing'>Source code</a></h2>
            Open <a href='https://github.com/sergeystoyan/CliverRoutines' target='_blank'>repository</a>.
        <p>
            Do not download the latest code from a branch because it may be under development. Instead, use the latest (pre-)release code.




            <h1><a name='config'>Config</a></h1>

<a href='#config'><code>Cliver.Config</code></a> is an application settings manager intended as a capable, yet simple in use replacement for .NET ConfigurationManager.

<p><b>Features:</b>

<br> - cross-platform;
<br> - natively supports types of any complexity;
<br> - settings are easily modified directly in code;
<br> - natively allows polymorphism;
<br> - supports encryption;
<br> - thread-safe;
<br> - serializes data in JSON;


<p><b>Idea:</b> 

<br><a href='#settings_class'>Settings types</a> are ordinary C# classes that you define in your code according to your needs thus achieving a great flexibility. <a href='#config'><code>Cliver.Config</code></a> automatically detects static <a href='#settings_field'>fields/properties</a> that are of those types and facilitates their serialization/deserialization to/from disk.

<p>While <a href='#config'><code>Cliver.Config</code></a> was designed primarily as a settings manager, in conjunction with <code>System.Linq</code> it can be used as a simple nosql database.			

<p>To grasp how to use it by example, refer directly to <a href='#config_usage'>the usage</a>.	
			
			
			
			
			
			

<h2><a name='settings_class'>Settings type</a></h2>
<a href='#settings_class'>Settings type</a> is a custom class whose fields and properties are serialized/deserialized according to the needs of the application. 

<p>While generally a <a href='#settings_class'>settings class</a> can be considered as a fully functional class, it must comply with the following conditions:
<br> - it must inherit from <a href='#cliver_settings'><code>Cliver.Settings</code></a> class. This inheritance can be indirectly via other classes;
<br> - it must either have no explicit constructor or have a <code>public</code> parameterless one;
		
<p>There can be any number of <a href='#settings_class'>settings types</a> defined in your code.

			
			
<p>Example of a <a href='#settings_class'>settings type</a>:			
<script type="text/plain" class="language-csharp">public class GeneralSettings : Cliver.UserSettings //serialized to the user data directory.
{   	
	public List<string> RecentFiles; 	
	public Color HighlightColor = Color.Orange;
	
	protected override void Loaded()
	{
		if(RecentFiles == null)
			RecentFiles = new List<string>(); 
	}
	
	protected override void Saving()
	{
		RecentFiles = RecentFiles.Distinct();
	}
}</script>

	
	
	
			
			

<h3><a name='serializable_field'>Serializable fields</a></h3>
<a href='#serializable_field'>Serializable fields</a> are fields or properties of a <a href='#settings_class'>settings class</a> that are (!)<code>public</code> and non-static. 

<p>Serialization/deserialization is performed by <a href='https://www.newtonsoft.com/json' target='_blank'>Newtonsoft.Json</a> engine.			
Hence, you can apply attributes provided by Newtonsoft.Json to <a href='#serializable_field'>serializable fields</a> to alter their serialization behavior. To do so, you have to reference Newtonsoft.Json in your project. (!)To avoid compilation problems, make sure that it is the same version that is referenced by CliverRoutines. For more info refer to <a href='https://www.newtonsoft.com/json' target='_blank'>Newtonsoft.Json</a> documentation. 			
			
<p>(!)While a <a href='#settings_class'>settings class</a> can implement any logic and members, remember that nevertheless there are restrictions for what and how can be serialized. For instance, data which depend on the current application state like <code>events, FieldInfo</code> types will be lost through serialization.





						
            <h3><a name='cliver_settings'>Cliver.Settings</a></h3>
			<a href='#cliver_settings'><code>Cliver.Settings</code></a> is a base class for building custom <a href='#settings_class'>settings types</a> in your code.
<p>It exposes the members that allow managing serialization routine in its derivatives:
<br> - property <code>__Info</code> which links an instance of <a href='#settings_class'>a settings type</a> to a certain <a href='#settings_field'>settings field</a>;
<br> - serialization methods;
<br> - auxiliary methods. Some of them can be redefined in your <a href='#settings_class'>settings class</a> if needed;
<br>See the API for more info.

        <p>			Usually you will not inherit <a href='#cliver_settings'><code>Cliver.Settings</code></a> directly but rather use one of its derivatives provided by CliverRoutines: <a href="#cliver_usersettings"><code>Cliver.UserSettings</code></a> and <a href="#cliver_appsettings"><code>Cliver.AppSettings</code></a>.
			<br>If your <a href='#settings_class'>settings class</a> inherits <a href='#cliver_settings'><code>Cliver.Settings</code></a> directly then you have to define the serialization directory in it.



            <h4><a name="cliver_usersettings">Cliver.UserSettings</a></h4>
<a href="#cliver_usersettings"><code>Cliver.UserSettings</code></a> is a <a href='#cliver_settings'><code>Cliver.Settings</code></a> derivative which performs serialization to the current user's application data directory. 




            <h4><a name="cliver_appsettings">Cliver.AppSettings</a></h4>
<a href="#cliver_appsettings"><code>Cliver.AppSettings</code></a> is a <a href='#cliver_settings'><code>Cliver.Settings</code></a> derivative which performs serialization to the common (user-irrelevant) application data directory. 
<p>(!)Writing to this directory on Windows may require additional permissions which is solved by <code>Cliver.Win.AppSettings</code> in CliverWinRoutines package.

				    
				   
		

			


			
<h2><a name='settings_field'>Settings field</a></h2>
<p>(!)Do not confuse <a href='#settings_field'>settings fields</a> with <a href='#serializable_field'>serializable fields</a>.

<p>A <a href='#settings_field'>settings field</a> is a field or property declared in any class of your app, that satisfies the following:
<br> - its type is a <a href='#settings_class'>settings type</a>;
<br> - it is <code>static</code> (<code>public</code> modifier is optional);

<br>Also, if the used .NET version supports setting readonly variables through reflection which not all the versions do, it can be declared as <code>readonly</code>.

			
<p><a href='#settings_field'>Settings fields</a> are automatically detected and initialized by <a href='#config'><code>Cliver.Config</code></a>.
<p>Behavior of a <a href='#settings_field'>settings field</a> can be influenced by <a href='#config_Attributes'>attributes</a> applied to it. 

<p>There can be any number of <a href='#settings_field'>settings fields</a> in your code.
<br> Usually you need to have only one <a href='#settings_field'>settings field</a> per <a href='#settings_class'>settings type</a>, but there is no problem to declare any number of <a href='#settings_field'>settings fields</a> of the same <a href='#settings_class'>settings type</a>.
				   
<p>Example of a <a href='#settings_field'>settings field</a>:
<script type="text/plain" class="language-csharp">public partial class Archive
{
	//settings field
	//it can be a field or a property
	//depending on .NET version, it can be readonly
	public static GeneralSettings General; 
}

//settings type
public class GeneralSettings : Cliver.UserSettings 
{   	
	...
}</script>





		
<h3>Initialization</h3>
        <br> Detection and initialization of <a href='#settings_field'>settings field</a>s must be triggered from your code. It can be preceded by optional configuration of <a href='#config'><code>Cliver.Config</code></a> (example: <a href='#config_Load_order'>load order</a>. For the complete options refer to the API).
<script type="text/plain" class="language-csharp">//optional configuration
...
//detect and initialize settings fields. 
Cliver.Config.Reload();//mandatory</script>			   
				
				
				
				
<h3>Assembly scope</h3>
        <br>(!)When looking for <a href='#settings_field'>settings fields</a> in an application, <a href='#config'><code>Cliver.Config</code></a> searches within the following assemblies by default:
<br> - the assembly that calls one of <a href='#config'><code>Cliver.Config</code></a>'s initializing methods;
<br> - assemblies that are referenced by the calling assembly;
<br>The search scope is limited this way in order not to load more assemblies which inevitably takes place when enumerating through them. 
 
<p>If needed, the assembly scope can be assigned from your code explicitly by setting <code>Cliver.Config.ExplicitlyTrackedAssemblies</code> before initializing <a href='#config'><code>Cliver.Config</code></a> engine:
<script type="text/plain" class="language-csharp">Cliver.Config.ExplicitlyTrackedAssemblies = new List<System.Reflection.Assembly> { Assembly.GetExecutingAssembly() };
Cliver.Config.Reload();</script>		
			
			
				   
				   
			
			
			
<h3><a name='storage_file'>Storage file</a></h3>
		A <a href='#storage_file'>storage file</a> stores serialized data for one <a href='#settings_field'>settings field</a>. Thus, every <a href='#settings_field'>settings field</a> has its own <a href='#storage_file'>storage file</a>. 
		
		<p>It is (re)created by <code>Save()</code> method:
<script type="text/plain" class="language-csharp">public partial class Settings
{
	public static GeneralSettings General;
}
...
Settings.General.Save();</script>
			
			
			
			<h4>Path</h4>
			<p><a href='#storage_file'>Storage file</a>'s path is defined as follows: the file directory is predetermined by the <a href='#settings_class'>settings type</a> and the file name is predetermined by the <a href='#settings_field'>settings field</a>'s full path in the code.
									
<p>See the example:
<script type="text/plain" class="language-csharp">namespace Example
{
	public class GeneralSettings : Cliver.UserSettings
	{   	
		...
	}
	
	public partial class Settings
	{
		public static GeneralSettings General;
	}
}</script>
The <a href='#storage_file'>storage file</a> path of <a href='#settings_field'>settings field</a> <code>Settings.General</code> will be:
			<table style="table-layout:fixed;">
			<tr>
			<td bgcolor="#efefef">storage file path:</td>
			<td bgcolor="#ddf" style="margin:0;padding:0;border:0;border-collapse:collapse;">C:\Users\serge\AppData\Local\</td>
			<td bgcolor="#def" style="margin:0;padding:0;border:0;border-collapse:collapse;">Dupersoft\Test\config\</td>
			<td bgcolor="#dff" style="margin:0;padding:0;border:0;border-collapse:collapse;">Example.Settings.General.json</td>
				</tr>
				<tr>
			<td bgcolor="#efefef">predetermined by:</td>
			<td bgcolor="#fafafa" style="width:10px;"><code>Cliver.UserSettings</code></td>
			<td bgcolor="#fafafa" style="width:10px;">application name 'Test' and company name 'Dupersoft'</td>
			<td bgcolor="#fafafa" style="width:10px;">the full path of field <code>General</code> in the application</td>
			</tr>
			</table>
			





			
			
<h3><a name='initial_file'>Initial file</a></h3>
			<p>An <a href='#initial_file'>initial file</a> keeps data that is to override the initial values hard-coded in a <a href='#settings_class'>settings type</a>'s definition. Each <a href='#settings_field'>settings field</a> can have its own <a href='#initial_file'>initial file</a> and thus, can have its own initial value set. 
			
			<p>It is optional and has the same format as a <a href='#storage_file'>storage file</a>.
			
		<p>An <a href='#initial_file'>initial file</a> is (re)read by <code>Reset()</code> method or, when no <a href='#storage_file'>storage file</a> exists, also by <code>Reload()</code> method.
			
			<p>It is supplied in the same directory as the application's main module.
		 
			
			<p>It is helpful when:
			<br> - initial settings data are too big to be kept in code;
			<br> - initial settings data are managed better in file than in code;
			<br> - the application has several <a href='#settings_field'>settings fields</a> of the same <a href='#settings_class'>settings type</a> and each of them must be initiated by its own value set;
						
			
			
			<h4>Name</h4>
			<p>An <a href='#initial_file'>initial file</a>'s name is predetermined by its <a href='#settings_field'>settings field</a>'s full path in the code.
									
<p>See the example:
<script type="text/plain" class="language-csharp">namespace App
{	
	public class Settings
	{
		public static GeneralSettings General;
	}
}</script>
Name of the <a href='#initial_file'>initial file</a> of the <a href='#settings_field'>settings field</a> <code>Settings.General</code> will be 'App.Settings.General.json'.



			
			
<h3>Loading</h3>
            <br><a href='#config'><code>Cliver.Config</code></a> performs loading of a <a href='#settings_field'>settings field</a> in the following order:
			
			<p><code><b>Reload()</code></b>
			<br> - from one's <a href='#storage_file'>storage file</a> if exists;
			<br> - from one's <a href='#initial_file'>initial file</a> if exists;
			<br> - from the values predefined in one's <a href='#settings_class'>settings type</a>;
		
			<p><code><b>Reset()</code></b>
			<br> - from one's <a href='#initial_file'>initial file</a> if exists;
			<br> - from the values predefined in one's <a href='#settings_class'>settings type</a>;
		
	








<h2><a name='config_usage'>Usage</a></h2>
			Reference CliverRoutines in your project.
			<br>Set your project's company name because it co-defines the directory of the <a href='#storage_file'>storage files</a>.
			
			
					
<p>Define <a href='#settings_class'>settings types</a> according to your needs like this:		
<script type="text/plain" class="language-csharp">//settings type
public class ConnectionSettings : Cliver.UserSettings //it is serialized to the user data directory
{
	public int ClientPort = 123;//serializable
	public List<Server> Servers = new List<Server>();//serializable
}

public class Server
{
	public string Name;//serializable
	public string Host;//serializable
	public int Port;	//serializable	
	internal string Status;//non-serializable
}</script>
			
			
			<p>Somewhere, declare a <a href='#settings_field'>settings field</a> for the defined <a href='#settings_class'>settings type</a>:			
<script type="text/plain" class="language-csharp">public class Settings
{
	public static ConnectionSettings Connection;//it can be property; //depending on .NET version, it can be readonly;
}</script>


        <p>Add this call at the beginning of your application, to make <a href='#config'><code>Cliver.Config</code></a> detect all <a href='#settings_field'>settings fields</a> in the code and initialize them:
<script type="text/plain" class="language-csharp">//it can be called many times; every call re-initializes all the settings.
Cliver.Config.Reload();//mandatory call before using settings</script>


         <p>      Now settings are ready to be used:
<script type="text/plain" class="language-csharp">//modify
Settings.Connection.ClientPort = 234;
Settings.Connection.Servers.Add(new Server {Name = "host1", Host = "123.123.123.123", Port = 345});
...
//save on disk
Settings.Connection.Save();
//or, restore the previously saved values
Settings.Connection.Reload();
//or, reset to the initial values
Settings.Connection.Reset();
...
//pass to a function
Server server = Settings.Connection.Servers.Find(a => a.Name == "host1");
connect(Settings.General.ClientPort, server.Host, server.Port);</script>
			<p>To find live examples, refer to CliverRoutinesExample project in CliverRoutines solution.
			<br>For the complete usage options, review <a href='#config'><code>Cliver.Config</code></a> API and annotations. 





<h2>Attached/detached instances</h2>
			  
		   <p>In the trivial use case, <a href='#settings_field'>settings fields</a> are only initialized by <a href='#config'><code>Cliver.Config</code></a> which for every <a href='#settings_field'>settings field</a> creates an instance of the respective <a href='#settings_class'>settings type</a> and sets it as the value of the field. 
		   <br>But you, too, can create or clone instances of <a href='#settings_class'>settings types</a>. And if a <a href='#settings_field'>settings field</a> is non-readonly, you can replace its value with another instance. 
<br>See <a href='#swapping_settings'>the replacing example</a>.
		   
		   <p>A <a href='#settings_class'>settings type</a> instance keeps information about its <a href='#settings_field'>settings field</a> in <code>__Info</code> object which is created only by <a href='#config'><code>Cliver.Config</code></a>. Therefore, an instance that is created by your code has <code>__Info</code> empty until you set it with the <code>__Info</code> taken from the respective instance generated by <a href='#config'><code>Cliver.Config</code></a>.		   
		   
<p>If an instance of a <a href='#settings_class'>settings type</a> is the value of the <a href='#settings_field'>settings field</a> pointed by its <code>__Info</code>, it is called <i>attached</i>, otherwise, <i>detached</i>. 
		   <br>This distinction is important because deattached <a href='#settings_class'>settings type</a> instances have a restricted functionality because otherwise it would lead to a confusion. So, when replacing the value of a <a href='#settings_field'>settings field</a> with a new instance, make sure that the latter has <code>__Info</code> pointing to this <a href='#settings_field'>settings field</a>. 
		   <br>  See <a href='#passing_to_process'>the passing example</a>.





<h2><a name='config_Attributes'>Attributes</a></h2>
<p>Class <code>Cliver.SettingsAttributes</code> exposes attributes which are applicable to <a href='#settings_field'>settings fields</a> and/or <a href='#settings_class'>settings types</a>. Those attributes allow altering <a href='#settings_field'>settings fields</a> features. Attributes of a <a href='#settings_field'>settings field</a> can be accessed at runtime though its <code>__Info</code> property. For example:


<script type="text/plain" class="language-csharp">[SettingsAttributes.Config(Indented = false)]//to serialize without indention
class GeneralSettings : Cliver.UserSettings//UserSettings based class is serialized in the user directory
{
	public Dictionary<string, User> Users = new Dictionary<string, User>();

	protected override void Saving()
	{
		ConfigExample.Log.Inform0("Settings saving...: " + __Info.FullName + " with indention: " + __Info.Indented);
	}
}</script>

<p>More examples can be found in <a href="#config_Tips">the tips</a>. Refer to the API and annotations for the complete attribute list.




		 
            <h2><a name='config_Tips'>Tips</a></h2>

            <h3><a name='restoring_predefined_collections'>(!)Predefined collections</a></h3>
			
			Pay attention that when you predefine a collection of values in your code, it will be doubled every time when it is saved/restored. It is how <code>Newtonsoft.Json</code> works by default.
			<br>To alter this behavior, add the attribute as in the example below:

<script type="text/plain" class="language-csharp">public class GeneralSettings : Cliver.UserSettings
{   	
	//avoid doubling the collection's elements
    [Newtonsoft.Json.JsonProperty(ObjectCreationHandling = Newtonsoft.Json.ObjectCreationHandling.Replace)]
	public List<string> Options = new List<string>("apple", "pear", "banana"); 
}</script>
			
			
            <h3><a name=''>Ignored fields/properties</a></h3>

            To make a certain field or property not serializable, make it <code>non-public</code>. Otherwise, reference <code>Newtonsoft.Json</code> and add the attribute as in the example:
<script type="text/plain" class="language-csharp">public class GeneralSettings : Cliver.UserSettings
{   	
	//this field will not be serialized
	internal string Password; 
	
	//this field will not be serialized
	[Newtonsoft.Json.JsonIgnore]
	public string Password2;
}</script>	





            <h3><a name='swapping_settings'>Cloning and replacing</a></h3>


            <p>Sometimes it is handy to modify not a <a href='#settings_field'>settings field</a> itself but its clone and then replace it:
<script type="text/plain" class="language-csharp">//create a clone
GeneralSettings general2 = Settings.General.CreateClone();//!!!property __Info is not cloned here but references the same object.

//modify
general2.ClientPort = 123;//general2 is detached because it is not refernced by any settings field

if(userOk())
{
	Settings.General = general2;//now general2 becomes attached
	Settings.General.Save();
}</script>

<p>Or, consider the opposite case: you need to save an edited <a href='#settings_field'>settings field</a> while its clone is in use and must remain unchanged until the end of the process so that the changes will come into play after restart:
<script type="text/plain" class="language-csharp">//create a clone which should not be changed
GeneralSettings general0 = Settings.General.CreateClone();
//using it until the end of the process...

...
//modify the original
general.ClientPort = 123;
//save it so that the changes will come into play after restart
Settings.General.Save();</script>




            <h3><a name=''>Polymorphism</a></h3>
Being ordinary C# classes, <a href='#settings_class'>settings types</a> support polymorphism. That is, you can build many <a href='#settings_class'>settings types</a> inheriting the same parent and easily switch between them depending on the application logic. See the example.

<p>Define a base <a href='#settings_class'>settings type</a> and its derivatives:
<script type="text/plain" class="language-csharp">//base settings class which you will reference in your code
abstract public class Settings : Cliver.UserSettings
{
	virtual public string Uri { get; set; }

	//it is ignored by the serialization engine because ScopeSettings is abstract class
	public static Settings This { get; internal set; }//a settings field can be nested in its own settings type
}

//derivative1 implementing certain logic
public class Settings1 : Settings
{
	override public string Uri { get; set; } = "http://www.help.com/doc1.html";

	public static Settings1 This;//a settings field can be nested in its own settings type
}

//derivative2 implementing certain logic
public class Settings2 : Settings
{
	override public string Uri { get; set; } = "http://www.help.com/doc2.html";

	public static Settings2 This;//a settings field can be nested in its own settings type
}</script>

<p>Now, without regard to the actual derivative, you can use <code>Settings.This</code> uniformly:
<script type="text/plain" class="language-csharp">//Initialize the settings fields
Config.Reload();
//set the required derivative
Settings.This = Settings1.This;
...
//using Settings.This uniformly without regard to the actual derivative
Process.Start(Settings.This.Uri);
Settings.This.Uri = "http://www.help.com/doc3.html"; 
Settings.This.Save();</script>









<h3><a name='configEncrypting'>Encrypting</a></h3>

            <h4><a name=''>Settings field/type</a></h4>
A whole <a href='#settings_field'>settings field</a> can be serialized as an encrypted string by adding the attribute <code>Encrypted</code> either to the <a href='#settings_field'>settings field</a> or to its <a href='#settings_class'>settings type</a> declaration:
<script type="text/plain" class="language-csharp">//An example of encryption of a Settings type/field
partial class Settings
{
	//Alternatively, the Encrypted attribute can be added directly to the field: 
	//[SettingsAttributes.Encrypted(stringEndecGetterHostingType: typeof(Settings), stringEndecGetterName: nameof(Settings.Endec))]
	//This object will be serialized as encrypted string
	internal static CredentialsSettings Credentials;

	//A StringEndec object passed into SettingsFieldAttribute.EncryptedAttribute
	public static StringEndec.Rijndael Endec { get; } = new StringEndec.Rijndael("111");
	//An alternative by CliverWinRoutines which does not require a key:
	//public static Cliver.Win.StringEndec Endec { get; } = new Cliver.Win.StringEndec();   
}

//Specify the class and the property that expose a StringEndec object to be used for encryption.
//This attribute can be applied to either a Settings type or a Settings field. Being applied to the type, it causes any field of this type to be encrypted.
[SettingsAttributes.Encrypted(stringEndecGetterHostingType: typeof(Settings), stringEndecGetterName: nameof(Settings.Endec))]
class CredentialsSettings : Cliver.UserSettings
{
	public string Key = "test";
	public string Token = "123";
}</script>

<p><code>Settings.Credentials</code> will be stored in <a href='#storage_file'>the storage file</a> as a string encrypted by the <code>StringEndec</code> instance that you provided.








            <h4><a name=''>Serializable field</a></h4>
Also, it is possible to encrypt a <a href='#settings_field'>settings field</a> not as a whole but only its certain member(s) (i.e. <a href='#serializable_field'>serializable fields</a>). How it is done:
<script type="text/plain" class="language-csharp">class ServerSettings : Cliver.UserSettings
{
	static ServerSettings()
	{
		//if you are not on Windows and cannot use CliverWinRoutines, you have to initialize StringEndec with a key
		Cliver.Encrypted<string>.InitializeDefault(new Cliver.StringEndec.Rijndael("123"));
	}

	public string Host = "";
	public int Port = 123;
	public Cliver.Encrypted<string> Password = new Cliver.Encrypted<string>();
	//Windows alternative provided by CliverWinRoutines:
	//public Cliver.Win.Encrypted<string> Password = new Cliver.Win.Encrypted<string>();    
}

public class Settings
{
	public static ServerSettings Server;
}</script>

<p>Now you can use it like this:
<script type="text/plain" class="language-csharp">Settings.Server.Password.Value = password;
Settings.Server.Save();

...
connect(Settings.Server.Host, Settings.Server.Password.Value);</script>

<p>With this encryption, the value is kept encrypted almost all the process time, being decrypted only when called explicitly. It is more secure against RAM sniffers.







            <h3><a name='passing_to_process'>Passing to another process</a></h3>
You can pass a <a href='#settings_field'>settings field</a> to another process. It should be done through serialization.

<p>In process 1:
<script type="text/plain" class="language-csharp">string generalStr = Cliver.Serialization.Json.Serialize(Settings.General);

//pass generalStr to process 2...</script>

<p>In process 2:
<script type="text/plain" class="language-csharp">//restore
GeneralSettings general = Cliver.Serialization.Json.Deserialize(generalStr);
//modify
general.Files.Add("c:\\other.txt");
//serialize
generalStr = Cliver.Serialization.Json.Serialize(general);

//pass generalStr back to process 1...</script>

<p>In process 1:
<script type="text/plain" class="language-csharp">//accept modifications
GeneralSettings general2 = Cliver.Serialization.Json.Deserialize(generalStr);
//!!!do not forget to restore __Info as it was distorted by serialization
general2.__Info = Settings.General.__Info;
Settings.General = general2;
Settings.General.Save();</script>











            <h3><a name=''>Upgrading settings type</a></h3>
Sometimes, when you upgrade an application, a <a href='#settings_class'>settings type</a> in it is changed that way that the new application cannot deserialize properly a <a href='#storage_file'>storage file</a> produced by an older application. When it happens, <a href='#config'><code>Cliver.Config</code></a> engine calls method <code>UnsupportedFormatHandler()</code> which you can override.

<p><code>UnsupportedFormatHandler()</code> is called in the following cases:
<br>- deserialization engine thew an exception meaning that the <a href='#settings_field'>settings field</a> could not be deserialized and is set to a default value;
<br>- the <a href='#settings_field'>settings field</a> was deserialized but its type version is still not acceptable meaning that some restored data may be deteriorated and need amending. This can be the case only if attribute <code>TypeVersion</code> is specified;

<p><b>TypeVersion attribute</b>
<br>By adding the attribute <code>TypeVersion</code> to a certain <a href='#settings_class'>settings type</a> you assign a version to its declaration in the code. When the application serializes an instance of this <a href='#settings_class'>settings type</a>, its version is stored in the <a href='#storage_file'>storage file</a> as <code>__TypeVersion</code> property. Each time when you alter the <a href='#settings_class'>settings type</a>'s decalration, you should also alter its version specified by the attribute. Thus, when a newer application reads an older <a href='#storage_file'>storage file</a> or vice versa, an older application reads a newer <a href='#storage_file'>storage file</a>, the type version in the <a href='#storage_file'>storage file</a> does not correspond to the version set by the attribute and therefore <a href='#config'><code>Cliver.Config</code></a> engine will call <code>UnsupportedFormatHandler()</code>.

<p>No matter why <code>UnsupportedFormatHandler()</code> was called, within it you can provide a smooth migration of the old data to the new format. See the example below:

<p>
<script type="text/plain" class="language-csharp">//An example of upgrading a Settings type 
partial class Settings
{
	internal static TemplatesSettings Templates;
}

//Example how to check the type version and migrate to the current type if needed.
//When this attribute is set, Config checks if the version set by the attribute accords with the version saved in the storage file.
[SettingsAttributes.TypeVersion(210701)]
class TemplatesSettings : Cliver.UserSettings//UserSettings based class is serialized in the user directory
{
	public List<Template> Templates = new List<Template> { new Template { Name = "test", Words = new List<string> { "apple", "box" } } };

	//Here is your chance to upgrade the data to the current format.
	override protected UnsupportedFormatHandlerCommand UnsupportedFormatHandler(Exception deserializingException)
	{//successive upgrading from version to version using different approaches:

		//upgrading to version 200601
		if (deserializingException?.Message.Contains("Could not create an instance of type Example.Template+Field") == true || __TypeVersion < 200601)
		{//remove property Field which does not exist anymore
			Newtonsoft.Json.Linq.JObject o = __Info.ReadStorageFileAsJObject();
			for (int i = o["Templates"].Count() - 1; i >= 0; i--)
				o["Templates"][i]["Field"]?.Remove();
			//set the respective version
			o["__TypeVersion"] = 200601;
			//save
			__Info.WriteStorageFileAsJObject(o);
			return UnsupportedFormatHandlerCommand.Reload;//this method will be called again because __TypeVersion is still obsolete
		}

		//upgrading to version 210301
		if (deserializingException == null && __TypeVersion < 210301)//the object was deserialized but its __TypeVersion is not acceptable
		{
			string s = __Info.ReadStorageFileAsString();
			//edit the old data as a serialized string. Altering the raw data.
			//...
			//set the respective version
			s = Regex.Replace(s, @"(?<=\""__TypeVersion\""\:\s*)\d+", "210301", RegexOptions.Singleline);
			//save
			__Info.WriteStorageFileAsString(s);
			return UnsupportedFormatHandlerCommand.Reload;//this method will be called again because __TypeVersion is still obsolete
		}

		//upgrading to the last version
		if (deserializingException == null && __TypeVersion < __Info.TypeVersion)//the object was deserialized but its __TypeVersion is not acceptable
		{
			//alter the data in the object itself
			foreach (Template t in Templates)
				t.Name = Regex.Replace(t.Name, @"^test", "_TEST_");
			//...
			//save
			Save();//(!)when saving, the current type version is set
			return UnsupportedFormatHandlerCommand.Proceed;
		}

		if (deserializingException != null)
			Console.WriteLine("UNHANDLED EXCEPTION while deserializing " + __Info.File + ":\r\n" + Log.GetExceptionMessage(deserializingException));
		else //__TypeVersion > __Info.TypeVersion.Value     
		{
			Console.WriteLine("WARNING: The application might not support properly the newer type version " + __TypeVersion + " data stored in " + __Info.File);
			Console.WriteLine("The expected version: " + __Info.TypeVersion);
			Console.WriteLine("Consider upgrading the application.");
		}
		while (true)
		{
			Console.WriteLine("\r\nPlease choose an option:\r\nExit - [E]\r\nReset the settings to default - [R]\r\nProceed as is - [P]");
			ConsoleKey k = Console.ReadKey().Key;
			switch (k)
			{
				case ConsoleKey.E:
					Log.Exit("Settings " + __Info.FullName + " could not be loaded.");
					break;
				case ConsoleKey.R:
					return UnsupportedFormatHandlerCommand.Reset;
				case ConsoleKey.P:
					return UnsupportedFormatHandlerCommand.Proceed;
				default:
					continue;
			}
		}
	}
}

public class Template
{
	public string Name;
	public List<string> Words = new List<string>();
}</script>









            <h3><a name='config_Load_order'>Load order</a></h3>
Sometimes, if <a href='#settings_class'>settings types</a> depend on each other, you may need to configure the order in which they are initialized. It can be done by setting <code>InitializationOrderedSettingsTypes</code> before calling <code>Reload()</code>:
<script type="text/plain" class="language-csharp">Config.InitializationOrderedSettingsTypes = new System.Collections.Generic.List<Type> { typeof(GeneralSettings), typeof(TemplatesSettings) };
Config.Reload();</script>













            <!--h3><a name='initialazing_order'>Initialization order</a></h3>
You can pass a <a href='#settings_field'>settings field</a> to another process. It should be done through serialization.

<p>In process 1:
<script type="text/plain" class="language-csharp">string generalStr = Cliver.Serialization.Json.Serialize(Settings.General);

//pass generalStr to process 2...</code>
</pre-->



            <h1><a name='log'>Log</a></h1>
        <p>
            <a href='#log'><code>Cliver.Log</code></a> is a logger designed with usability and scalability in mind. 

<p><b>Features:</b>

<br> - cross-platform;
<br> - thread-safe;
<br> - <a href="#log_session">session</a> oriented - an application can write multiple log <a href="#log_session">sessions</a> successively or simultaneously. It is helpful when an application performs multiple independent tasks;
<br> - <a href="#thread_log">thread</a> oriented - it can automatically write a log per thread;
<br> - auto-cleanup of old logs;
<br> - diagnostic output;

<p>To grasp how to use it for logging sufficient in the most applications, refer directly to <a href='#log_usage'>the usage</a>.		



            <h2><a name='log_session'>Session</a></h2>

A <a href='#log_session'>session</a> is a collection of logs that is dedicated to a certain logical task. Usually a log belongs to some <a href='#log_session'>session</a> (but can be a <a href='#log_Sessionless_log'>sessionless log</a>). 
			
			<p>Depending on <a href='#log'><code>Cliver.Log</code></a> configuration, it is either:
			<br> - all the <a href='#log_session'>sessions</a> share the same folder. Log files have their session name in their names;
			<br> - or, each <a href='#log_session'>session</a> creates its own folder to which all its logs are written;
			
            <p> Session folders can be used to store additional data like caches etc.
			
			<p> Multiple <a href='#log_session'>sessions</a> can be open simultaneously.
			
			<p>Using an explicitly created <a href='#log_session'>session</a>:
<script type="text/plain" class="language-csharp">using Cliver;
...
//make each session create its own folder
Log.Initialize(Log.Mode.FOLDER_PER_SESSION);
...
//create or get the existing session
Log.Session game1Log = Log.Session.Get("Game1");
//write to the default log of the session
game1Log.Debug("message");
...
//close all the file handlers beloning to the session.
game1Log.Close(true);//optional call to free memory</script>			
			


			<h3><a name='log_default_session'>Head session</a></h3>
<a href='#log_default_session'>The default session</a> is a <a href='#log_session'>session</a> that is used when no <a href='#log_session'>session</a> is called explicitly. It is referenced as <code>Head</code> and has an empty name.

			<p><a href='#log_default_session'>The default session</a> is used for the trivial logging which is sufficient for the most applications:

<script type="text/plain" class="language-csharp">using Cliver;
...
//write to the default log of the default session
Log.Write("message");//shortcut for Log.Head.Write("message");</script>




			<h3><a name='default_log'>Default log</a></h3>
<a href='#default_log'>The default log</a> of a <a href='#log_session'>session</a> is the log that is called without explicit reference. Depending on <a href='#log'><code>Cliver.Log</code></a> configuration, it can be either <a href='#main_log'>the main log</a> (by default) or <a href='#thread_log'>thread log</a>.
		
    <p><a href='#default_log'>The default log</a> is handy as a shortcut for trivial logging when everything is written to the same file:
<script type="text/plain" class="language-csharp">using Cliver;
...
Log.Inform("test message");//shortcut for Log.Head.Main.Inform()</script>

			<p>Toggle <a href='#default_log'>the default log</a> to <a href='#thread_log'>thread log</a>:
<script type="text/plain" class="language-csharp">Log.Initialize(Log.Mode.DEFAULT_THREAD_LOG);//thread log will be used by default
Log.Inform("test message");//shortcut for Log.Head.Thread.Inform()</script>






			<h3><a name="#log_root_directory">Root directory</a></h3>
<br>
			All <a href='#log_session'>sessions</a> are created within the <a href="log_root_directory">root directory</a> which is defined at the first logging or by <code>Log.Initialize()</code>
			
			
			<p>By default, the <a href="log_root_directory">root directory</a> is defined in the order by which <a href='#log'><code>Cliver.Log</code></a> tries to write to:
			<br> - the user data folder;
			<br> - the common data folder;
			<br> - the folder where the application is located;
			<br> - the user desktop folder;
			<br> - the temp folder;
			
			<p>The <a href="log_root_directory">root directory</a> definition can be customized while initializing:
<script type="text/plain" class="language-csharp">//optional initialization before using logs
Log.Initialize(Log.Mode.FOLDER_PER_SESSION, new List<string> { Log.AppCompanyCommonDataDir });//logs will be recorded to the common data folder</script>





    <h2><a name='named_log'>Named log</a></h2>
    <a href='#named_log'>Named log</a> is a log that can be referenced by a custom name.
	<p>The name of a <a href='#named_log'>named log</a> is a part of its file name.

			
 <p>   Writing to a named log of <a href='#log_default_session'>the default session</a>:
<script type="text/plain" class="language-csharp">//writig to the log "Inform" of the default session
Log.Session.NamedWriter informLog = Log.Head["Inform"];
Log.Session.NamedWriter errorLog = Log.Head["Error"];
try
{
	informLog.Inform("test message");
}
catch (Exception e)
{
	errorLog.Error2("Failed", e);
}</script>

 <p>   Writing to a named log of an explicitly created <a href='#log_session'>session</a>:
<script type="text/plain" class="language-csharp">Log.Session game1Session = Log.Session.Get("Game1");

//to the main log
game1Session.Write("test message");

//to the log named "Test"
game1Session["Test"].Write("test message");</script>





			<h3><a name='main_log'>Main log</a></h3>
<a href='#main_log'>The main log</a> of a <a href='#log_session'>session</a> is a <a href='#named_log'>named log</a> that is not created explicitly and is referenced as <code>Main</code>. It has an empty name.

		
    
    <p><a href='#main_log'>The main log</a> is handy as a ready-to-use log:
<script type="text/plain" class="language-csharp">using Cliver;
...

//writing to the main log in the default (Head) session
Log.Main.Inform0("test message");//It is a shortcut for Log.Head.Main.Inform()</script>

Or:
<script type="text/plain" class="language-csharp">//writing to the main log of session "Game1"
Log.Session game1Session = Log.Session.Get("Game1");
game1Session.Main.Inform0("test message");</script>






    <h2><a name='thread_log'>Thread log</a></h2>
    <p>A <a href='#thread_log'>thread log</a> is a log that belongs to only one and the same .NET thread.
	
	<p>Each <a href='#thread_log'>thread log</a> has a unique ID which is a part of its file name. Depending on configuration, those ID's can be reused or be endlessly incremented for each new <a href='#thread_log'>thread log</a>.
	
	<p>In this example, each downloading thread writes its own log:
<script type="text/plain" class="language-csharp">using Cliver;
...

static void download(string uri)
{
	try
	{
		//each download thread writes its own log in the default (Head) session
		Log.Thread.Inform("test message"); //It is a shortcut for Log.Head.Thread.Inform()
	}
	catch (Exception e)
	{
		Log.Thread.Error2(e);
	}
}

static void Main(string[] args)
{
	//launch a number of parallel theads
	ThreadRoutines.Start(() => { download("http://file.com/1"); });
	...
	ThreadRoutines.Start(() => { download("http://file.com/N"); });
}</script>




    <h2><a name='log_Sessionless_log'>Sessionless log</a></h2>
    <p>A <a href='#log_Sessionless_log'>sessionless log</a> is a named log that is created within the <a href="log_root_directory">root directory</a> and does not belongs to a <a href='#log_session'>session</a> so that it is continued with the next launch of the application.
	
	<p>Example:
<script type="text/plain" class="language-csharp">Log.Writer historyLog = Log.Get("history");//create or retrieve the log
historyLog.Inform("sessionless log");</script>






            <h2><a name='log_usage'>Usage</a></h2>
			Reference CliverRoutines in your project.
			<br>Set your project's company name because it co-defines the log directory.
			
		
        <p> At the beginning of the application, add optional initialization:
<script type="text/plain" class="language-csharp">using Cliver;
...

//optional configuration. See the API and annotations for options.
Log.Level = Log.Level.WARNING;

//optional initialization. It can be called many times; every call closes all the logs and re-initializes the engine.
Log.Initialize(Log.Mode.FOLDER_PER_SESSION); //this call is not mandatory if you are ok with default settings.</script>


         <p>      Write to log:
<script type="text/plain" class="language-csharp">Log.Inform("test message"); //trivial logging</script> 
			<p>To see live examples, refer to CliverRoutinesExample project in CliverRoutines solution. 
			<br>For the complete usage options, review <a href='#log'><code>Cliver.Log</code></a> API and annotations.
		 
  






    <h1><a name='miscellaneous'>Miscellaneous</a></h1>
<p>CliverRoutines exposes a number of auxiliary routines. See the API and annotations for details.







    </div>

    <div class='footer'>
        <script src='copyright.js'></script>
        &nbsp;2006 - 2021&nbsp;&nbsp;<a href="javascript:window.location.href = '&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#115;&#101;&#114;&#103;&#101;&#121;&#46;&#115;&#116;&#111;&#121;&#97;&#110;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#109;'" target="_top">Sergey Stoyan</a>
       
    </div>

    <!--script>
    var cs = document.getElementsByTagName('code');
    for(var i = 0; i < cs.length; i++)
        cs[i].classList.add("language-csharp");
    </script-->

    <script>
        if (!window.location.href.match(/\#./ig)) {
            window.location.href = window.location.href.replace(/#.*/, '') + '#1';
            location.reload();
        }
    </script>
    <script src='menu_generator.js' shiftHeaderAndFooterToContentView=''></script>

</body>
</html>