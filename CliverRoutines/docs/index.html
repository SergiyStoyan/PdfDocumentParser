<html>
<head>
    <title>CliverRoutines</title>

    <link rel="stylesheet" type="text/css" href="main.css">
    <link rel="stylesheet" type="text/css" href="menu_generator.css">

    <link href="prism.css" rel="stylesheet" />

</head>
<body>
    <script src="prism.js"></script>
    <div class='header'>
        <div class='mainHeader'>CliverRoutines 6.*</div>
    </div>

    <div class='content'>
        <h1><a name='overview'>Overview</a></h1>
        <p> CliverRoutines is a cross-platform C# lib which includes:

 <ul>
                <li> <a href="#config">application settings manager</a> superseding .NET <code>ConfigurationManager</code>;</li>
                <li> <a href="#log">logger</a> with <a href='#thread_log'>threading</a> and <a href='#log_session'>session</a> support;</li>
                <li> <a href="#miscellaneous">auxiliary routines</a>;</li>
            </ul>
			
<p><b>Compatibility</b>
<br>CliverRoutines has been developed in .NET Standard 2.0 and supposed to run on any platform that adopts C# including .NET, Xamarin, Mono.			
<br>A possible concern about certain platform might arise due to peculiarities of its file system.

			<p>CliverRoutines has been used on:
<br> - Windows 7, 10 in C# projects including windows services;
<br> - macOS High Sierra 10.12 in Xamarin.Mac projects built in Visual Studio for Mac;


            <h2><a name='licensing'>Licensing</a></h2>
			
			 See <a href='https://raw.githubusercontent.com/sergiystoyan/CliverRoutines/master/LICENSE' target='_blank'>the license source</a>.
			<br><br>
			<textarea id="license" rows="30" cols="100">
           
</textarea>
<script>
function setLicense() {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', 'https://raw.githubusercontent.com/sergiystoyan/CliverRoutines/master/LICENSE');
    xhr.send(null);

    xhr.onreadystatechange = function () {
        var status = 4;
        var http_code = 200;
        if (xhr.readyState === status) {
            if (xhr.status === http_code)  {
                var textarea = document.getElementById('license');
                textarea.value = xhr.responseText;
            } else {
                // do something with an error here
            }
        } 
    }
};

setLicense();
</script>
        <p>*Notice that CliverRoutines may use third-party software as command line tools or linked libraries which should be licensed independently.

            <h2><a name='licensing'>Source code</a></h2>
            Open <a href='https://github.com/sergiystoyan/CliverRoutines' target='_blank'>repository</a>.
        <p>
            Do not download the latest code from a branch because it may be under development. Instead, use the latest (pre-)release code.




            <h1><a name='config'>Config</a></h1>

<a href='#config'><code>Cliver.Config</code></a> is an application settings manager intended as a capable, yet simple in use replacement for .NET ConfigurationManager.

<p><b>Features:</b>

<br> - cross-platform;
<br> - natively supports types of any complexity;
<br> - settings are easily modified directly in code;
<br> - natively allows polymorphism;
<br> - supports encryption;
<br> - thread-safe;
<br> - serializes data in JSON;


<p><b>Idea:</b> 

<br><a href='#settings_class'>Settings types</a> are ordinary C# classes that you define in your code according to your needs thus achieving a great flexibility. <a href='#config'><code>Cliver.Config</code></a> automatically detects static <a href='#settings_field'>fields/properties</a> that are of those types and facilitates their serialization/deserialization to/from disk.

<p>While <a href='#config'><code>Cliver.Config</code></a> was designed primarily as a settings manager, in conjunction with <code>System.Linq</code> it can be used as a simple nosql database.			

<p>To grasp how to use it by example, refer directly to <a href='#config_usage'>the usage</a>.	
			
			
			
			
			
			

<h2><a name='settings_class'>Settings type</a></h2>
<a href='#settings_class'>Settings type</a> is a custom class whose fields and properties are serialized/deserialized according to the needs of the application. 

<p>While generally a <a href='#settings_class'>settings class</a> can be considered as a fully functional class, it must comply with the following conditions:
<br> - it must inherit from <a href='#cliver_settings'><code>Cliver.Settings</code></a> class. This inheritance can be indirectly via other classes;
<br> - it must either have no explicit constructor or have a <code>public</code> parameterless one;
		
<p>There can be any number of <a href='#settings_class'>settings types</a> defined in your code.

			
			
<p>Example of a <a href='#settings_class'>settings type</a>:			
<script type="text/plain" class="language-csharp">public class GeneralSettings : Cliver.UserSettings //serialized to the user data directory.
{   	
	public List<string> RecentFiles; 	
	public Color HighlightColor = Color.Orange;
	
	protected override void Loaded()
	{
		if(RecentFiles == null)
			RecentFiles = new List<string>(); 
	}
	
	protected override void Saving()
	{
		RecentFiles = RecentFiles.Distinct();
	}
}</script>

	
	
	
			
			

<h3><a name='serializable_field'>Serializable fields</a></h3>
<a href='#serializable_field'>Serializable fields</a> are fields or properties of a <a href='#settings_class'>settings class</a> that are (!)<code>public</code> and non-static. 

<p>Serialization/deserialization is performed by <a href='https://www.newtonsoft.com/json' target='_blank'>Newtonsoft.Json</a> engine.			
Hence, you can apply attributes provided by Newtonsoft.Json to <a href='#serializable_field'>serializable fields</a> to alter their serialization behavior. To do so, you have to reference Newtonsoft.Json in your project. (!)To avoid compilation problems, make sure that it is the same version that is referenced by CliverRoutines. For more info refer to <a href='https://www.newtonsoft.com/json' target='_blank'>Newtonsoft.Json</a> documentation. 			
			
<p>(!)While a <a href='#settings_class'>settings class</a> can implement any logic and members, remember that nevertheless there are restrictions for what and how can be serialized. For instance, data which depend on the current application state like <code>events, FieldInfo</code> types will be lost through serialization.





						
            <h3><a name='cliver_settings'>Cliver.Settings</a></h3>
			<a href='#cliver_settings'><code>Cliver.Settings</code></a> is a base class for building custom <a href='#settings_class'>settings types</a> in your code.
<p>It exposes the members that allow managing serialization routine in its derivatives:
<br> - property <code>__Info</code> which links an instance of <a href='#settings_class'>a settings type</a> to a certain <a href='#settings_field'>settings field</a>;
<br> - serialization methods;
<br> - auxiliary methods. Some of them can be redefined in your <a href='#settings_class'>settings class</a> if needed;
<br>See the API for the complete info.

        <p>			Usually you will not inherit <a href='#cliver_settings'><code>Cliver.Settings</code></a> directly but rather use one of its derivatives provided by CliverRoutines: <a href="#cliver_usersettings"><code>Cliver.UserSettings</code></a> and <a href="#cliver_appsettings"><code>Cliver.AppSettings</code></a>.
			<br>If your <a href='#settings_class'>settings class</a> inherits <a href='#cliver_settings'><code>Cliver.Settings</code></a> directly then you have to define the serialization directory in it.



            <h4><a name="cliver_usersettings">Cliver.UserSettings</a></h4>
<a href="#cliver_usersettings"><code>Cliver.UserSettings</code></a> is a <a href='#cliver_settings'><code>Cliver.Settings</code></a> derivative which performs serialization to the current user's application data directory. 




            <h4><a name="cliver_appsettings">Cliver.AppSettings</a></h4>
<a href="#cliver_appsettings"><code>Cliver.AppSettings</code></a> is a <a href='#cliver_settings'><code>Cliver.Settings</code></a> derivative which performs serialization to the common (user-irrelevant) application data directory. 
<p>(!)Writing to this directory on Windows may require additional permissions which is solved by <code>Cliver.Win.AppSettings</code> in CliverWinRoutines package.

				    
				   
		

			


			
<h2><a name='settings_field'>Settings field</a></h2>
<p>(!)Do not confuse <a href='#settings_field'>settings fields</a> with <a href='#serializable_field'>serializable fields</a>.

<p>A <a href='#settings_field'>settings field</a> is a field or property declared in any class of your app, that satisfies the following:
<br> - its type is a <a href='#settings_class'>settings type</a>;
<br> - it is <code>static</code>;

<br>A <a href='#settings_field'>settings field</a> can have any access modifier.
<br>Also, depending on .NET version, it can be declared as <code>readonly</code> (check if the used .NET version allows setting readonly variables through reflection).

			
<p><a href='#settings_field'>Settings fields</a> are automatically detected and initialized by <a href='#config'><code>Cliver.Config</code></a>.
<p>Behavior of a <a href='#settings_field'>settings field</a> can be influenced by <a href='#config_Attributes'>the attributes</a> applied to it or its <a href='#settings_class'>type</a>. 

<p>There can be any number of <a href='#settings_field'>settings fields</a> in your code.
<br> Usually you need to have only one <a href='#settings_field'>settings field</a> per <a href='#settings_class'>settings type</a>, but there is no problem to declare any number of <a href='#settings_field'>settings fields</a> of the same <a href='#settings_class'>settings type</a>.
				   
<p>Example of a <a href='#settings_field'>settings field</a>:
<script type="text/plain" class="language-csharp">public partial class Archive
{
	//settings field
	public static HistorySettings History;//it can be either field or property
}

//settings type
public class HistorySettings : Cliver.UserSettings 
{   	
	...
}</script>

<p>Example of a <a href='#settings_field'>settings field</a> being a member of its own <a href='#settings_class'>type</a>:
<script type="text/plain" class="language-csharp">//settings type
public class HistorySettings : Cliver.UserSettings 
{   	
	//settings field
	public static HistorySettings This;//it will be ignored by the serialization engine because it is static
	...
}</script>





		
<h3>Initialization</h3>
<br> Detection and initialization of <a href='#settings_field'>settings field</a>s must be triggered from your code. It is done by calling either <code>Config.Reload()</code> or <code>Config.Reset()</code> method at the beginning of the application. 

<p>The initialization can be preceded by optional configuration of the <a href='#config'><code>Cliver.Config</code></a> engine (examples: <a href='#config_Assembly_scope'>assembly scope</a>, <a href='#config_Load_order'>load order</a>. For the complete options, refer to the API).
<script type="text/plain" class="language-csharp">//optional configuration
...
//detect and initialize settings fields. 
Cliver.Config.Reload();//mandatory;</script>			   

<p>If needed, the initialization can be preformed more than once.
				
				
<h3><a name='config_Assembly_scope'>Assembly scope</a></h3>
        <br>(!)When looking for <a href='#settings_field'>settings fields</a> in an application, <a href='#config'><code>Cliver.Config</code></a> searches within the following assemblies by default:
<br> - the assembly that calls one of <a href='#config'><code>Cliver.Config</code></a>'s initializing methods;
<br> - assemblies that are referenced by the calling assembly;
<br>The search scope is limited this way in order not to load more assemblies which inevitably takes place while enumerating through them. 
 
<p>If needed, the assembly scope can be configured explicitly in your code by setting <code>Cliver.Config.ExplicitlyTrackedAssemblies</code> before initializing <a href='#config'><code>Cliver.Config</code></a> engine:
<script type="text/plain" class="language-csharp">Cliver.Config.ExplicitlyTrackedAssemblies = new List<System.Reflection.Assembly> { Assembly.GetExecutingAssembly() };
Cliver.Config.Reload();</script>		
			
			
				   
				   
			
			
			
<h3><a name='storage_file'>Storage file</a></h3>
		A <a href='#storage_file'>storage file</a> stores serialized data for one <a href='#settings_field'>settings field</a>. Thus, every <a href='#settings_field'>settings field</a> has its own <a href='#storage_file'>storage file</a>. 
		
		<p>It is (re)created by <code>Save()</code> method:
<script type="text/plain" class="language-csharp">public partial class Settings
{
	public static GeneralSettings General;
}
...
Settings.General.Save();</script>
			
			
			
			<h4>Path</h4>
			<p><a href='#storage_file'>Storage file</a>'s path is defined as follows: the file directory is predetermined by the <a href='#settings_class'>settings type</a> and the file name is predetermined by the <a href='#settings_field'>settings field</a>'s full path in the code.
									
<p>See the example:
<script type="text/plain" class="language-csharp">namespace Example
{
	public class GeneralSettings : Cliver.UserSettings
	{   	
		...
	}
	
	public partial class Settings
	{
		public static GeneralSettings General;
	}
}</script>
The <a href='#storage_file'>storage file</a> path of <a href='#settings_field'>settings field</a> <code>Settings.General</code> will be:
			<table style="table-layout:fixed;">
			<tr>
			<td bgcolor="#efefef">storage file path:</td>
			<td bgcolor="#ddf" style="margin:0;padding:0;border:0;border-collapse:collapse;">C:\Users\serge\AppData\Local\</td>
			<td bgcolor="#def" style="margin:0;padding:0;border:0;border-collapse:collapse;">Dupersoft\Test\config\</td>
			<td bgcolor="#dff" style="margin:0;padding:0;border:0;border-collapse:collapse;">Example.Settings.General.json</td>
				</tr>
				<tr>
			<td bgcolor="#efefef">predetermined by:</td>
			<td bgcolor="#fafafa" style="width:10px;"><code>Cliver.UserSettings</code></td>
			<td bgcolor="#fafafa" style="width:10px;">application name 'Test' and company name 'Dupersoft'</td>
			<td bgcolor="#fafafa" style="width:10px;">the full path of field <code>General</code> in the application</td>
			</tr>
			</table>
			





			
			
<h3><a name='initial_file'>Initial file</a></h3>
			<p>An <a href='#initial_file'>initial file</a> keeps the data that is to override the values hard-coded in a <a href='#settings_class'>settings type</a>'s definition. Each <a href='#settings_field'>settings field</a> can have its own <a href='#initial_file'>initial file</a> and thus can have its own initial value set distinct from the hard-coded one. 
			
			<p>It is optional and has the same format as a <a href='#storage_file'>storage file</a>.
			
		<p>An <a href='#initial_file'>initial file</a> is (re)read by <code>Reset()</code> method or, when no <a href='#storage_file'>storage file</a> exists, also by <code>Reload()</code> method.
			
			<p>It is supplied in the same directory as the application's entry assembly.
		 
			
			<p><a href='#initial_file'>Initial file</a> is used when:
			<br> - initial settings data are too big to be kept in code;
			<br> - initial settings data are managed better in a file than in code;
			<br> - the application has several <a href='#settings_field'>settings fields</a> of the same <a href='#settings_class'>type</a> and each of them must be initiated by its own value set;
						
			
			
			<h4>Name</h4>
			<p>An <a href='#initial_file'>initial file</a>'s name is predetermined by its <a href='#settings_field'>settings field</a>'s full path in the code.
									
<p>See the example:
<script type="text/plain" class="language-csharp">namespace App
{	
	public class Settings
	{
		public static GeneralSettings General;
	}
}</script>
Name of the <a href='#initial_file'>initial file</a> of the <a href='#settings_field'>settings field</a> <code>Settings.General</code> will be 'App.Settings.General.json'.



			
			
<h3>Loading</h3>
            <br><a href='#config'><code>Cliver.Config</code></a> performs loading of a <a href='#settings_field'>settings field</a> in the following order:
			
			<p><code><b>Reload()</code></b>
			<br> - from one's <a href='#storage_file'>storage file</a> if exists;
			<br> - from one's <a href='#initial_file'>initial file</a> if exists;
			<br> - from the values predefined in one's <a href='#settings_class'>settings type</a>;
		
			<p><code><b>Reset()</code></b>
			<br> - from one's <a href='#initial_file'>initial file</a> if exists;
			<br> - from the values predefined in one's <a href='#settings_class'>settings type</a>;
		
	








<h2><a name='config_usage'>Usage</a></h2>
			Reference CliverRoutines in your project.
			<br>Set your project's company name because it co-defines the directory of the <a href='#storage_file'>storage files</a>.
			
			
					
<p>Define <a href='#settings_class'>settings types</a> according to your needs like this:		
<script type="text/plain" class="language-csharp">//settings type
public class ConnectionSettings : Cliver.UserSettings //it is serialized to the user data directory
{
	public int ClientPort = 123;//serializable
	public List<Server> Servers = new List<Server>();//serializable
}

public class Server
{
	public string Name;//serializable
	public string Host;//serializable
	public int Port;	//serializable	
	internal string Status;//non-serializable
}</script>
			
			
			<p>Somewhere, declare a <a href='#settings_field'>settings field</a> for the defined <a href='#settings_class'>settings type</a>:			
<script type="text/plain" class="language-csharp">public class Settings
{
	public static ConnectionSettings Connection;//it can be property; //depending on .NET version, it can be readonly;
}</script>


        <p>Add this call at the beginning of your application, to make <a href='#config'><code>Cliver.Config</code></a> detect all <a href='#settings_field'>settings fields</a> in the code and initialize them:
<script type="text/plain" class="language-csharp">//it can be called many times; every call re-initializes all the settings.
Cliver.Config.Reload();//mandatory call before using settings</script>


         <p>      Now settings are ready to be used:
<script type="text/plain" class="language-csharp">//modify
Settings.Connection.ClientPort = 234;
Settings.Connection.Servers.Add(new Server {Name = "host1", Host = "123.123.123.123", Port = 345});
...
//save on disk
Settings.Connection.Save();
//or, restore the previously saved values
Settings.Connection.Reload();
//or, reset to the initial values
Settings.Connection.Reset();
...
//pass to a function
Server server = Settings.Connection.Servers.Find(a => a.Name == "host1");
connect(Settings.General.ClientPort, server.Host, server.Port);</script>
			<p>To find live examples, refer to CliverRoutinesExample project in CliverRoutines solution.
			<br>For the complete usage options, review <a href='#config'><code>Cliver.Config</code></a> API and annotations. 





<h2>Attached/detached instances</h2>
			  
		   <p>In the trivial use case, <a href='#settings_field'>settings fields</a> are only initialized by <a href='#config'><code>Cliver.Config</code></a> which for every <a href='#settings_field'>settings field</a> creates an instance of the respective <a href='#settings_class'>settings type</a> and sets it as the value of the field. 
		   <br>But you, too, can create or clone instances of <a href='#settings_class'>settings types</a>. And if a <a href='#settings_field'>settings field</a> is non-readonly, you can replace its value with another instance. 
<br>See <a href='#swapping_settings'>the replacing example</a>.
		   
		   <p>A <a href='#settings_class'>settings type</a> instance keeps information about its <a href='#settings_field'>settings field</a> in <code>__Info</code> object which is created only by <a href='#config'><code>Cliver.Config</code></a>. Therefore, an instance that is created by your code has <code>__Info</code> empty until you set it with the <code>__Info</code> taken from the respective instance generated by <a href='#config'><code>Cliver.Config</code></a>.		   
		   
<p>If an instance of a <a href='#settings_class'>settings type</a> is the value of the <a href='#settings_field'>settings field</a> pointed by its <code>__Info</code>, it is called <i>attached</i>, otherwise, <i>detached</i>. 
		   <br>This distinction is important because detached <a href='#settings_class'>settings type</a> instances have a restricted functionality because otherwise it would lead to a confusion. So, when replacing the value of a <a href='#settings_field'>settings field</a> with a new instance, make sure that the latter has <code>__Info</code> pointing to this <a href='#settings_field'>settings field</a>. 
		   <br>  See <a href='#passing_to_process'>the passing example</a>.





<h2><a name='config_Attributes'>Attributes</a></h2>
<p>Class <code>Cliver.SettingsAttributes</code> exposes attributes which are applicable to <a href='#settings_field'>settings fields</a> and/or <a href='#settings_class'>settings types</a>. Those attributes allow altering <a href='#settings_field'>settings fields</a> features. Attributes of a <a href='#settings_field'>settings field</a> can be accessed at runtime though its <code>__Info</code> property. For example:


<script type="text/plain" class="language-csharp">[SettingsAttributes.Config(Indented = false)]//to serialize without indention
class GeneralSettings : Cliver.UserSettings//UserSettings based class is serialized in the user directory
{
	public Dictionary<string, User> Users = new Dictionary<string, User>();

	protected override void Saving()
	{
		ConfigExample.Log.Inform0("Settings saving...: " + __Info.FullName + " with indention: " + __Info.Indented);
	}
}</script>

<p>More examples can be found in <a href="#config_Tips">the tips</a>. Refer to the API and annotations for the complete attribute list.




		 
            <h2><a name='config_Tips'>Tips</a></h2>

            <h3><a name='restoring_predefined_collections'>(!)Predefined collections</a></h3>
			
			Pay attention that when you predefine a collection of values in your code, it will be doubled every time when it is saved/restored. It is how <code>Newtonsoft.Json</code> works by default.
			<br>To alter this behavior, add the attribute as in the example below:

<script type="text/plain" class="language-csharp">public class GeneralSettings : Cliver.UserSettings
{   	
	//avoid doubling the collection's elements
    [Newtonsoft.Json.JsonProperty(ObjectCreationHandling = Newtonsoft.Json.ObjectCreationHandling.Replace)]
	public List<string> Options = new List<string>("apple", "pear", "banana"); 
}</script>
			
			
            <h3><a name=''>Ignored fields/properties</a></h3>

            To make a certain field or property not serializable, make it <code>non-public</code>. Otherwise, reference <code>Newtonsoft.Json</code> and add the attribute as in the example:
<script type="text/plain" class="language-csharp">public class GeneralSettings : Cliver.UserSettings
{   	
	//this field will not be serialized
	internal string Password; 
	
	//this field will not be serialized
	[Newtonsoft.Json.JsonIgnore]
	public string Password2;
}</script>	





            <h3><a name='swapping_settings'>Cloning and replacing</a></h3>


            <p>Sometimes it is handy to modify not a <a href='#settings_field'>settings field</a> itself but its clone and then replace it:
<script type="text/plain" class="language-csharp">//create a clone
GeneralSettings general2 = Settings.General.CreateClone();//!!!property __Info is not cloned here but references the same object.

//modify
general2.ClientPort = 123;//general2 is detached because it is not referenced by any settings field

if(userOk())
{
	Settings.General = general2;//now general2 becomes attached
	Settings.General.Save();
}</script>

<p>Or, consider the opposite case: you need to save an edited <a href='#settings_field'>settings field</a> while its clone is in use and must remain unchanged until the end of the process so that the changes will come into play after restart:
<script type="text/plain" class="language-csharp">//create a clone which should not be changed
GeneralSettings general0 = Settings.General.CreateClone();
//using it until the end of the process...

...
//modify the original
general.ClientPort = 123;
//save it so that the changes will come into play after restart
Settings.General.Save();</script>




            <h3><a name=''>Polymorphism</a></h3>
Being ordinary C# classes, <a href='#settings_class'>settings types</a> allow polymorphism. That is, you can build many <a href='#settings_class'>settings types</a> inheriting from the same parent and easily switch between them depending on the application logic. See the example.

<p>Define a base <a href='#settings_class'>settings type</a> and its derivatives:
<script type="text/plain" class="language-csharp">//base settings class which you will reference in your code
abstract public class Settings : Cliver.UserSettings
{
	virtual public string Uri { get; set; }

	//a settings field which is nested in its own settings type
	//it is ignored by the serialization engine because it is static
	public static Settings This { get; internal set; }
}

//derivative1 implementing certain logic
public class Settings1 : Settings
{
	override public string Uri { get; set; } = "http://www.help.com/doc1.html";

	//a settings field which is nested in its own settings type
	//it is ignored by the serialization engine because it is static
	public static Settings1 This;
}

//derivative2 implementing certain logic
public class Settings2 : Settings
{
	override public string Uri { get; set; } = "http://www.help.com/doc2.html";

	//a settings field which is nested in its own settings type
	//it is ignored by the serialization engine because it is static
	public static Settings2 This;
}</script>

<p>Now, without regard to the actual derivative, you can use <code>Settings.This</code> uniformly:
<script type="text/plain" class="language-csharp">//Initialize the settings fields
Config.Reload();
//set the required derivative
Settings.This = Settings1.This;
...
//using Settings.This uniformly without regard to the actual derivative
Process.Start(Settings.This.Uri);
Settings.This.Uri = "http://www.help.com/doc3.html"; 
Settings.This.Save();</script>









<h3><a name='configEncrypting'>Encrypting</a></h3>

            <h4><a name=''>Settings field/type</a></h4>
A whole <a href='#settings_field'>settings field</a> can be serialized as an encrypted string by adding the attribute <code>Encrypted</code> either to the <a href='#settings_field'>settings field</a> or to its <a href='#settings_class'>type</a> definition:
		<script type="text/plain" class="language-csharp">//An example of encrypting a Settings type/field
partial class Settings
{
	//Alternatively, the Encrypted attribute can be added directly to the field:
	//[SettingsAttributes.Encrypted(endecGetterHostingType: typeof(Settings), endecGetterName: nameof(Settings.Endec))]
	//This object will be serialized as encrypted string
	internal static CredentialsSettings Credentials;

	//A Endec2String object passed into SettingsFieldAttribute.EncryptedAttribute
	internal static Endec2String Endec { get; } = new Endec2String.Rijndael("111"); //recommended way
	//Alternatives:
	//internal static Endec2String Endec { get; } = new Endec2String(new Endec.Rijndael("111"));//general way
	//internal static StringEndec Endec { get; } = new StringEndec.Rijndael("111");//(!)deprecated!
	//An alternative by CliverWinRoutines that does not require a key:
	//internal static Endec2String Endec { get; } = new Cliver.Win.Endec2String.ProtectedData();//recommended way
	//internal static Endec2String Endec { get; } = new Endec2String(new Cliver.Win.Endec.ProtectedData());//general way
	//internal static Cliver.StringEndec Endec { get; } = new Cliver.Win.StringEndec();//(!)deprecated!
}

//This attribute can be applied to either a Settings type or a Settings field. Being applied to a type, it causes any field of the type to be encrypted.
//Specify the class and the property that expose a Endec2String object to be used for encryption.
[SettingsAttributes.Encrypted(endecGetterHostingType: typeof(Settings), endecGetterName: nameof(Settings.Endec))]
class CredentialsSettings : Cliver.UserSettings
{
	public string Key = "test";
	public string Token = "123";
}</script>

<p><code>Settings.Credentials</code> will be stored in <a href='#storage_file'>the storage file</a> as a string encrypted by the <code>StringEndec</code> instance that you provided.








            <h4><a name=''>Serializable field</a></h4>
Also, it is possible to encrypt a <a href='#settings_field'>settings field</a> not as a whole but only its certain member(s) (i.e. <a href='#serializable_field'>serializable fields</a>). How it is done:
<script type="text/plain" class="language-csharp">partial class Settings
{
	public static ServerSettings Server { get; set; }
}

class ServerSettings : Cliver.UserSettings//UserSettings based class is serialized in the user directory
{
	static ServerSettings()
	{
		//if you are not on Windows and cannot use CliverWinRoutines, you have to initialize Encrypted<> explicitly with a key
		Cliver.Encrypted<string>.InitializeDefault(new Cliver.Endec2String.Rijndael("123"));//recommended way
		//Alternatives:
		//Cliver.Encrypted<string>.InitializeDefault(new Cliver.Endec2String(new Endec.Rijndael("123")));//general way
		//Cliver.Encrypted<string>.InitializeDefault(new Cliver.StringEndec.Rijndael("123"));//(!)deprecated!
	}

	public string Host = "";
	public int Port = 123;
	//This field is encrypted. It decrypts its value only when explicitly called.
	public Cliver.Encrypted<string> Password = new Cliver.Encrypted<string>();
	//Windows alternative provided by CliverWinRoutines:
	//public Cliver.Encrypted<string> Password = new Cliver.Win.Encrypted<string>();
}</script>

<p>Now you can use it like this:
<script type="text/plain" class="language-csharp">Settings.Server.Password.Value = password;
Settings.Server.Save();

...
connect(Settings.Server.Host, Settings.Server.Password.Value);</script>

<p>With this encryption, the value is kept encrypted almost all the process time, being decrypted only when called explicitly. It is more secure against RAM sniffers.







            <h3><a name='passing_to_process'>Passing to another process</a></h3>
You can pass a <a href='#settings_field'>settings field</a> to another process. It should be done through serialization.

<p>In process 1:
<script type="text/plain" class="language-csharp">string generalStr = Cliver.Serialization.Json.Serialize(Settings.General);

//pass generalStr to process 2...</script>

<p>In process 2:
<script type="text/plain" class="language-csharp">//restore
GeneralSettings general = Cliver.Serialization.Json.Deserialize(generalStr);
//modify
general.Files.Add("c:\\other.txt");
//serialize
generalStr = Cliver.Serialization.Json.Serialize(general);

//pass generalStr back to process 1...</script>

<p>In process 1:
<script type="text/plain" class="language-csharp">//accept modifications
GeneralSettings general2 = Cliver.Serialization.Json.Deserialize(generalStr);
//!!!do not forget to restore __Info as it was distorted by serialization
general2.__Info = Settings.General.__Info;
Settings.General = general2;
Settings.General.Save();</script>











            <h3><a name=''>Upgrading settings type</a></h3>
Sometimes, when you upgrade an application, a <a href='#settings_class'>settings type</a> in it is changed that way that the new application cannot deserialize properly a <a href='#storage_file'>storage file</a> produced by an older application. When it happens, <a href='#config'><code>Cliver.Config</code></a> engine calls method <code>UnsupportedFormatHandler()</code> which you can override.

<p><code>UnsupportedFormatHandler()</code> is called in the following cases:
<br>- deserialization engine thew an exception meaning that the <a href='#settings_field'>settings field</a> could not be deserialized and is set to a default value;
<br>- the <a href='#settings_field'>settings field</a> was deserialized but its type version is still not acceptable meaning that some restored data may be deteriorated and need amending. This can be the case only if attribute <code>TypeVersion</code> is specified;

<p><b>TypeVersion attribute</b>
<br>By adding the attribute <code>TypeVersion</code> to a certain <a href='#settings_class'>settings type</a> you assign a version to its definition in the code. When the application serializes an instance of this <a href='#settings_class'>settings type</a>, its version is stored in the <a href='#storage_file'>storage file</a> as <code>__TypeVersion</code> property. Each time when you alter the <a href='#settings_class'>settings type</a>'s definition, you should also alter its version specified by the attribute. Thus, when a newer application reads an older <a href='#storage_file'>storage file</a> or vice versa, an older application reads a newer <a href='#storage_file'>storage file</a>, the type version in the <a href='#storage_file'>storage file</a> does not correspond to the version set by the attribute and therefore <a href='#config'><code>Cliver.Config</code></a> engine will call <code>UnsupportedFormatHandler()</code>.

<p>No matter why <code>UnsupportedFormatHandler()</code> was called, within it you can provide a smooth migration of old data to the new format. See the example below:

<p>
<script type="text/plain" class="language-csharp">//An example of upgrading a Settings type 
partial class Settings
{
	internal static TemplatesSettings Templates;
}

public class Template
{
	public string Name;
	public List<string> Words = new List<string>();
}

//Example how to check the type version and migrate to the current type if needed.
//When this attribute is set, Config checks if the version set by the attribute accords with the version saved in the storage file.
[SettingsAttributes.TypeVersion(210701)]
class TemplatesSettings : Cliver.UserSettings//UserSettings based class is serialized in the user directory
{
	public List<Template> Templates = new List<Template> { new Template { Name = "test", Words = new List<string> { "apple", "box" } } };

	//Here is your chance to upgrade the data to the current format.
	override protected void UnsupportedFormatHandler(Exception deserializingException)
	{
		try
		{
			if (deserializingException != null)
				throw deserializingException;

			//the object was deserialized but its __TypeVersion is not acceptable
			//successive upgrading from version to version using different approaches:
			if (__TypeVersion < 200601)
			{//editing the data as JSON object
				//remove property Field which does not exist anymore
				Newtonsoft.Json.Linq.JObject o = __Info.ReadStorageFileAsJObject();
				for (int i = o["Templates"].Count() - 1; i >= 0; i--)
					o["Templates"][i]["Field"]?.Remove();
				//set the respective version
				o["__TypeVersion"] = 200601;
				//save
				__Info.WriteStorageFileAsJObject(o);
				Reload();//UnsupportedFormatHandler() will be called again because __TypeVersion is still obsolete
				return;
			}
			if (__TypeVersion < 210301)
			{//editing the data as string
				string s = __Info.ReadStorageFileAsString();
				//edit the old data as a serialized string. It is the most low-level option of data altering.
				//...
				//set the respective version                
				__Info.UpdateTypeVersionInStorageFileString(210301, ref s);
				//save
				__Info.WriteStorageFileAsString(s);
				Reload();//UnsupportedFormatHandler() will be called again because __TypeVersion is still obsolete
				return;
			}
			if (__TypeVersion < __Info.TypeVersion)
			{//altering this object itself
				foreach (Template t in Templates)
					t.Name = Regex.Replace(t.Name, @"^test", "_TEST_");
				//...
				//save
				Save();//(!)when saving, the current type version is set
				return;
			}

			//the type version in the file is newer than supported by this method
			throw new Exception("Unsupported version of " + GetType().FullName + ": " + __TypeVersion + ". Accepted version: " + __Info.TypeVersion, deserializingException);
		}
		catch (Exception e)
		{
			Log.Error(e);
			Console.WriteLine("Error while loading " + __Info.File);
			Console.WriteLine("The application will exit now. If you still want to run it, remove the file or, to preserve it, move it to a safe location."
				+ "The file's data will be reset by this application to their default state.");
			Console.WriteLine("Press a key...");
			Console.ReadKey();
			Log.Exit("Settings " + __Info.FullName + " could not be loaded.");
		}
	}
}</script>









            <h3><a name='config_Load_order'>Load order</a></h3>
Sometimes, if <a href='#settings_class'>settings types</a> depend on each other, you may need to configure the order in which they are initialized. It can be done by setting <code>InitializationOrderedSettingsTypes</code> before calling <code>Reload()</code>:
<script type="text/plain" class="language-csharp">Config.InitializationOrderedSettingsTypes = new System.Collections.Generic.List<Type> { typeof(GeneralSettings), typeof(TemplatesSettings) };
Config.Reload();</script>













            <!--h3><a name='initialazing_order'>Initialization order</a></h3>
You can pass a <a href='#settings_field'>settings field</a> to another process. It should be done through serialization.

<p>In process 1:
<script type="text/plain" class="language-csharp">string generalStr = Cliver.Serialization.Json.Serialize(Settings.General);

//pass generalStr to process 2...</code>
</pre-->



            <h1><a name='log'>Log</a></h1>
        <p>
            <a href='#log'><code>Cliver.Log</code></a> is a logger designed with usability and scalability in mind. 

<p><b>Features:</b>

<br> - cross-platform;
<br> - thread-safe;
<br> - <a href="#log_session">session</a> oriented - an application can write multiple log <a href="#log_session">sessions</a> successively or simultaneously. It is helpful when an application performs multiple independent tasks;
<br> - <a href="#thread_log">thread</a> oriented - it can automatically write a log per thread;
<br> - auto-cleanup of old logs;
<br> - diagnostic output;

<p>To grasp how to use it for logging sufficient in the most applications, refer directly to <a href='#log_usage'>the usage</a>.		



            <h2><a name='log_session'>Session</a></h2>

A <a href='#log_session'>session</a> is a collection of logs that is dedicated to a certain logical task. Usually a log belongs to some <a href='#log_session'>session</a> (but can be a <a href='#log_Sessionless_log'>sessionless log</a>). 
			
			<p>Depending on <a href='#log'><code>Cliver.Log</code></a> configuration, it is either:
			<br> - all the <a href='#log_session'>sessions</a> share the same folder. Log files have their session name in their names;
			<br> - or, each <a href='#log_session'>session</a> creates its own folder to which all its logs are written;
			
            <p> Session folders can be used to store additional data like caches etc.
			
			<p> Multiple <a href='#log_session'>sessions</a> can be open simultaneously.
			
			<p>Using an explicitly created <a href='#log_session'>session</a>:
<script type="text/plain" class="language-csharp">using Cliver;
...
//make each session create its own folder
Log.Initialize(Log.Mode.FOLDER_PER_SESSION);
...
//create or get the existing session
Log.Session game1Log = Log.Session.Get("Game1");
//write to the default log of the session
game1Log.Debug("message");
...
//close all the file handlers beloning to the session.
game1Log.Close(true);//optional call to free memory</script>			
			


			<h3><a name='log_default_session'>Head session</a></h3>
<a href='#log_default_session'>The default session</a> is a <a href='#log_session'>session</a> that is used when no <a href='#log_session'>session</a> is called explicitly. It is referenced as <code>Head</code> and has an empty name.

			<p><a href='#log_default_session'>The default session</a> is used for the trivial logging which is sufficient for the most applications:

<script type="text/plain" class="language-csharp">using Cliver;
...
//write to the default log of the default session
Log.Write("message");//shortcut for Log.Head.Write("message");</script>




			<h3><a name='default_log'>Default log</a></h3>
<a href='#default_log'>The default log</a> of a <a href='#log_session'>session</a> is the log that is called without explicit reference. Depending on <a href='#log'><code>Cliver.Log</code></a> configuration, it can be either <a href='#main_log'>the main log</a> (by default) or <a href='#thread_log'>thread log</a>.
		
    <p><a href='#default_log'>The default log</a> is handy as a shortcut for trivial logging when everything is written to the same file:
<script type="text/plain" class="language-csharp">using Cliver;
...
Log.Inform("test message");//shortcut for Log.Head.Main.Inform()</script>

			<p>Toggle <a href='#default_log'>the default log</a> to <a href='#thread_log'>thread log</a>:
<script type="text/plain" class="language-csharp">Log.Initialize(Log.Mode.DEFAULT_THREAD_LOG);//thread log will be used by default
Log.Inform("test message");//shortcut for Log.Head.Thread.Inform()</script>






			<h3><a name="#log_root_directory">Root directory</a></h3>
<br>
			All <a href='#log_session'>sessions</a> are created within the <a href="log_root_directory">root directory</a> which is defined at the first logging or by <code>Log.Initialize()</code>
			
			
			<p>By default, the <a href="log_root_directory">root directory</a> is defined in the order by which <a href='#log'><code>Cliver.Log</code></a> tries to write to:
			<br> - the user data folder;
			<br> - the common data folder;
			<br> - the folder where the application is located;
			<br> - the user desktop folder;
			<br> - the temp folder;
			
			<p>The <a href="log_root_directory">root directory</a> definition can be customized while initializing:
<script type="text/plain" class="language-csharp">//optional initialization before using logs
Log.Initialize(Log.Mode.FOLDER_PER_SESSION, new List<string> { Log.AppCompanyCommonDataDir });//logs will be recorded to the common data folder</script>





    <h2><a name='named_log'>Named log</a></h2>
    <a href='#named_log'>Named log</a> is a log that can be referenced by a custom name.
	<p>The name of a <a href='#named_log'>named log</a> is a part of its file name.

			
 <p>   Writing to a named log of <a href='#log_default_session'>the default session</a>:
<script type="text/plain" class="language-csharp">//writing to the log "Inform" of the default session
Log.Session.NamedWriter informLog = Log.Head["Inform"];
Log.Session.NamedWriter errorLog = Log.Head["Error"];
try
{
	informLog.Inform("test message");
}
catch (Exception e)
{
	errorLog.Error2("Failed", e);
}</script>

 <p>   Writing to a named log of an explicitly created <a href='#log_session'>session</a>:
<script type="text/plain" class="language-csharp">Log.Session game1Session = Log.Session.Get("Game1");

//to the main log
game1Session.Write("test message");

//to the log named "Test"
game1Session["Test"].Write("test message");</script>





			<h3><a name='main_log'>Main log</a></h3>
<a href='#main_log'>The main log</a> of a <a href='#log_session'>session</a> is a <a href='#named_log'>named log</a> that is not created explicitly and is referenced as <code>Main</code>. It has an empty name.

		
    
    <p><a href='#main_log'>The main log</a> is handy as a ready-to-use log:
<script type="text/plain" class="language-csharp">using Cliver;
...

//writing to the main log in the default (Head) session
Log.Main.Inform0("test message");//It is a shortcut for Log.Head.Main.Inform()</script>

Or:
<script type="text/plain" class="language-csharp">//writing to the main log of session "Game1"
Log.Session game1Session = Log.Session.Get("Game1");
game1Session.Main.Inform0("test message");</script>






    <h2><a name='thread_log'>Thread log</a></h2>
    <p>A <a href='#thread_log'>thread log</a> is a log that belongs to only one and the same .NET thread.
	
	<p>Each <a href='#thread_log'>thread log</a> has a unique ID which is a part of its file name. Depending on configuration, those ID's can be reused or be endlessly incremented for each new <a href='#thread_log'>thread log</a>.
	
	<p>In this example, each downloading thread writes its own log:
<script type="text/plain" class="language-csharp">using Cliver;
...

static void download(string uri)
{
	try
	{
		//each download thread writes its own log in the default (Head) session
		Log.Thread.Inform("test message"); //It is a shortcut for Log.Head.Thread.Inform()
	}
	catch (Exception e)
	{
		Log.Thread.Error2(e);
	}
}

static void Main(string[] args)
{
	//launch a number of parallel theads
	ThreadRoutines.Start(() => { download("http://file.com/1"); });
	...
	ThreadRoutines.Start(() => { download("http://file.com/N"); });
}</script>




    <h2><a name='log_Sessionless_log'>Sessionless log</a></h2>
    <p>A <a href='#log_Sessionless_log'>sessionless log</a> is a named log that is created within the <a href="log_root_directory">root directory</a> and does not belongs to a <a href='#log_session'>session</a> so that it is continued with the next launch of the application.
	
	<p>Example:
<script type="text/plain" class="language-csharp">Log.Writer historyLog = Log.Get("history");//create or retrieve the log
historyLog.Inform("sessionless log");</script>






            <h2><a name='log_usage'>Usage</a></h2>
			Reference CliverRoutines in your project.
			<br>Set your project's company name because it co-defines the log directory.
			
		
        <p> At the beginning of the application, add optional initialization:
<script type="text/plain" class="language-csharp">using Cliver;
...

//optional configuration. See the API and annotations for options.
Log.Level = Log.Level.WARNING;

//optional initialization. It can be called many times; every call closes all the logs and re-initializes the engine.
Log.Initialize(Log.Mode.FOLDER_PER_SESSION); //this call is not mandatory if you are ok with default settings.</script>


         <p>      Write to log:
<script type="text/plain" class="language-csharp">Log.Inform("test message"); //trivial logging</script> 
			<p>To see live examples, refer to CliverRoutinesExample project in CliverRoutines solution. 
			<br>For the complete usage options, review <a href='#log'><code>Cliver.Log</code></a> API and annotations.
		 
  






    <h1><a name='miscellaneous'>Miscellaneous</a></h1>
<p>CliverRoutines exposes a number of auxiliary routines. See the API and annotations for details.







    </div>

    <div class='footer'>
        <script src='copyright.js'></script>
        &nbsp;2006 - 2021&nbsp;&nbsp;<a href="javascript:window.location.href = '&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#115;&#101;&#114;&#103;&#101;&#121;&#46;&#115;&#116;&#111;&#121;&#97;&#110;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#109;'" target="_top">Sergiy Stoyan</a>
       
    </div>

    <!--script>
    var cs = document.getElementsByTagName('code');
    for(var i = 0; i < cs.length; i++)
        cs[i].classList.add("language-csharp");
    </script-->

    <script>
        if (!window.location.href.match(/\#./ig)) {
            window.location.href = window.location.href.replace(/#.*/, '') + '#1';
            location.reload();
        }
    </script>
    <script src='menu_generator.js' shiftHeaderAndFooterToContentView=''></script>

</body>
</html>