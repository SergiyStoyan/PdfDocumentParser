<html>
<head>
    <title>CliverRoutines</title>

    <link rel="stylesheet" type="text/css" href="main.css">
    <link rel="stylesheet" type="text/css" href="menu_generator.css">

    <link href="prism.css" rel="stylesheet" />

</head>
<body>
    <script src="prism.js"></script>
    <div class='header'>
        <div class='mainHeader'>CliverRoutines 5.*</div>
    </div>

    <div class='content'>
        <h1><a name='overview'>Overview</a></h1>
        <p> CliverRoutines is a cross-platform C# lib which contains:

 <ul>
                <li> <a href="#config">application settings manager</a> superseding .NET <code>ConfigurationManager</code>;</li>
                <li> <a href="#log">logger</a> with <a href='#thread_log'>threading</a> and <a href='#log_session'>session</a> support;</li>
                <li> <a href="#miscellaneous">auxiliary routines</a>;</li>
            </ul>
			
<p><b>Compatibility</b>
<br>CliverRoutines has been developed in .NET Standard 2.0 and supposed to run on any platform that adopts C# including .NET, Xamarin, Mono.			
<br>A possible concern about certain platform might arise due to peculiarities of its file system.

			<p>CliverRoutines has been used on:
<br> - Windows 7, 10 in C# projects including windows services;
<br> - macOS High Sierra 10.12 in Xamarin.Mac projects built in Visual Studio for Mac;


            <h2><a name='licensing'>Licensing</a></h2>
			
			 See <a href='https://raw.githubusercontent.com/sergeystoyan/CliverRoutines/master/LICENSE' target='_blank'>the license source</a>.
			<br><br>
			<textarea id="license" rows="30" cols="100">
           
</textarea>
<script>
function setLicense() {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', 'https://raw.githubusercontent.com/sergeystoyan/CliverRoutines/master/LICENSE');
    xhr.send(null);

    xhr.onreadystatechange = function () {
        var status = 4;
        var http_code = 200;
        if (xhr.readyState === status) {
            if (xhr.status === http_code)  {
                var textarea = document.getElementById('license');
                textarea.value = xhr.responseText;
            } else {
                // do something with an error here
            }
        } 
    }
};

setLicense();
</script>
        <p>*Notice that CliverRoutines may use third-party software as command line tools or linked libraries which should be licensed independently.

            <h2><a name='licensing'>Source code</a></h2>
            Open <a href='https://github.com/sergeystoyan/CliverRoutines' target='_blank'>repository</a>.
        <p>
            Do not download the latest code from a branch because it may be under development. Instead, use the latest (pre-)release code.




            <h1><a name='config'>Config</a></h1>

<a href='#config'><code>Cliver.Config</code></a> is an application settings manager intended as a capable, yet simple in use replacement for .NET ConfigurationManager.

<p><b>Features:</b>

<br> - cross-platform;
<br> - natively enables setting types of any complexity and functionality;
<br> - settings are easily modified directly in code;
<br> - enables settings polymorphism;
<br> - thread-safe;
<br> - serializes data in JSON;


<p><b>Idea:</b> 

<br><a href='#settings_class'>Settings types</a> are ordinary C# classes that you define in your code according to your needs thus achieving a great flexibility. <a href='#config'><code>Cliver.Config</code></a> automatically detects <a href='#settings_field'>fields/properties</a> having those types and facilitates their serialization/deserialization to/from disk.

<p>While <a href='#config'><code>Cliver.Config</code></a> was designed primarily as a settings manager, in conjunction with <code>System.Linq</code> it can be used as a simple nosql database.			

<p>To grasp how to use it by example, refer directly to <a href='#config_usage'>the usage</a>.	
			
			
			
			
			
			

<h2><a name='settings_class'>Settings type</a></h2>
<a href='#settings_class'>Settings type</a> is a custom class whose fields and properties are serialized/deserialized according to the needs of the application. 

<p>While generally a <a href='#settings_class'>settings class</a> should be considered a fully functional class, it must comply with the following conditions:
<br> - it must inherit from <a href='#cliver_settings'><code>Cliver.Settings</code></a> class. This inheritance can be indirectly via another classes;
<br> - it must either have no explicit constructor or have a <code>public</code> parameterless one;
		
<p>There can be any number of <a href='#settings_class'>settings types</a> defined in your code.

			
			
<p>Example of a <a href='#settings_class'>settings type</a>:			
<pre>
<code class="language-csharp">public class GeneralSettings : Cliver.UserSettings //serialized to the user data directory.
{   	
	public List&lt;string&gt; RecentFiles; 	
	public Color HighlightColor = Color.Orange;
	
	protected override void Loaded()
	{
		if(RecentFiles == null)
			RecentFiles = new List<string>(); 
	}
	
	protected override void Saving()
	{
		RecentFiles = RecentFiles.Distinct();
	}
}</code>
</pre>

	
	
	
			
			

<h3><a name='serializable_field'>Serializable fields</a></h3>
<a href='#serializable_field'>Serializable fields</a> are fields or properties of a <a href='#settings_class'>settings class</a> that are (!)<code>public</code> and non-static. Optionally they can be <code>readonly</code>.

<p>Serialization/deserialization is performed by <a href='https://www.newtonsoft.com/json'>Newtonsoft.Json</a> engine.			
Hence, you can apply attributes provided by Newtonsoft.Json to <a href='#serializable_field'>serializable fields</a> to alter their serialization behavior. To do so, you have to reference Newtonsoft.Json in your project. (!)To avoid compilation problems, make sure that it is the same version that is referenced by CliverRoutines. For more info refer to <a href='https://www.newtonsoft.com/json'>Newtonsoft.Json</a> documentation. 			
			
<p>(!)While a <a href='#settings_class'>settings class</a> can implement any logic and members, remember that nevertheless there are restrictions for what and how can be serialized. For instance, data which depend on the current application state like <code>events, FieldInfo</code> types will be lost through serialization.





						
            <h3><a name='cliver_settings'>Cliver.Settings</a></h3>
			<a href='#cliver_settings'><code>Cliver.Settings</code></a> is a base class for building custom <a href='#settings_class'>settings types</a> in your code.
<p>It exposes the members that allow managing serialization routine in its derivatives:
<br> - property <code>__Info</code> which links an instance of <a href='#settings_class'>a settings type</a> to a certain <a href='#settings_field'>settings field</a>;
<br> - serialization methods;
<br> - auxiliary methods. Some of them can be redefined in your <a href='#settings_class'>settings class</a> if needed;
<br>See the API for more info.

        <p>			Usually you will not inherit <a href='#cliver_settings'><code>Cliver.Settings</code></a> directly and use one of its derivatives provided by CliverRoutines: <a href="#cliver_usersettings"><code>Cliver.UserSettings</code></a> and <a href="#cliver_appsettings"><code>Cliver.AppSettings</code></a>.
			<br>If your <a href='#settings_class'>settings class</a> inherits <a href='#cliver_settings'><code>Cliver.Settings</code></a> directly then you have to define the serialization directory in it.



            <h4><a name="cliver_usersettings">Cliver.UserSettings</a></h4>
<a href="#cliver_usersettings"><code>Cliver.UserSettings</code></a> is a <a href='#cliver_settings'><code>Cliver.Settings</code></a> derivative which performs serialization to the current user's application data directory. 




            <h4><a name="cliver_appsettings">Cliver.AppSettings</a></h4>
<a href="#cliver_appsettings"><code>Cliver.AppSettings</code></a> is a <a href='#cliver_settings'><code>Cliver.Settings</code></a> derivative which performs serialization to the common (user-irrelevant) application data directory. 
<p>(!)Writing to this directory on Windows may require additional permissions which is solved by <code>Cliver.Win.AppSettings</code> in CliverWinRoutines package.

				    
				   
		

			


			
<h2><a name='settings_field'>Settings field</a></h2>
<p>(!)Do not confuse <a href='#settings_field'>settings fields</a> with <a href='#serializable_field'>serializable fields</a>.

<p>A <a href='#settings_field'>settings field</a> is a field or property declared in any class of your app, that satisfies the following:
<br> - its type is a <a href='#settings_class'>settings type</a>;
<br> - it is <code>static</code> (<code>public</code> is optional); 

			
<p><a href='#settings_field'>Settings fields</a> are automatically detected and initialized by <a href='#config'><code>Cliver.Config</code></a>.
<p>Behavior of a <a href='#settings_field'>settings field</a> can be influenced by <code>Cliver.SettingsAttribute</code> applied to it. 

<p>There can be any number of <a href='#settings_field'>settings fields</a> in your code.
<br> Usually you will need only one <a href='#settings_field'>settings field</a> per <a href='#settings_class'>settings type</a>, but there is no problem to declare any number of <a href='#settings_field'>settings fields</a> of the same <a href='#settings_class'>settings type</a>.
				   
<p>Example of a <a href='#settings_field'>settings field</a>:
<pre><code class="language-csharp">namespace App
{
	public class Settings
	{
		//settings field
		public static readonly GeneralSettings General; //readonly is optional; it can be a property
	}
}</code>
</pre>





		
<h3>Initialization</h3>
        <br> Detection and initialization of <a href='#settings_field'>settings field</a>s must be triggered from your code. It can be preceded by optional configuration of <a href='#config'><code>Cliver.Config</code></a> (see its API).
<pre>
<code class="language-csharp">//configure. It must be done before initializing the settings.
Cliver.Config.ExplicitlyTrackedAssemblies = new List<System.Reflection.Assembly> { Assembly.GetExecutingAssembly() };//optional

//detect and initialize settings fields. 
Cliver.Config.Reload();//mandatory</code>
</pre>			   
				
				
				
				
<h3>Assembly scope</h3>
        <br>(!)When looking for <a href='#settings_field'>settings fields</a> in an application, <a href='#config'><code>Cliver.Config</code></a> searches within the following assemblies by default:
<br> - assembly that calls one of <a href='#config'><code>Cliver.Config</code></a>'s initializing methods;
<br> - assemblies that are referenced by the calling assembly;
<br>The search scope is limited this way in order not to load more assemblies which occurs inevitably when enumerating through them. 
 
<p>If needed, the assembly scope can be assigned from your code explicitly (see the API).
			
			
				   
				   
			
			
			
<h3><a name='storage_file'>Storage file</a></h3>
		<a href='#storage_file'>Storage file</a> stores serialized data for one <a href='#settings_field'>settings field</a>. Thus, every <a href='#settings_field'>settings field</a> has its own <a href='#storage_file'>storage file</a>. 
		
		<p>It is re-created by <code>Save()</code> method.
			
			
			
			<h4>Path</h4>
			<p><a href='#storage_file'>Storage file</a> path is defined as follows: file directory is predetermined by the <a href='#settings_class'>settings type</a> and file name is predetermined by the <a href='#settings_field'>settings field</a>'s full path in the code.
									
<p>See the example:
<pre>
<code class="language-csharp">namespace App
{
	public class GeneralSettings : Cliver.UserSettings
	{   	
		...
	}
	
	public class Settings
	{
		public static readonly GeneralSettings General;
	}
}</code>
</pre>
The <a href='#storage_file'>storage file</a> path of <a href='#settings_field'>settings field</a> <code>Settings.General</code> will be:
			<table style="table-layout:fixed;">
			<tr>
			<td style="border:0;">storage file path:</td>
			<td bgcolor="#ddf" style="margin:0;padding:0;border:0;border-collapse:collapse;">C:\Users\serge\AppData\Local\</td>
			<td bgcolor="#def" style="margin:0;padding:0;border:0;border-collapse:collapse;">Supersoft\App\config\</td>
			<td bgcolor="#dff" style="margin:0;padding:0;border:0;border-collapse:collapse;">App.Settings.General.json</td>
				</tr>
				<tr>
			<td>predetermined by:</td>
			<td style="width:10px;"><code>Cliver.UserSettings</code></td>
			<td style="width:10px;">application name 'App' and company name 'Supersoft'</td>
			<td style="width:10px;">the full path of field <code>General</code> in the application</td>
			</tr>
			</table>
			





			
			
<h3><a name='initial_file'>Initial file</a></h3>
			<p><a href='#initial_file'>Initial file</a> keeps data that is to override the initial values hard-coded in a <a href='#settings_class'>settings type</a> definition. Each <a href='#settings_field'>settings field</a> can have its own <a href='#initial_file'>initial file</a> and thus, can have its own initial value set. 
			
			<p>It is optional and has the same format as <a href='#storage_file'>storage file</a>.
			
		<p><a href='#initial_file'>Initial file</a> is re-read by <code>Reload()</code> or <code>Reset()</code> methods.
			
			<p>It is supplied in the same directory as the application itself.
		 
			
			<p>It is helpful when:
			<br> - initial settings data are too big to be kept in code;
			<br> - initial settings data are managed better in file than in code;
			<br> - the application has several <a href='#settings_field'>settings fields</a> of the same <a href='#settings_class'>settings type</a> and each of them must be initiated by its own value set;
						
			
			
			<h4>Name</h4>
			<p><a href='#initial_file'>Initial file</a> name is predetermined by the <a href='#settings_field'>settings field</a>'s full path in the code.
									
<p>See the example:
<pre>
<code class="language-csharp">namespace App
{	
	public class Settings
	{
		public static readonly GeneralSettings General;
	}
}</code>
</pre>
The <a href='#initial_file'>initial file</a> name of <a href='#settings_field'>settings field</a> <code>Settings.General</code> will be 'App.Settings.General.json'.



			
			
<h3>Restoring order</h3>
            <br><a href='#config'><code>Cliver.Config</code></a> performs restoring of a <a href='#settings_field'>settings field</a> in the following order:
			
			<p><code><b>Reload()</code></b>
			<br> - from one's <a href='#storage_file'>storage file</a> if exists;
			<br> - from one's <a href='#initial_file'>initial file</a> if exists;
			<br> - from the values predefined in one's <a href='#settings_class'>settings type</a>;
		
			<p><code><b>Reset()</code></b>
			<br> - from one's <a href='#initial_file'>initial file</a> if exists;
			<br> - from the values predefined in one's <a href='#settings_class'>settings type</a>;
		
	








<h2><a name='config_usage'>Usage</a></h2>
			Reference CliverRoutines in your project.
			<br>Set your project's company name because it co-defines the storage directory.
			
			
					
<p>Define <a href='#settings_class'>settings types</a> according to your needs like this one:		
<pre>
<code class="language-csharp">//settings type
public class ConnectionSettings : Cliver.UserSettings //it is serialized to the user data directory
{
	public int ClientPort = 123;//serializable
	public List&lt;Server&gt; Servers = new List&lt;Server&gt;();//serializable
}

public class Server
{
	public string Name;//serializable
	public string Host;//serializable
	public int Port;	//serializable	
	internal string Status;//non-serializable
}</code>
</pre>
			
			
			<p>Somewhere, declare a <a href='#settings_field'>settings field</a> for the defined <a href='#settings_class'>settings type</a>:			
<pre>
<code class="language-csharp">public class Settings
{
	public static readonly ConnectionSettings Connection;//readonly is optional; can be property
}</code>
</pre>


        <p>Add this call at the beginning of your application, to make <a href='#config'><code>Cliver.Config</code></a> detect all <a href='#settings_field'>settings fields</a> in the code and initialize them:
<pre>
<code class="language-csharp">//it can be called many times; every call re-initializes all the settings.
Cliver.Config.Reload();//mandatory call before using settings</code>
</pre>


         <p>      Now settings are ready to be used:
<pre>
<code class="language-csharp">//modify
Settings.Connection.ClientPort = 234;
Settings.Connection.Servers.Add(new Server {Name = "host1", Host = "123.123.123.123", Port = 345});
...
//save on disk
Settings.Connection.Save();
//or, restore the previous values instead of saving the new ones
Settings.Connection.Reload();
//or, reset to the initial values
Settings.Connection.Reset();
...
//pass to a function
Server server = Settings.Connection.Servers.Find(a => a.Name == "host1");
connect(Settings.General.ClientPort, server.Host, server.Port);</code>
</pre>
			<p>To find live examples, refer to CliverRoutinesExample project in CliverRoutines solution.
			<br>For the complete usage options, review <a href='#config'><code>Cliver.Config</code></a> API and annotations. 





<h2>Attached/detached instances</h2>
			  
		   <p>In the trivial use case, <a href='#settings_field'>settings fields</a> are only initialized by <a href='#config'><code>Cliver.Config</code></a> which for every <a href='#settings_field'>settings field</a> creates an instance of the respective <a href='#settings_class'>settings type</a> and sets it as the value of the field. 
		   <br>But you, too, can create or clone instances of <a href='#settings_class'>settings types</a>. And if a <a href='#settings_field'>settings field</a> is non-readonly, you can replace its value with another instance. 
<br>See <a href='#swapping_settings'>the replace example</a>.
		   
		   <p>A <a href='#settings_class'>settings type</a> instance keeps information about its <a href='#settings_field'>settings field</a> in <code>__Info</code> object which is created only by <a href='#config'><code>Cliver.Config</code></a>. Therefore, an instance that is created by your code has <code>__Info</code> empty until you set it with the <code>__Info</code> taken from the respective instance generated by <a href='#config'><code>Cliver.Config</code></a>.		   
		   
<p>If an instance of a <a href='#settings_class'>settings type</a> is the value of the <a href='#settings_field'>settings field</a> pointed by its <code>__Info</code>, it is called <i>attached</i>, otherwise, <i>detached</i>. 
		   <br>This distinction is important because <a href='#config'><code>Cliver.Config</code></a> manages only attached <a href='#settings_class'>settings type</a> instances, while detached ones have restricted functionality. So, when replacing the value of a <a href='#settings_field'>settings field</a> with a new instance, make sure that the latter has <code>__Info</code> pointing to this <a href='#settings_field'>settings field</a>. 
		   <br>  See <a href='#passing_to_process'>the pass example</a>.












		 
            <h2><a name=''>Tips</a></h2>

            <h3><a name='restoring_predefined_collections'>(!)Predefining collections</a></h3>
			
			Pay attention that when you predefine a collection of values in your code, it will be doubled every time when it is saved/restored. It is how Newtonsoft.Json works by default.
			<br>To alter this behavior, add the attribute as in the example below:

<pre>
<code class="language-csharp">public class GeneralSettings : Cliver.UserSettings
{   	
	//avoid doubling the collection's elements
	[JsonProperty(ObjectCreationHandling = ObjectCreationHandling.Replace)]
	public List&lt;string&gt; Options = new List&lt;string&gt;("apple", "pear", "banana"); 
}</code>
</pre>
			
			
            <h3><a name=''>Ignoring fields/properties</a></h3>

            To make a certain field or property not serializable, make it <code>non-public</code>. Otherwise, reference Newtonsoft.Json and add the attribute as in the example:
<pre>
<code class="language-csharp">public class GeneralSettings : Cliver.UserSettings
{   	
	//this field will not be serialized
	internal string Password; 
	
	//this field will not be serialized
	[Newtonsoft.Json.JsonIgnore]
	public string Password2;
}</code>
</pre>	





            <h3><a name='swapping_settings'>Cloning and replacing</a></h3>


            <p>Sometimes it is handy to modify not a <a href='#settings_field'>settings field</a> itself but its clone and then replace it:
<pre>
<code class="language-csharp">//create a clone
GeneralSettings general2 = Settings.General.CreateClone();//!!!property __Info is not cloned here but references the same object.

//modify
general2.ClientPort = 123;//general2 is detached because it is not refernced by any settings field

if(userOk())
{
	Settings.General = general2;//now general2 becomes attached
	Settings.General.Save();
}</code>
</pre>

<p>Or, consider the opposite case: you need to save an edited <a href='#settings_field'>settings field</a> while its clone is in use and must remain unchanged until the end of the process so that the changes will come into play after restart:
<pre>
<code class="language-csharp">//create a clone which should not be changed
GeneralSettings general0 = Settings.General.CreateClone();
//using it until the end of the process...

...
//modify the original
general.ClientPort = 123;
//save it so that the changes will come into play after restart
Settings.General.Save();</code>
</pre>




            <h3><a name=''>Polymorphism</a></h3>
Being ordinary C# classes, <a href='#settings_class'>settings types</a> support polymorphism. That is, you can build many <a href='#settings_class'>settings types</a> inheriting the same parent and easily switch between them depending on the application logic. See the example.

<p>Define a base <a href='#settings_class'>settings type</a> and its derivatives:
<pre>
<code class="language-csharp">//base settings class which you will reference in your code
abstract public class ScopeSettings : Cliver.UserSettings
{
	virtual public string HelpUri { get; set; }

	public static ScopeSettings Scope { get; internal set; }//(!)it is ignored by Cliver.Config because ScopeSettings is abstract class
}

//derivative1 implementing certain logic
public class Scope1Settings : ScopeSettings
{
	override public string HelpUri { get; set; } = "http://www.help.com/help1.html";

	public static Scope1Settings This;//a settings field can be nested in its own settings type
}

//derivative2 implementing certain logic
public class Scope2Settings : ScopeSettings
{
	override public string HelpUri { get; set; } = "http://www.help.com/help2.html";

	public static Scope2Settings This;
}</code>
</pre>

<p>Initialize <a href='#settings_field'>settings fields</a> and set the required scope:
<pre>
<code class="language-csharp">Config.Reload();
//choose which scope to use?
ScopeSettings.Scope = Scope1Settings.This;</code>
</pre>

<p>Now, without regard to the actual scope, you can use <code>ScopeSettings.Scope</code> uniformly:
<pre>
<code class="language-csharp">...
Process.Start(ScopeSettings.Scope.HelpUri);
...
ScopeSettings.Scope.HelpUri = "http://www.help.com/help3.html"; 
ScopeSettings.Scope.Save();</code>
</pre>






            <h3><a name='storing_password'>Storing password</a></h3>
            How to store and use passwords:
<pre>
<code class="language-csharp">public class GeneralSettings : Cliver.Win.UserSettings
{   	            
	//password will be stored on disk as an ecrypted string
	public string _EncryptedPassword = null;
	
	//it is internal so not to be serialized; otheriwse if public, use attribute [Newtonsoft.Json.JsonIgnore]
	internal string Password
	{
		get
		{
			if (string.IsNullOrEmpty(_EncryptedPassword))
				return null;
			try
			{
				return crypto.Decrypt(_EncryptedPassword);
			}
			catch(Exception e)
			{
				Cliver.Log.Error("Could not decrypt password.", e);
				return null;
			}
		}
		set
		{
			if (string.IsNullOrEmpty(value))
				_EncryptedPassword = null;
			else
				_EncryptedPassword = crypto.Encrypt(value);
		}
	}
	//on Widnows
    Cliver.Win.Crypto.ProtectedData crypto = new Cliver.Win.Crypto.ProtectedData();
	//cross-platform
    Cliver.Crypto.Rijndael crypto = new Cliver.Crypto.Rijndael("random key");
}

public class Settings
{
	public static readonly GeneralSettings General;
}</code>
</pre>

<p>Now, use it when required:
<pre>
<code class="language-csharp">Settings.General.Password = password;
Settings.General.Save();

...
connect(General.Password);</code>
</pre>







            <h3><a name='passing_to_process'>Passing to another process</a></h3>
You can pass a <a href='#settings_field'>settings field</a> to another process. It should be done through serialization.

<p>In process 1:
<pre>
<code class="language-csharp">string generalStr = Cliver.Serialization.Json.Serialize(Settings.General);

//pass generalStr to process 2...</code>
</pre>

<p>In process 2:
<pre>
<code class="language-csharp">//restore
GeneralSettings general = Cliver.Serialization.Json.Deserialize(generalStr);
//modify
general.Files.Add("c:\\other.txt");
//serialize
generalStr = Cliver.Serialization.Json.Serialize(general);

//pass generalStr back to process 1...</code>
</pre>

<p>In process 1:
<pre>
<code class="language-csharp">//accept modifications
GeneralSettings general2 = Cliver.Serialization.Json.Deserialize(generalStr);
//!!!do not forget to restore __Info as it is distorted by serialization
general2.__Info = Settings.General.__Info;
Settings.General = general2;
Settings.General.Save();</code>
</pre>








            <!--h3><a name='initialazing_order'>Initialization order</a></h3>
You can pass a <a href='#settings_field'>settings field</a> to another process. It should be done through serialization.

<p>In process 1:
<pre>
<code class="language-csharp">string generalStr = Cliver.Serialization.Json.Serialize(Settings.General);

//pass generalStr to process 2...</code>
</pre-->



            <h1><a name='log'>Log</a></h1>
        <p>
            <a href='#log'><code>Cliver.Log</code></a> is a logger designed with usability and scalability in mind. 

<p><b>Features:</b>

<br> - cross-platform;
<br> - thread-safe;
<br> - <a href="#log_session">session</a> oriented - an application can write multiple log <a href="#log_session">sessions</a> successively or simultaneously. It is helpful when an application performs multiple independent tasks;
<br> - <a href="#thread_log">thread</a> oriented - it can automatically write a log per thread;
<br> - auto-cleanup of old logs;
<br> - diagnostic output;

<p>To grasp how to use it for logging sufficient in the most applications, refer directly to <a href='#log_usage'>the usage</a>.		



            <h2><a name='log_session'>Session</a></h2>

        A <a href='#log_session'>session</a> is a collection of logs that is dedicated to a certain logical task. Every log belongs to some <a href='#log_session'>session</a>. 
			
			<p>Depending on <a href='#log'><code>Cliver.Log</code></a> configuration, it is either:
			<br> - all the <a href='#log_session'>sessions</a> share the same folder. Log files have their session name in their names;
			<br> - or, each <a href='#log_session'>session</a> creates its own folder to which all its logs are written;
			
            <p> Session folders can be used to store additional data like caches etc.
			
			<p> Multiple <a href='#log_session'>sessions</a> can be open simultaneously.
			
			<p>Using an explicitly created <a href='#log_session'>session</a>:
<pre>
<code class="language-csharp">using Cliver;
...
//make each session create its own folder
Log.Initialize(Log.Mode.FOLDER_PER_SESSION);
...
//create or get the existing session
Log.Session game1Log = Log.Session.Get("Game1");
//write to the default log of the session
game1Log.Debug("message");
...
//close all the file handlers beloning to the session.
game1Log.Close(true);//optional call to free memory</code>
</pre>			
			


			<h3><a name='log_default_session'>Head session</a></h3>
<a href='#log_default_session'>The default session</a> is a <a href='#log_session'>session</a> that is used when no <a href='#log_session'>session</a> is called explicitly. It is referenced as <code>Head</code> and has an empty name.

			<p><a href='#log_default_session'>The default session</a> is used for the trivial logging which is sufficient for the most applications:

<pre>
<code class="language-csharp">using Cliver;
...
//write to the default log of the default session
Log.Write("message");//shortcut for Log.Head.Write("message");</code>
</pre>




			<h3><a name='default_log'>Default log</a></h3>
<a href='#default_log'>The default log</a> of a <a href='#log_session'>session</a> is the log that is called without explicit reference. Depending on <a href='#log'><code>Cliver.Log</code></a> configuration, it can be either <a href='#main_log'>the main log</a> (by default) or <a href='#thread_log'>thread log</a>.
		
    <p><a href='#default_log'>The default log</a> is handy as a shortcut for trivial logging when everything is written to the same file:
<pre><code class="language-csharp">using Cliver;
...
Log.Inform("test message");//shortcut for Log.Head.Main.Inform()</code>
</pre>

			<p>Toggle <a href='#default_log'>the default log</a> to <a href='#thread_log'>thread log</a>:
<pre>
<code class="language-csharp">Log.Initialize(Log.Mode.DEFAULT_THREAD_LOG);//thread log will be used by default
Log.Inform("test message");//shortcut for Log.Head.Thread.Inform()</code>
</pre>






			<h3><a name="#base_directory">Work directory</a></h3>
<br>
			All <a href='#log_session'>sessions</a> are created within the <a href="base_directory">work directory</a> which is defined at the first logging or by <code>Log.Initialize()</code>
			
			
			<p>By default, the <a href="base_directory">work directory</a> is defined in the order by which <a href='#log'><code>Cliver.Log</code></a> tries to write to:
			<br> - the user data folder;
			<br> - the common data folder;
			<br> - the folder where the application is located;
			<br> - the user desktop folder;
			<br> - the temp folder;
			
			<p>The <a href="base_directory">work directory</a> definition can be customized while initializing:
<pre>
<code class="language-csharp">//optional initialization before using logs
Log.Initialize(Log.Mode.FOLDER_PER_SESSION, new List<string> { Log.AppCompanyCommonDataDir });//logs will be recorded to the common data folder</code>
</pre>





    <h2><a name='named_log'>Named log</a></h2>
    <a href='#named_log'>Named log</a> is a log that can be referenced by a custom name.
	<p>The name of a <a href='#named_log'>named log</a> is a part of its file name.

			
 <p>   Writing to a named log of <a href='#log_default_session'>the default session</a>:
<pre><code class="language-csharp">//writig to the log "Inform" of the default session
Log.Session.NamedWriter informLog = Log.Head["Inform"];
Log.Session.NamedWriter errorLog = Log.Head["Error"];
try
{
	informLog.Inform("test message");
}
catch (Exception e)
{
	errorLog.Error2("Failed", e);
}</code>
</pre>

 <p>   Writing to a named log of an explicitly created <a href='#log_session'>session</a>:
<pre><code class="language-csharp">Log.Session game1Session = Log.Session.Get("Game1");

//to the main log
game1Session.Write("test message");

//to the log named "Test"
game1Session["Test"].Write("test message");</code>
</pre>





			<h3><a name='main_log'>Main log</a></h3>
<a href='#main_log'>The main log</a> of a <a href='#log_session'>session</a> is a <a href='#named_log'>named log</a> that is not created explicitly and is referenced as <code>Main</code>. It has an empty name.

		
    
    <p><a href='#main_log'>The main log</a> is handy as a ready-to-use log:
<pre><code class="language-csharp">using Cliver;
...

//writing to the main log in the default (Head) session
Log.Main.Inform0("test message");//It is a shortcut for Log.Head.Main.Inform()</code>
</pre>

Or:
<pre><code class="language-csharp">//writing to the main log of session "Game1"
Log.Session game1Session = Log.Session.Get("Game1");
game1Session.Main.Inform0("test message");</code>
</pre>






    <h2><a name='thread_log'>Thread log</a></h2>
    <p>A <a href='#thread_log'>thread log</a> is a log that belongs to only one and the same .NET thread.
	
	<p>Each <a href='#thread_log'>thread log</a> has a unique ID which is a part of its file name. Depending on configuration, those ID's can be reused or be endlessly incremented for each new <a href='#thread_log'>thread log</a>.
	
	<p>In this example, each downloading thread writes its own log:
<pre>
<code class="language-csharp">using Cliver;
...

static void download(string uri)
{
	try
	{
		//each download thread writes its own log in the default (Head) session
		Log.Thread.Inform("test message"); //It is a shortcut for Log.Head.Thread.Inform()
	}
	catch (Exception e)
	{
		Log.Thread.Error2(e);
	}
}

static void Main(string[] args)
{
	//launch a number of parallel theads
	ThreadRoutines.Start(() => { download("http://file.com/1"); });
	...
	ThreadRoutines.Start(() => { download("http://file.com/N"); });
}</code>
</pre>




            <h2><a name='log_usage'>Usage</a></h2>
			Reference CliverRoutines in your project.
			<br>Set your project's company name because it co-defines the log directory.
			
		
        <p> At the beginning of the application, add optional initialization:
<pre>
<code class="language-csharp">using Cliver;
...

//optional configuration. See the API and annotations for options.
Log.Level = Log.Level.WARNING;

//optional initialization. It can be called many times; every call closes all the logs and re-initializes the engine.
Log.Initialize(Log.Mode.FOLDER_PER_SESSION); //this call is not mandatory if you are ok with default settings.</code>
</pre>


         <p>      Write to log:
<pre>
<code class="language-csharp">Log.Inform("test message"); //trivial logging</code>
</pre> 
			<p>To see live examples, refer to CliverRoutinesExample project in CliverRoutines solution. 
			<br>For the complete usage options, review <a href='#log'><code>Cliver.Log</code></a> API and annotations.
		 
  






    <h1><a name='miscellaneous'>Miscellaneous</a></h1>
<p>CliverRoutines exposes a number of auxiliary routines. See the API and annotations.







    </div>

    <div class='footer'>
        <script src='copyright.js'></script>
        &nbsp;2006 - 2021&nbsp;&nbsp;<a href="javascript:window.location.href = '&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#115;&#101;&#114;&#103;&#101;&#121;&#46;&#115;&#116;&#111;&#121;&#97;&#110;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#109;'" target="_top">Sergey Stoyan</a>
       
    </div>

    <!--script>
    var cs = document.getElementsByTagName('code');
    for(var i = 0; i < cs.length; i++)
        cs[i].classList.add("language-csharp");
    </script-->

    <script>
        if (!window.location.href.match(/\#./ig)) {
            window.location.href = window.location.href.replace(/#.*/, '') + '#1';
            location.reload();
        }
    </script>
    <script src='menu_generator.js' shiftHeaderAndFooterToContentView=''></script>

</body>
</html>